syntax = "proto2";

package nio.proto;

import "geometry.proto";
import "path.proto";
import "perception_object.proto";
import "config_planner.proto";
import "car_state.proto";


message TrajectoryConfig {}

message CarParam {
  optional double mass = 1;
  optional double inertia = 2;
  optional double wheel_base = 3;
  optional double front_to_gc = 4;
  optional double c_alpha_front = 5;
  optional double c_alpha_rear = 6;
  optional double c_torque_front = 7;
  optional double c_torque_rear = 8;
  optional double air_resistance_coefficient = 9;
  optional double gravity = 10;
}

message ControlConfig {
  optional CarParam car_param = 10;
  optional double step_time = 2;
}

message SimEgoCarConfig {
  optional double init_position_x = 1;
  optional double init_position_y = 2;
  optional double init_position_z = 3 [default = 0.0];
  optional double init_speed = 4 [default = 0.0];
  optional double init_acceleration = 5 [default = 0.0];
  optional double init_theta = 6 [default = 0.0];
  optional CarState.GearStatus init_gear = 7;

  oneof EgoStateUpdateConfig {
    TrajectoryConfig trajectory_config = 8;
    ControlConfig control_config = 9;
  }
}

message SimObjectConfig {
   
  optional uint64 id = 1;

  optional PerceptionObject.Type type = 2;

  optional Vector3d dimension = 3;  // length/width/height

  // if path is set directly, will not be generated by route
  // since stopline is detected by overlaps in route, object can not stop in stopline without route
  optional Path path = 4;

  // generate route by route_config, then generate path by route
  // should use method 2a&2b to generate route, method is defined in config_planner.proto
  optional ConfigRouting route_config = 5;

  optional double speed = 6 [default = 5.0];

  optional double acceleration_max = 7 [default = 2.0];

  optional double deceleration_max = 8 [default = 5.0];

  // objects run in route repeatedly
  optional bool repeation = 9  [default = false];

  // whether stop in stop line
  optional bool stop_by_sign = 10  [default = false];

  optional double stop_line_wait_time = 11 [default = 3.0];

  // objects show after time_delay seconds
  optional double time_delay = 12;

  // objects show when distance to ego car is smaller than start_distance_to_ego
  optional double start_distance_to_ego = 13;
} 

message SimSignalConfig {

  optional uint64 traffic_light_id = 1;

  // for lights with two types, the order is red->green
  // total time is red_duration + green_duration
  // for lights with three types, the order is red->yellow->green
  // total time is green_duration + yellow_duration + red_duration
  // set start_time within total time to decide start light type
  optional double start_time = 2 [default = 1];

  optional double green_duration = 3 [default = 10.0];

  optional double yellow_duration = 4 [default = 3.0];

  optional double red_duration = 5 [default = 10.0];

  optional double white_duration = 6 [default = 10.0];

  // add all traffic lights in route
  // should use method 2a&2b to generate route, method is defined in config_planner.proto
  optional ConfigRouting route_config = 7;

  // if true, the traffic light is generated by id;
  // if false, the traffic light is generated by route
  // if traffic light is generated by route and certain traffic_light_id exist in another SimSignal message,
  // traffic light will follow the SimSignal message that has the matching traffic_light_id
  optional bool generated_by_id = 8 [default = false];
}

message SimulatorConfig { 
  optional SimEgoCarConfig sim_ego_car_config = 1;
  // the whole scene include multiple objects
  repeated SimObjectConfig sim_objects_config = 2;
  repeated SimSignalConfig sim_signals_config = 3;
  optional double simulation_time_step = 4 [default = 0.1];
  optional string road_map_filename = 5;
}

