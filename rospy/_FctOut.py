# This Python file uses the following encoding: utf-8
"""autogenerated by genpy from rospy_message_converter/FctOut.msg. Do not edit."""
import codecs
import sys
python3 = True if sys.hexversion > 0x03000000 else False
import genpy
import struct

import rospy_message_converter.msg

class FctOut(genpy.Message):
  _md5sum = "e8e4acc12816e15f4ac82ab3c124c9c3"
  _type = "rospy_message_converter/FctOut"
  _has_header = False  # flag to mark the presence of a Header object
  _full_text = """AhcOut Ahc
LatCtrlOut LatCtrl
LonCtrlOut LonCtrl
HwaOut Hwa
LdwOut Ldw
SasOut Sas
HeaterOut Heater
ElkOut Elk
FunctionXstatus[] Function
AcmEdrOut AcmEdr
HMIIconOut HmiIcon
EasOut Eas
float64[] Reserved
SnsrStsOut SesrSts
RcvProtoPTPTimeOut RcvProtoPTPTime
uint64 publish_ptp_ts
string publisher_id
uint64 counter
uint64 publish_ts

================================================================================
MSG: rospy_message_converter/AhcOut
int32 AhcSysSt
bool AhcHiBmReq

================================================================================
MSG: rospy_message_converter/LatCtrlOut
int32 ExtReqCAMFC
int32 LeLineTyp
int32 RiLineTyp
int32 LeTrackingSts
int32 RiTrackingSts
int32 LaneAssiTyp
int32 LkaSnsvty
float32 AbsltPinionAgReq
int32 EPSReqTyp
int32 LkaLnAsstSts
int32 LkaHODWarnSeq
bool LatCtrlActv
int32 EPSACITsuSup
int32 VMC1ACITsuSup
int32 LatCtrlTarLe
int32 LatCtrlTarRi
ALCSOut AlcsInfo

================================================================================
MSG: rospy_message_converter/ALCSOut
uint32 DA_LaneChgSupReason
uint32 AlcManeuverSts
uint32 DA_ALCSsts
uint32 ShowSetDA_ALCS

================================================================================
MSG: rospy_message_converter/LonCtrlOut
int32 ModeESP
int32 TauGapSet
bool ObjValid
float32 DsplVelocitySet
int32 GoNotfrReq
int32 TextInfo
int32 GoNotfrOnOffSts
int32 TSRSpdLimDataOnOffSts
int32 TakeOverReq
float32 TargetAccel
float32 CmftLowerAccl
float32 CmftUpprAccl
float32 MinJerkAccl
float32 MaxJerkAccl
int32 DecelToStopReq
int32 ShutdownModReq
int32 DrvOffReq
int32 BrkPreferReq
int32 MinBkrgReq
int32 ACCNPDrvMsg
int32 ClsObjTyp
float32 ClsObjDst
int32 TauGapChgDisp
bool DisplSetSpdEnbl
int32 VlcReqFct
uint32 SpdUnit
int32 DA_SetSpeedAnimation
uint32 DA_Inhibit

================================================================================
MSG: rospy_message_converter/HwaOut
int32 AccNpSts
int32 LongCtrlActv
int32 LatCtrlActv
int32 HodWarnReq
int32 HzrdLiReq
int32 DoorUnlckReq
int32 HodTakeOver
int32 NaNadSts
uint32 NaNadWTI
bool FreespaceIntrsn
bool ADC_VehDisp_Warn
bool DA_TurnIndctrLeTip
bool DA_TurnIndctrRiTip
bool DA_TurnIndctrLeLatch
bool DA_TurnIndctrRiLatch
bool DA_TurnIndctrLePush
bool DA_TurnIndctrRiPush
int32 DA_NOP_Avl
bool NeedNOPCtrl
uint32 DA_NOP_WTIs
uint32 DA_iACC_WTIs
uint32 DA_Pilot_WTIs
bool DA_SysFailSymbol

================================================================================
MSG: rospy_message_converter/LdwOut
int32 AdasLeLine
int32 AdasRiLine
int32 LaneAsstSts
int32 EPSReqTyp
int32 Snvty
int32 LaneAsstTyp
int32 HapticOnOffSts

================================================================================
MSG: rospy_message_converter/SasOut
uint32 SpeedLimitValue
uint32 SpeedUnit
int32 SpeedLimitAttribute
int32 SpeedLimitTakeover
uint32 SupSignType
uint32 SupSignAttribute
uint32 RoadFeatureWarningSign
uint32 TrafficLightSts
uint32 LocalHazards
int32 SLIFState
int32 SLWFWarnTrigger

================================================================================
MSG: rospy_message_converter/HeaterOut
bool WSHeatReq
bool WSHeatReqValid

================================================================================
MSG: rospy_message_converter/ElkOut
int32 ElkSts
int32 ESFWarningSts

================================================================================
MSG: rospy_message_converter/FunctionXstatus
string FunctionName
int32 FunctionID
int32 FuncSts
int32 ReqFunctionID

================================================================================
MSG: rospy_message_converter/AcmEdrOut
uint32 acsf_b1_sts_edr
uint32 acsf_b2_sts_edr
uint32 acsf_c_sts_edr
uint32 acsf_d_sts_edr
uint32 acsf_e_sts_edr
uint32 lane_assist_sts_edr
uint32 ldw_lka_lane_assi_typ_edr
uint32 adas_le_line_edr
uint32 adas_ri_line_edr
uint32 elk_sts_edr
uint32 esf_warning_sts_edr
uint32 acc_sts_edr

================================================================================
MSG: rospy_message_converter/HMIIconOut
uint32 ShowSetSWF
bool ShowSetDA_ALCS
uint32 ShowSetDA_SpdAssist
bool ShowSetDA_SetSpdCtrl
uint32 ShowSetDA_SteerAssist
bool ShowSetDA_CurveSpdAssist
uint32 ReRADfeatures_FactoryDft
uint32 LaneFeautres_FactoryDft

================================================================================
MSG: rospy_message_converter/EasOut
uint32 EASSts
uint32 EASWarningLv
uint32 RpsLockUnlckCtrl
bool EasCall

================================================================================
MSG: rospy_message_converter/SnsrStsOut
int32 LidarSts
int32 Camera_FrntWideSts

================================================================================
MSG: rospy_message_converter/RcvProtoPTPTimeOut
uint64 function_arb_out_ptp_ts
uint64 sd_map_ptp_ts
uint64 nop_functionstatus_ptp_ts
uint64 nop_speedlimitvalue_ptp_ts
uint64 nop_vehicleout_ptp_ts
uint64 side_feature_ptp_ts
uint64 vision_illumnance_flag_ptp_ts
uint64 vision_road_detection_ptp_ts
uint64 vehicle_10ms_ptp_ts
uint64 vehicle_50ms_ptp_ts
uint64 ehy_lpp_outputs_ptp_ts
uint64 ehy_obf_outputs_ptp_ts
uint64 ehy_rme_road_outputs_ptp_ts
uint64 ehy_tpp_outputs_ptp_ts
uint64 ehy_tse_outputs_ptp_ts
uint64 ehy_tsi_outputs_ptp_ts
uint64[] reserved_ptp_ts
"""
  __slots__ = ['Ahc','LatCtrl','LonCtrl','Hwa','Ldw','Sas','Heater','Elk','Function','AcmEdr','HmiIcon','Eas','Reserved','SesrSts','RcvProtoPTPTime','publish_ptp_ts','publisher_id','counter','publish_ts']
  _slot_types = ['rospy_message_converter/AhcOut','rospy_message_converter/LatCtrlOut','rospy_message_converter/LonCtrlOut','rospy_message_converter/HwaOut','rospy_message_converter/LdwOut','rospy_message_converter/SasOut','rospy_message_converter/HeaterOut','rospy_message_converter/ElkOut','rospy_message_converter/FunctionXstatus[]','rospy_message_converter/AcmEdrOut','rospy_message_converter/HMIIconOut','rospy_message_converter/EasOut','float64[]','rospy_message_converter/SnsrStsOut','rospy_message_converter/RcvProtoPTPTimeOut','uint64','string','uint64','uint64']

  def __init__(self, *args, **kwds):
    """
    Constructor. Any message fields that are implicitly/explicitly
    set to None will be assigned a default value. The recommend
    use is keyword arguments as this is more robust to future message
    changes.  You cannot mix in-order arguments and keyword arguments.

    The available fields are:
       Ahc,LatCtrl,LonCtrl,Hwa,Ldw,Sas,Heater,Elk,Function,AcmEdr,HmiIcon,Eas,Reserved,SesrSts,RcvProtoPTPTime,publish_ptp_ts,publisher_id,counter,publish_ts

    :param args: complete set of field values, in .msg order
    :param kwds: use keyword arguments corresponding to message field names
    to set specific fields.
    """
    if args or kwds:
      super(FctOut, self).__init__(*args, **kwds)
      # message fields cannot be None, assign default values for those that are
      if self.Ahc is None:
        self.Ahc = rospy_message_converter.msg.AhcOut()
      if self.LatCtrl is None:
        self.LatCtrl = rospy_message_converter.msg.LatCtrlOut()
      if self.LonCtrl is None:
        self.LonCtrl = rospy_message_converter.msg.LonCtrlOut()
      if self.Hwa is None:
        self.Hwa = rospy_message_converter.msg.HwaOut()
      if self.Ldw is None:
        self.Ldw = rospy_message_converter.msg.LdwOut()
      if self.Sas is None:
        self.Sas = rospy_message_converter.msg.SasOut()
      if self.Heater is None:
        self.Heater = rospy_message_converter.msg.HeaterOut()
      if self.Elk is None:
        self.Elk = rospy_message_converter.msg.ElkOut()
      if self.Function is None:
        self.Function = []
      if self.AcmEdr is None:
        self.AcmEdr = rospy_message_converter.msg.AcmEdrOut()
      if self.HmiIcon is None:
        self.HmiIcon = rospy_message_converter.msg.HMIIconOut()
      if self.Eas is None:
        self.Eas = rospy_message_converter.msg.EasOut()
      if self.Reserved is None:
        self.Reserved = []
      if self.SesrSts is None:
        self.SesrSts = rospy_message_converter.msg.SnsrStsOut()
      if self.RcvProtoPTPTime is None:
        self.RcvProtoPTPTime = rospy_message_converter.msg.RcvProtoPTPTimeOut()
      if self.publish_ptp_ts is None:
        self.publish_ptp_ts = 0
      if self.publisher_id is None:
        self.publisher_id = ''
      if self.counter is None:
        self.counter = 0
      if self.publish_ts is None:
        self.publish_ts = 0
    else:
      self.Ahc = rospy_message_converter.msg.AhcOut()
      self.LatCtrl = rospy_message_converter.msg.LatCtrlOut()
      self.LonCtrl = rospy_message_converter.msg.LonCtrlOut()
      self.Hwa = rospy_message_converter.msg.HwaOut()
      self.Ldw = rospy_message_converter.msg.LdwOut()
      self.Sas = rospy_message_converter.msg.SasOut()
      self.Heater = rospy_message_converter.msg.HeaterOut()
      self.Elk = rospy_message_converter.msg.ElkOut()
      self.Function = []
      self.AcmEdr = rospy_message_converter.msg.AcmEdrOut()
      self.HmiIcon = rospy_message_converter.msg.HMIIconOut()
      self.Eas = rospy_message_converter.msg.EasOut()
      self.Reserved = []
      self.SesrSts = rospy_message_converter.msg.SnsrStsOut()
      self.RcvProtoPTPTime = rospy_message_converter.msg.RcvProtoPTPTimeOut()
      self.publish_ptp_ts = 0
      self.publisher_id = ''
      self.counter = 0
      self.publish_ts = 0

  def _get_types(self):
    """
    internal API method
    """
    return self._slot_types

  def serialize(self, buff):
    """
    serialize message into buffer
    :param buff: buffer, ``StringIO``
    """
    try:
      _x = self
      buff.write(_get_struct_iB7if3iB4i4I2iBf5i5f7ifiBiIiI8iI8BiB3IB7i2I2i5I2i2B2i().pack(_x.Ahc.AhcSysSt, _x.Ahc.AhcHiBmReq, _x.LatCtrl.ExtReqCAMFC, _x.LatCtrl.LeLineTyp, _x.LatCtrl.RiLineTyp, _x.LatCtrl.LeTrackingSts, _x.LatCtrl.RiTrackingSts, _x.LatCtrl.LaneAssiTyp, _x.LatCtrl.LkaSnsvty, _x.LatCtrl.AbsltPinionAgReq, _x.LatCtrl.EPSReqTyp, _x.LatCtrl.LkaLnAsstSts, _x.LatCtrl.LkaHODWarnSeq, _x.LatCtrl.LatCtrlActv, _x.LatCtrl.EPSACITsuSup, _x.LatCtrl.VMC1ACITsuSup, _x.LatCtrl.LatCtrlTarLe, _x.LatCtrl.LatCtrlTarRi, _x.LatCtrl.AlcsInfo.DA_LaneChgSupReason, _x.LatCtrl.AlcsInfo.AlcManeuverSts, _x.LatCtrl.AlcsInfo.DA_ALCSsts, _x.LatCtrl.AlcsInfo.ShowSetDA_ALCS, _x.LonCtrl.ModeESP, _x.LonCtrl.TauGapSet, _x.LonCtrl.ObjValid, _x.LonCtrl.DsplVelocitySet, _x.LonCtrl.GoNotfrReq, _x.LonCtrl.TextInfo, _x.LonCtrl.GoNotfrOnOffSts, _x.LonCtrl.TSRSpdLimDataOnOffSts, _x.LonCtrl.TakeOverReq, _x.LonCtrl.TargetAccel, _x.LonCtrl.CmftLowerAccl, _x.LonCtrl.CmftUpprAccl, _x.LonCtrl.MinJerkAccl, _x.LonCtrl.MaxJerkAccl, _x.LonCtrl.DecelToStopReq, _x.LonCtrl.ShutdownModReq, _x.LonCtrl.DrvOffReq, _x.LonCtrl.BrkPreferReq, _x.LonCtrl.MinBkrgReq, _x.LonCtrl.ACCNPDrvMsg, _x.LonCtrl.ClsObjTyp, _x.LonCtrl.ClsObjDst, _x.LonCtrl.TauGapChgDisp, _x.LonCtrl.DisplSetSpdEnbl, _x.LonCtrl.VlcReqFct, _x.LonCtrl.SpdUnit, _x.LonCtrl.DA_SetSpeedAnimation, _x.LonCtrl.DA_Inhibit, _x.Hwa.AccNpSts, _x.Hwa.LongCtrlActv, _x.Hwa.LatCtrlActv, _x.Hwa.HodWarnReq, _x.Hwa.HzrdLiReq, _x.Hwa.DoorUnlckReq, _x.Hwa.HodTakeOver, _x.Hwa.NaNadSts, _x.Hwa.NaNadWTI, _x.Hwa.FreespaceIntrsn, _x.Hwa.ADC_VehDisp_Warn, _x.Hwa.DA_TurnIndctrLeTip, _x.Hwa.DA_TurnIndctrRiTip, _x.Hwa.DA_TurnIndctrLeLatch, _x.Hwa.DA_TurnIndctrRiLatch, _x.Hwa.DA_TurnIndctrLePush, _x.Hwa.DA_TurnIndctrRiPush, _x.Hwa.DA_NOP_Avl, _x.Hwa.NeedNOPCtrl, _x.Hwa.DA_NOP_WTIs, _x.Hwa.DA_iACC_WTIs, _x.Hwa.DA_Pilot_WTIs, _x.Hwa.DA_SysFailSymbol, _x.Ldw.AdasLeLine, _x.Ldw.AdasRiLine, _x.Ldw.LaneAsstSts, _x.Ldw.EPSReqTyp, _x.Ldw.Snvty, _x.Ldw.LaneAsstTyp, _x.Ldw.HapticOnOffSts, _x.Sas.SpeedLimitValue, _x.Sas.SpeedUnit, _x.Sas.SpeedLimitAttribute, _x.Sas.SpeedLimitTakeover, _x.Sas.SupSignType, _x.Sas.SupSignAttribute, _x.Sas.RoadFeatureWarningSign, _x.Sas.TrafficLightSts, _x.Sas.LocalHazards, _x.Sas.SLIFState, _x.Sas.SLWFWarnTrigger, _x.Heater.WSHeatReq, _x.Heater.WSHeatReqValid, _x.Elk.ElkSts, _x.Elk.ESFWarningSts))
      length = len(self.Function)
      buff.write(_struct_I.pack(length))
      for val1 in self.Function:
        _x = val1.FunctionName
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
        _x = val1
        buff.write(_get_struct_3i().pack(_x.FunctionID, _x.FuncSts, _x.ReqFunctionID))
      _x = self
      buff.write(_get_struct_13IBIBIB5IB().pack(_x.AcmEdr.acsf_b1_sts_edr, _x.AcmEdr.acsf_b2_sts_edr, _x.AcmEdr.acsf_c_sts_edr, _x.AcmEdr.acsf_d_sts_edr, _x.AcmEdr.acsf_e_sts_edr, _x.AcmEdr.lane_assist_sts_edr, _x.AcmEdr.ldw_lka_lane_assi_typ_edr, _x.AcmEdr.adas_le_line_edr, _x.AcmEdr.adas_ri_line_edr, _x.AcmEdr.elk_sts_edr, _x.AcmEdr.esf_warning_sts_edr, _x.AcmEdr.acc_sts_edr, _x.HmiIcon.ShowSetSWF, _x.HmiIcon.ShowSetDA_ALCS, _x.HmiIcon.ShowSetDA_SpdAssist, _x.HmiIcon.ShowSetDA_SetSpdCtrl, _x.HmiIcon.ShowSetDA_SteerAssist, _x.HmiIcon.ShowSetDA_CurveSpdAssist, _x.HmiIcon.ReRADfeatures_FactoryDft, _x.HmiIcon.LaneFeautres_FactoryDft, _x.Eas.EASSts, _x.Eas.EASWarningLv, _x.Eas.RpsLockUnlckCtrl, _x.Eas.EasCall))
      length = len(self.Reserved)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(struct.Struct(pattern).pack(*self.Reserved))
      _x = self
      buff.write(_get_struct_2i16Q().pack(_x.SesrSts.LidarSts, _x.SesrSts.Camera_FrntWideSts, _x.RcvProtoPTPTime.function_arb_out_ptp_ts, _x.RcvProtoPTPTime.sd_map_ptp_ts, _x.RcvProtoPTPTime.nop_functionstatus_ptp_ts, _x.RcvProtoPTPTime.nop_speedlimitvalue_ptp_ts, _x.RcvProtoPTPTime.nop_vehicleout_ptp_ts, _x.RcvProtoPTPTime.side_feature_ptp_ts, _x.RcvProtoPTPTime.vision_illumnance_flag_ptp_ts, _x.RcvProtoPTPTime.vision_road_detection_ptp_ts, _x.RcvProtoPTPTime.vehicle_10ms_ptp_ts, _x.RcvProtoPTPTime.vehicle_50ms_ptp_ts, _x.RcvProtoPTPTime.ehy_lpp_outputs_ptp_ts, _x.RcvProtoPTPTime.ehy_obf_outputs_ptp_ts, _x.RcvProtoPTPTime.ehy_rme_road_outputs_ptp_ts, _x.RcvProtoPTPTime.ehy_tpp_outputs_ptp_ts, _x.RcvProtoPTPTime.ehy_tse_outputs_ptp_ts, _x.RcvProtoPTPTime.ehy_tsi_outputs_ptp_ts))
      length = len(self.RcvProtoPTPTime.reserved_ptp_ts)
      buff.write(_struct_I.pack(length))
      pattern = '<%sQ'%length
      buff.write(struct.Struct(pattern).pack(*self.RcvProtoPTPTime.reserved_ptp_ts))
      _x = self.publish_ptp_ts
      buff.write(_get_struct_Q().pack(_x))
      _x = self.publisher_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self
      buff.write(_get_struct_2Q().pack(_x.counter, _x.publish_ts))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize(self, str):
    """
    unpack serialized message in str into this message instance
    :param str: byte array of serialized message, ``str``
    """
    if python3:
      codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      if self.Ahc is None:
        self.Ahc = rospy_message_converter.msg.AhcOut()
      if self.LatCtrl is None:
        self.LatCtrl = rospy_message_converter.msg.LatCtrlOut()
      if self.LonCtrl is None:
        self.LonCtrl = rospy_message_converter.msg.LonCtrlOut()
      if self.Hwa is None:
        self.Hwa = rospy_message_converter.msg.HwaOut()
      if self.Ldw is None:
        self.Ldw = rospy_message_converter.msg.LdwOut()
      if self.Sas is None:
        self.Sas = rospy_message_converter.msg.SasOut()
      if self.Heater is None:
        self.Heater = rospy_message_converter.msg.HeaterOut()
      if self.Elk is None:
        self.Elk = rospy_message_converter.msg.ElkOut()
      if self.Function is None:
        self.Function = None
      if self.AcmEdr is None:
        self.AcmEdr = rospy_message_converter.msg.AcmEdrOut()
      if self.HmiIcon is None:
        self.HmiIcon = rospy_message_converter.msg.HMIIconOut()
      if self.Eas is None:
        self.Eas = rospy_message_converter.msg.EasOut()
      if self.SesrSts is None:
        self.SesrSts = rospy_message_converter.msg.SnsrStsOut()
      if self.RcvProtoPTPTime is None:
        self.RcvProtoPTPTime = rospy_message_converter.msg.RcvProtoPTPTimeOut()
      end = 0
      _x = self
      start = end
      end += 332
      (_x.Ahc.AhcSysSt, _x.Ahc.AhcHiBmReq, _x.LatCtrl.ExtReqCAMFC, _x.LatCtrl.LeLineTyp, _x.LatCtrl.RiLineTyp, _x.LatCtrl.LeTrackingSts, _x.LatCtrl.RiTrackingSts, _x.LatCtrl.LaneAssiTyp, _x.LatCtrl.LkaSnsvty, _x.LatCtrl.AbsltPinionAgReq, _x.LatCtrl.EPSReqTyp, _x.LatCtrl.LkaLnAsstSts, _x.LatCtrl.LkaHODWarnSeq, _x.LatCtrl.LatCtrlActv, _x.LatCtrl.EPSACITsuSup, _x.LatCtrl.VMC1ACITsuSup, _x.LatCtrl.LatCtrlTarLe, _x.LatCtrl.LatCtrlTarRi, _x.LatCtrl.AlcsInfo.DA_LaneChgSupReason, _x.LatCtrl.AlcsInfo.AlcManeuverSts, _x.LatCtrl.AlcsInfo.DA_ALCSsts, _x.LatCtrl.AlcsInfo.ShowSetDA_ALCS, _x.LonCtrl.ModeESP, _x.LonCtrl.TauGapSet, _x.LonCtrl.ObjValid, _x.LonCtrl.DsplVelocitySet, _x.LonCtrl.GoNotfrReq, _x.LonCtrl.TextInfo, _x.LonCtrl.GoNotfrOnOffSts, _x.LonCtrl.TSRSpdLimDataOnOffSts, _x.LonCtrl.TakeOverReq, _x.LonCtrl.TargetAccel, _x.LonCtrl.CmftLowerAccl, _x.LonCtrl.CmftUpprAccl, _x.LonCtrl.MinJerkAccl, _x.LonCtrl.MaxJerkAccl, _x.LonCtrl.DecelToStopReq, _x.LonCtrl.ShutdownModReq, _x.LonCtrl.DrvOffReq, _x.LonCtrl.BrkPreferReq, _x.LonCtrl.MinBkrgReq, _x.LonCtrl.ACCNPDrvMsg, _x.LonCtrl.ClsObjTyp, _x.LonCtrl.ClsObjDst, _x.LonCtrl.TauGapChgDisp, _x.LonCtrl.DisplSetSpdEnbl, _x.LonCtrl.VlcReqFct, _x.LonCtrl.SpdUnit, _x.LonCtrl.DA_SetSpeedAnimation, _x.LonCtrl.DA_Inhibit, _x.Hwa.AccNpSts, _x.Hwa.LongCtrlActv, _x.Hwa.LatCtrlActv, _x.Hwa.HodWarnReq, _x.Hwa.HzrdLiReq, _x.Hwa.DoorUnlckReq, _x.Hwa.HodTakeOver, _x.Hwa.NaNadSts, _x.Hwa.NaNadWTI, _x.Hwa.FreespaceIntrsn, _x.Hwa.ADC_VehDisp_Warn, _x.Hwa.DA_TurnIndctrLeTip, _x.Hwa.DA_TurnIndctrRiTip, _x.Hwa.DA_TurnIndctrLeLatch, _x.Hwa.DA_TurnIndctrRiLatch, _x.Hwa.DA_TurnIndctrLePush, _x.Hwa.DA_TurnIndctrRiPush, _x.Hwa.DA_NOP_Avl, _x.Hwa.NeedNOPCtrl, _x.Hwa.DA_NOP_WTIs, _x.Hwa.DA_iACC_WTIs, _x.Hwa.DA_Pilot_WTIs, _x.Hwa.DA_SysFailSymbol, _x.Ldw.AdasLeLine, _x.Ldw.AdasRiLine, _x.Ldw.LaneAsstSts, _x.Ldw.EPSReqTyp, _x.Ldw.Snvty, _x.Ldw.LaneAsstTyp, _x.Ldw.HapticOnOffSts, _x.Sas.SpeedLimitValue, _x.Sas.SpeedUnit, _x.Sas.SpeedLimitAttribute, _x.Sas.SpeedLimitTakeover, _x.Sas.SupSignType, _x.Sas.SupSignAttribute, _x.Sas.RoadFeatureWarningSign, _x.Sas.TrafficLightSts, _x.Sas.LocalHazards, _x.Sas.SLIFState, _x.Sas.SLWFWarnTrigger, _x.Heater.WSHeatReq, _x.Heater.WSHeatReqValid, _x.Elk.ElkSts, _x.Elk.ESFWarningSts,) = _get_struct_iB7if3iB4i4I2iBf5i5f7ifiBiIiI8iI8BiB3IB7i2I2i5I2i2B2i().unpack(str[start:end])
      self.Ahc.AhcHiBmReq = bool(self.Ahc.AhcHiBmReq)
      self.LatCtrl.LatCtrlActv = bool(self.LatCtrl.LatCtrlActv)
      self.LonCtrl.ObjValid = bool(self.LonCtrl.ObjValid)
      self.LonCtrl.DisplSetSpdEnbl = bool(self.LonCtrl.DisplSetSpdEnbl)
      self.Hwa.FreespaceIntrsn = bool(self.Hwa.FreespaceIntrsn)
      self.Hwa.ADC_VehDisp_Warn = bool(self.Hwa.ADC_VehDisp_Warn)
      self.Hwa.DA_TurnIndctrLeTip = bool(self.Hwa.DA_TurnIndctrLeTip)
      self.Hwa.DA_TurnIndctrRiTip = bool(self.Hwa.DA_TurnIndctrRiTip)
      self.Hwa.DA_TurnIndctrLeLatch = bool(self.Hwa.DA_TurnIndctrLeLatch)
      self.Hwa.DA_TurnIndctrRiLatch = bool(self.Hwa.DA_TurnIndctrRiLatch)
      self.Hwa.DA_TurnIndctrLePush = bool(self.Hwa.DA_TurnIndctrLePush)
      self.Hwa.DA_TurnIndctrRiPush = bool(self.Hwa.DA_TurnIndctrRiPush)
      self.Hwa.NeedNOPCtrl = bool(self.Hwa.NeedNOPCtrl)
      self.Hwa.DA_SysFailSymbol = bool(self.Hwa.DA_SysFailSymbol)
      self.Heater.WSHeatReq = bool(self.Heater.WSHeatReq)
      self.Heater.WSHeatReqValid = bool(self.Heater.WSHeatReqValid)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.Function = []
      for i in range(0, length):
        val1 = rospy_message_converter.msg.FunctionXstatus()
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.FunctionName = str[start:end].decode('utf-8', 'rosmsg')
        else:
          val1.FunctionName = str[start:end]
        _x = val1
        start = end
        end += 12
        (_x.FunctionID, _x.FuncSts, _x.ReqFunctionID,) = _get_struct_3i().unpack(str[start:end])
        self.Function.append(val1)
      _x = self
      start = end
      end += 84
      (_x.AcmEdr.acsf_b1_sts_edr, _x.AcmEdr.acsf_b2_sts_edr, _x.AcmEdr.acsf_c_sts_edr, _x.AcmEdr.acsf_d_sts_edr, _x.AcmEdr.acsf_e_sts_edr, _x.AcmEdr.lane_assist_sts_edr, _x.AcmEdr.ldw_lka_lane_assi_typ_edr, _x.AcmEdr.adas_le_line_edr, _x.AcmEdr.adas_ri_line_edr, _x.AcmEdr.elk_sts_edr, _x.AcmEdr.esf_warning_sts_edr, _x.AcmEdr.acc_sts_edr, _x.HmiIcon.ShowSetSWF, _x.HmiIcon.ShowSetDA_ALCS, _x.HmiIcon.ShowSetDA_SpdAssist, _x.HmiIcon.ShowSetDA_SetSpdCtrl, _x.HmiIcon.ShowSetDA_SteerAssist, _x.HmiIcon.ShowSetDA_CurveSpdAssist, _x.HmiIcon.ReRADfeatures_FactoryDft, _x.HmiIcon.LaneFeautres_FactoryDft, _x.Eas.EASSts, _x.Eas.EASWarningLv, _x.Eas.RpsLockUnlckCtrl, _x.Eas.EasCall,) = _get_struct_13IBIBIB5IB().unpack(str[start:end])
      self.HmiIcon.ShowSetDA_ALCS = bool(self.HmiIcon.ShowSetDA_ALCS)
      self.HmiIcon.ShowSetDA_SetSpdCtrl = bool(self.HmiIcon.ShowSetDA_SetSpdCtrl)
      self.HmiIcon.ShowSetDA_CurveSpdAssist = bool(self.HmiIcon.ShowSetDA_CurveSpdAssist)
      self.Eas.EasCall = bool(self.Eas.EasCall)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.Reserved = s.unpack(str[start:end])
      _x = self
      start = end
      end += 136
      (_x.SesrSts.LidarSts, _x.SesrSts.Camera_FrntWideSts, _x.RcvProtoPTPTime.function_arb_out_ptp_ts, _x.RcvProtoPTPTime.sd_map_ptp_ts, _x.RcvProtoPTPTime.nop_functionstatus_ptp_ts, _x.RcvProtoPTPTime.nop_speedlimitvalue_ptp_ts, _x.RcvProtoPTPTime.nop_vehicleout_ptp_ts, _x.RcvProtoPTPTime.side_feature_ptp_ts, _x.RcvProtoPTPTime.vision_illumnance_flag_ptp_ts, _x.RcvProtoPTPTime.vision_road_detection_ptp_ts, _x.RcvProtoPTPTime.vehicle_10ms_ptp_ts, _x.RcvProtoPTPTime.vehicle_50ms_ptp_ts, _x.RcvProtoPTPTime.ehy_lpp_outputs_ptp_ts, _x.RcvProtoPTPTime.ehy_obf_outputs_ptp_ts, _x.RcvProtoPTPTime.ehy_rme_road_outputs_ptp_ts, _x.RcvProtoPTPTime.ehy_tpp_outputs_ptp_ts, _x.RcvProtoPTPTime.ehy_tse_outputs_ptp_ts, _x.RcvProtoPTPTime.ehy_tsi_outputs_ptp_ts,) = _get_struct_2i16Q().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sQ'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.RcvProtoPTPTime.reserved_ptp_ts = s.unpack(str[start:end])
      start = end
      end += 8
      (self.publish_ptp_ts,) = _get_struct_Q().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.publisher_id = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.publisher_id = str[start:end]
      _x = self
      start = end
      end += 16
      (_x.counter, _x.publish_ts,) = _get_struct_2Q().unpack(str[start:end])
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill


  def serialize_numpy(self, buff, numpy):
    """
    serialize message with numpy array types into buffer
    :param buff: buffer, ``StringIO``
    :param numpy: numpy python module
    """
    try:
      _x = self
      buff.write(_get_struct_iB7if3iB4i4I2iBf5i5f7ifiBiIiI8iI8BiB3IB7i2I2i5I2i2B2i().pack(_x.Ahc.AhcSysSt, _x.Ahc.AhcHiBmReq, _x.LatCtrl.ExtReqCAMFC, _x.LatCtrl.LeLineTyp, _x.LatCtrl.RiLineTyp, _x.LatCtrl.LeTrackingSts, _x.LatCtrl.RiTrackingSts, _x.LatCtrl.LaneAssiTyp, _x.LatCtrl.LkaSnsvty, _x.LatCtrl.AbsltPinionAgReq, _x.LatCtrl.EPSReqTyp, _x.LatCtrl.LkaLnAsstSts, _x.LatCtrl.LkaHODWarnSeq, _x.LatCtrl.LatCtrlActv, _x.LatCtrl.EPSACITsuSup, _x.LatCtrl.VMC1ACITsuSup, _x.LatCtrl.LatCtrlTarLe, _x.LatCtrl.LatCtrlTarRi, _x.LatCtrl.AlcsInfo.DA_LaneChgSupReason, _x.LatCtrl.AlcsInfo.AlcManeuverSts, _x.LatCtrl.AlcsInfo.DA_ALCSsts, _x.LatCtrl.AlcsInfo.ShowSetDA_ALCS, _x.LonCtrl.ModeESP, _x.LonCtrl.TauGapSet, _x.LonCtrl.ObjValid, _x.LonCtrl.DsplVelocitySet, _x.LonCtrl.GoNotfrReq, _x.LonCtrl.TextInfo, _x.LonCtrl.GoNotfrOnOffSts, _x.LonCtrl.TSRSpdLimDataOnOffSts, _x.LonCtrl.TakeOverReq, _x.LonCtrl.TargetAccel, _x.LonCtrl.CmftLowerAccl, _x.LonCtrl.CmftUpprAccl, _x.LonCtrl.MinJerkAccl, _x.LonCtrl.MaxJerkAccl, _x.LonCtrl.DecelToStopReq, _x.LonCtrl.ShutdownModReq, _x.LonCtrl.DrvOffReq, _x.LonCtrl.BrkPreferReq, _x.LonCtrl.MinBkrgReq, _x.LonCtrl.ACCNPDrvMsg, _x.LonCtrl.ClsObjTyp, _x.LonCtrl.ClsObjDst, _x.LonCtrl.TauGapChgDisp, _x.LonCtrl.DisplSetSpdEnbl, _x.LonCtrl.VlcReqFct, _x.LonCtrl.SpdUnit, _x.LonCtrl.DA_SetSpeedAnimation, _x.LonCtrl.DA_Inhibit, _x.Hwa.AccNpSts, _x.Hwa.LongCtrlActv, _x.Hwa.LatCtrlActv, _x.Hwa.HodWarnReq, _x.Hwa.HzrdLiReq, _x.Hwa.DoorUnlckReq, _x.Hwa.HodTakeOver, _x.Hwa.NaNadSts, _x.Hwa.NaNadWTI, _x.Hwa.FreespaceIntrsn, _x.Hwa.ADC_VehDisp_Warn, _x.Hwa.DA_TurnIndctrLeTip, _x.Hwa.DA_TurnIndctrRiTip, _x.Hwa.DA_TurnIndctrLeLatch, _x.Hwa.DA_TurnIndctrRiLatch, _x.Hwa.DA_TurnIndctrLePush, _x.Hwa.DA_TurnIndctrRiPush, _x.Hwa.DA_NOP_Avl, _x.Hwa.NeedNOPCtrl, _x.Hwa.DA_NOP_WTIs, _x.Hwa.DA_iACC_WTIs, _x.Hwa.DA_Pilot_WTIs, _x.Hwa.DA_SysFailSymbol, _x.Ldw.AdasLeLine, _x.Ldw.AdasRiLine, _x.Ldw.LaneAsstSts, _x.Ldw.EPSReqTyp, _x.Ldw.Snvty, _x.Ldw.LaneAsstTyp, _x.Ldw.HapticOnOffSts, _x.Sas.SpeedLimitValue, _x.Sas.SpeedUnit, _x.Sas.SpeedLimitAttribute, _x.Sas.SpeedLimitTakeover, _x.Sas.SupSignType, _x.Sas.SupSignAttribute, _x.Sas.RoadFeatureWarningSign, _x.Sas.TrafficLightSts, _x.Sas.LocalHazards, _x.Sas.SLIFState, _x.Sas.SLWFWarnTrigger, _x.Heater.WSHeatReq, _x.Heater.WSHeatReqValid, _x.Elk.ElkSts, _x.Elk.ESFWarningSts))
      length = len(self.Function)
      buff.write(_struct_I.pack(length))
      for val1 in self.Function:
        _x = val1.FunctionName
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
        _x = val1
        buff.write(_get_struct_3i().pack(_x.FunctionID, _x.FuncSts, _x.ReqFunctionID))
      _x = self
      buff.write(_get_struct_13IBIBIB5IB().pack(_x.AcmEdr.acsf_b1_sts_edr, _x.AcmEdr.acsf_b2_sts_edr, _x.AcmEdr.acsf_c_sts_edr, _x.AcmEdr.acsf_d_sts_edr, _x.AcmEdr.acsf_e_sts_edr, _x.AcmEdr.lane_assist_sts_edr, _x.AcmEdr.ldw_lka_lane_assi_typ_edr, _x.AcmEdr.adas_le_line_edr, _x.AcmEdr.adas_ri_line_edr, _x.AcmEdr.elk_sts_edr, _x.AcmEdr.esf_warning_sts_edr, _x.AcmEdr.acc_sts_edr, _x.HmiIcon.ShowSetSWF, _x.HmiIcon.ShowSetDA_ALCS, _x.HmiIcon.ShowSetDA_SpdAssist, _x.HmiIcon.ShowSetDA_SetSpdCtrl, _x.HmiIcon.ShowSetDA_SteerAssist, _x.HmiIcon.ShowSetDA_CurveSpdAssist, _x.HmiIcon.ReRADfeatures_FactoryDft, _x.HmiIcon.LaneFeautres_FactoryDft, _x.Eas.EASSts, _x.Eas.EASWarningLv, _x.Eas.RpsLockUnlckCtrl, _x.Eas.EasCall))
      length = len(self.Reserved)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(self.Reserved.tostring())
      _x = self
      buff.write(_get_struct_2i16Q().pack(_x.SesrSts.LidarSts, _x.SesrSts.Camera_FrntWideSts, _x.RcvProtoPTPTime.function_arb_out_ptp_ts, _x.RcvProtoPTPTime.sd_map_ptp_ts, _x.RcvProtoPTPTime.nop_functionstatus_ptp_ts, _x.RcvProtoPTPTime.nop_speedlimitvalue_ptp_ts, _x.RcvProtoPTPTime.nop_vehicleout_ptp_ts, _x.RcvProtoPTPTime.side_feature_ptp_ts, _x.RcvProtoPTPTime.vision_illumnance_flag_ptp_ts, _x.RcvProtoPTPTime.vision_road_detection_ptp_ts, _x.RcvProtoPTPTime.vehicle_10ms_ptp_ts, _x.RcvProtoPTPTime.vehicle_50ms_ptp_ts, _x.RcvProtoPTPTime.ehy_lpp_outputs_ptp_ts, _x.RcvProtoPTPTime.ehy_obf_outputs_ptp_ts, _x.RcvProtoPTPTime.ehy_rme_road_outputs_ptp_ts, _x.RcvProtoPTPTime.ehy_tpp_outputs_ptp_ts, _x.RcvProtoPTPTime.ehy_tse_outputs_ptp_ts, _x.RcvProtoPTPTime.ehy_tsi_outputs_ptp_ts))
      length = len(self.RcvProtoPTPTime.reserved_ptp_ts)
      buff.write(_struct_I.pack(length))
      pattern = '<%sQ'%length
      buff.write(self.RcvProtoPTPTime.reserved_ptp_ts.tostring())
      _x = self.publish_ptp_ts
      buff.write(_get_struct_Q().pack(_x))
      _x = self.publisher_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self
      buff.write(_get_struct_2Q().pack(_x.counter, _x.publish_ts))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize_numpy(self, str, numpy):
    """
    unpack serialized message in str into this message instance using numpy for array types
    :param str: byte array of serialized message, ``str``
    :param numpy: numpy python module
    """
    if python3:
      codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      if self.Ahc is None:
        self.Ahc = rospy_message_converter.msg.AhcOut()
      if self.LatCtrl is None:
        self.LatCtrl = rospy_message_converter.msg.LatCtrlOut()
      if self.LonCtrl is None:
        self.LonCtrl = rospy_message_converter.msg.LonCtrlOut()
      if self.Hwa is None:
        self.Hwa = rospy_message_converter.msg.HwaOut()
      if self.Ldw is None:
        self.Ldw = rospy_message_converter.msg.LdwOut()
      if self.Sas is None:
        self.Sas = rospy_message_converter.msg.SasOut()
      if self.Heater is None:
        self.Heater = rospy_message_converter.msg.HeaterOut()
      if self.Elk is None:
        self.Elk = rospy_message_converter.msg.ElkOut()
      if self.Function is None:
        self.Function = None
      if self.AcmEdr is None:
        self.AcmEdr = rospy_message_converter.msg.AcmEdrOut()
      if self.HmiIcon is None:
        self.HmiIcon = rospy_message_converter.msg.HMIIconOut()
      if self.Eas is None:
        self.Eas = rospy_message_converter.msg.EasOut()
      if self.SesrSts is None:
        self.SesrSts = rospy_message_converter.msg.SnsrStsOut()
      if self.RcvProtoPTPTime is None:
        self.RcvProtoPTPTime = rospy_message_converter.msg.RcvProtoPTPTimeOut()
      end = 0
      _x = self
      start = end
      end += 332
      (_x.Ahc.AhcSysSt, _x.Ahc.AhcHiBmReq, _x.LatCtrl.ExtReqCAMFC, _x.LatCtrl.LeLineTyp, _x.LatCtrl.RiLineTyp, _x.LatCtrl.LeTrackingSts, _x.LatCtrl.RiTrackingSts, _x.LatCtrl.LaneAssiTyp, _x.LatCtrl.LkaSnsvty, _x.LatCtrl.AbsltPinionAgReq, _x.LatCtrl.EPSReqTyp, _x.LatCtrl.LkaLnAsstSts, _x.LatCtrl.LkaHODWarnSeq, _x.LatCtrl.LatCtrlActv, _x.LatCtrl.EPSACITsuSup, _x.LatCtrl.VMC1ACITsuSup, _x.LatCtrl.LatCtrlTarLe, _x.LatCtrl.LatCtrlTarRi, _x.LatCtrl.AlcsInfo.DA_LaneChgSupReason, _x.LatCtrl.AlcsInfo.AlcManeuverSts, _x.LatCtrl.AlcsInfo.DA_ALCSsts, _x.LatCtrl.AlcsInfo.ShowSetDA_ALCS, _x.LonCtrl.ModeESP, _x.LonCtrl.TauGapSet, _x.LonCtrl.ObjValid, _x.LonCtrl.DsplVelocitySet, _x.LonCtrl.GoNotfrReq, _x.LonCtrl.TextInfo, _x.LonCtrl.GoNotfrOnOffSts, _x.LonCtrl.TSRSpdLimDataOnOffSts, _x.LonCtrl.TakeOverReq, _x.LonCtrl.TargetAccel, _x.LonCtrl.CmftLowerAccl, _x.LonCtrl.CmftUpprAccl, _x.LonCtrl.MinJerkAccl, _x.LonCtrl.MaxJerkAccl, _x.LonCtrl.DecelToStopReq, _x.LonCtrl.ShutdownModReq, _x.LonCtrl.DrvOffReq, _x.LonCtrl.BrkPreferReq, _x.LonCtrl.MinBkrgReq, _x.LonCtrl.ACCNPDrvMsg, _x.LonCtrl.ClsObjTyp, _x.LonCtrl.ClsObjDst, _x.LonCtrl.TauGapChgDisp, _x.LonCtrl.DisplSetSpdEnbl, _x.LonCtrl.VlcReqFct, _x.LonCtrl.SpdUnit, _x.LonCtrl.DA_SetSpeedAnimation, _x.LonCtrl.DA_Inhibit, _x.Hwa.AccNpSts, _x.Hwa.LongCtrlActv, _x.Hwa.LatCtrlActv, _x.Hwa.HodWarnReq, _x.Hwa.HzrdLiReq, _x.Hwa.DoorUnlckReq, _x.Hwa.HodTakeOver, _x.Hwa.NaNadSts, _x.Hwa.NaNadWTI, _x.Hwa.FreespaceIntrsn, _x.Hwa.ADC_VehDisp_Warn, _x.Hwa.DA_TurnIndctrLeTip, _x.Hwa.DA_TurnIndctrRiTip, _x.Hwa.DA_TurnIndctrLeLatch, _x.Hwa.DA_TurnIndctrRiLatch, _x.Hwa.DA_TurnIndctrLePush, _x.Hwa.DA_TurnIndctrRiPush, _x.Hwa.DA_NOP_Avl, _x.Hwa.NeedNOPCtrl, _x.Hwa.DA_NOP_WTIs, _x.Hwa.DA_iACC_WTIs, _x.Hwa.DA_Pilot_WTIs, _x.Hwa.DA_SysFailSymbol, _x.Ldw.AdasLeLine, _x.Ldw.AdasRiLine, _x.Ldw.LaneAsstSts, _x.Ldw.EPSReqTyp, _x.Ldw.Snvty, _x.Ldw.LaneAsstTyp, _x.Ldw.HapticOnOffSts, _x.Sas.SpeedLimitValue, _x.Sas.SpeedUnit, _x.Sas.SpeedLimitAttribute, _x.Sas.SpeedLimitTakeover, _x.Sas.SupSignType, _x.Sas.SupSignAttribute, _x.Sas.RoadFeatureWarningSign, _x.Sas.TrafficLightSts, _x.Sas.LocalHazards, _x.Sas.SLIFState, _x.Sas.SLWFWarnTrigger, _x.Heater.WSHeatReq, _x.Heater.WSHeatReqValid, _x.Elk.ElkSts, _x.Elk.ESFWarningSts,) = _get_struct_iB7if3iB4i4I2iBf5i5f7ifiBiIiI8iI8BiB3IB7i2I2i5I2i2B2i().unpack(str[start:end])
      self.Ahc.AhcHiBmReq = bool(self.Ahc.AhcHiBmReq)
      self.LatCtrl.LatCtrlActv = bool(self.LatCtrl.LatCtrlActv)
      self.LonCtrl.ObjValid = bool(self.LonCtrl.ObjValid)
      self.LonCtrl.DisplSetSpdEnbl = bool(self.LonCtrl.DisplSetSpdEnbl)
      self.Hwa.FreespaceIntrsn = bool(self.Hwa.FreespaceIntrsn)
      self.Hwa.ADC_VehDisp_Warn = bool(self.Hwa.ADC_VehDisp_Warn)
      self.Hwa.DA_TurnIndctrLeTip = bool(self.Hwa.DA_TurnIndctrLeTip)
      self.Hwa.DA_TurnIndctrRiTip = bool(self.Hwa.DA_TurnIndctrRiTip)
      self.Hwa.DA_TurnIndctrLeLatch = bool(self.Hwa.DA_TurnIndctrLeLatch)
      self.Hwa.DA_TurnIndctrRiLatch = bool(self.Hwa.DA_TurnIndctrRiLatch)
      self.Hwa.DA_TurnIndctrLePush = bool(self.Hwa.DA_TurnIndctrLePush)
      self.Hwa.DA_TurnIndctrRiPush = bool(self.Hwa.DA_TurnIndctrRiPush)
      self.Hwa.NeedNOPCtrl = bool(self.Hwa.NeedNOPCtrl)
      self.Hwa.DA_SysFailSymbol = bool(self.Hwa.DA_SysFailSymbol)
      self.Heater.WSHeatReq = bool(self.Heater.WSHeatReq)
      self.Heater.WSHeatReqValid = bool(self.Heater.WSHeatReqValid)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.Function = []
      for i in range(0, length):
        val1 = rospy_message_converter.msg.FunctionXstatus()
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.FunctionName = str[start:end].decode('utf-8', 'rosmsg')
        else:
          val1.FunctionName = str[start:end]
        _x = val1
        start = end
        end += 12
        (_x.FunctionID, _x.FuncSts, _x.ReqFunctionID,) = _get_struct_3i().unpack(str[start:end])
        self.Function.append(val1)
      _x = self
      start = end
      end += 84
      (_x.AcmEdr.acsf_b1_sts_edr, _x.AcmEdr.acsf_b2_sts_edr, _x.AcmEdr.acsf_c_sts_edr, _x.AcmEdr.acsf_d_sts_edr, _x.AcmEdr.acsf_e_sts_edr, _x.AcmEdr.lane_assist_sts_edr, _x.AcmEdr.ldw_lka_lane_assi_typ_edr, _x.AcmEdr.adas_le_line_edr, _x.AcmEdr.adas_ri_line_edr, _x.AcmEdr.elk_sts_edr, _x.AcmEdr.esf_warning_sts_edr, _x.AcmEdr.acc_sts_edr, _x.HmiIcon.ShowSetSWF, _x.HmiIcon.ShowSetDA_ALCS, _x.HmiIcon.ShowSetDA_SpdAssist, _x.HmiIcon.ShowSetDA_SetSpdCtrl, _x.HmiIcon.ShowSetDA_SteerAssist, _x.HmiIcon.ShowSetDA_CurveSpdAssist, _x.HmiIcon.ReRADfeatures_FactoryDft, _x.HmiIcon.LaneFeautres_FactoryDft, _x.Eas.EASSts, _x.Eas.EASWarningLv, _x.Eas.RpsLockUnlckCtrl, _x.Eas.EasCall,) = _get_struct_13IBIBIB5IB().unpack(str[start:end])
      self.HmiIcon.ShowSetDA_ALCS = bool(self.HmiIcon.ShowSetDA_ALCS)
      self.HmiIcon.ShowSetDA_SetSpdCtrl = bool(self.HmiIcon.ShowSetDA_SetSpdCtrl)
      self.HmiIcon.ShowSetDA_CurveSpdAssist = bool(self.HmiIcon.ShowSetDA_CurveSpdAssist)
      self.Eas.EasCall = bool(self.Eas.EasCall)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.Reserved = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
      _x = self
      start = end
      end += 136
      (_x.SesrSts.LidarSts, _x.SesrSts.Camera_FrntWideSts, _x.RcvProtoPTPTime.function_arb_out_ptp_ts, _x.RcvProtoPTPTime.sd_map_ptp_ts, _x.RcvProtoPTPTime.nop_functionstatus_ptp_ts, _x.RcvProtoPTPTime.nop_speedlimitvalue_ptp_ts, _x.RcvProtoPTPTime.nop_vehicleout_ptp_ts, _x.RcvProtoPTPTime.side_feature_ptp_ts, _x.RcvProtoPTPTime.vision_illumnance_flag_ptp_ts, _x.RcvProtoPTPTime.vision_road_detection_ptp_ts, _x.RcvProtoPTPTime.vehicle_10ms_ptp_ts, _x.RcvProtoPTPTime.vehicle_50ms_ptp_ts, _x.RcvProtoPTPTime.ehy_lpp_outputs_ptp_ts, _x.RcvProtoPTPTime.ehy_obf_outputs_ptp_ts, _x.RcvProtoPTPTime.ehy_rme_road_outputs_ptp_ts, _x.RcvProtoPTPTime.ehy_tpp_outputs_ptp_ts, _x.RcvProtoPTPTime.ehy_tse_outputs_ptp_ts, _x.RcvProtoPTPTime.ehy_tsi_outputs_ptp_ts,) = _get_struct_2i16Q().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sQ'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.RcvProtoPTPTime.reserved_ptp_ts = numpy.frombuffer(str[start:end], dtype=numpy.uint64, count=length)
      start = end
      end += 8
      (self.publish_ptp_ts,) = _get_struct_Q().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.publisher_id = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.publisher_id = str[start:end]
      _x = self
      start = end
      end += 16
      (_x.counter, _x.publish_ts,) = _get_struct_2Q().unpack(str[start:end])
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill

_struct_I = genpy.struct_I
def _get_struct_I():
    global _struct_I
    return _struct_I
_struct_13IBIBIB5IB = None
def _get_struct_13IBIBIB5IB():
    global _struct_13IBIBIB5IB
    if _struct_13IBIBIB5IB is None:
        _struct_13IBIBIB5IB = struct.Struct("<13IBIBIB5IB")
    return _struct_13IBIBIB5IB
_struct_2Q = None
def _get_struct_2Q():
    global _struct_2Q
    if _struct_2Q is None:
        _struct_2Q = struct.Struct("<2Q")
    return _struct_2Q
_struct_2i16Q = None
def _get_struct_2i16Q():
    global _struct_2i16Q
    if _struct_2i16Q is None:
        _struct_2i16Q = struct.Struct("<2i16Q")
    return _struct_2i16Q
_struct_3i = None
def _get_struct_3i():
    global _struct_3i
    if _struct_3i is None:
        _struct_3i = struct.Struct("<3i")
    return _struct_3i
_struct_Q = None
def _get_struct_Q():
    global _struct_Q
    if _struct_Q is None:
        _struct_Q = struct.Struct("<Q")
    return _struct_Q
_struct_iB7if3iB4i4I2iBf5i5f7ifiBiIiI8iI8BiB3IB7i2I2i5I2i2B2i = None
def _get_struct_iB7if3iB4i4I2iBf5i5f7ifiBiIiI8iI8BiB3IB7i2I2i5I2i2B2i():
    global _struct_iB7if3iB4i4I2iBf5i5f7ifiBiIiI8iI8BiB3IB7i2I2i5I2i2B2i
    if _struct_iB7if3iB4i4I2iBf5i5f7ifiBiIiI8iI8BiB3IB7i2I2i5I2i2B2i is None:
        _struct_iB7if3iB4i4I2iBf5i5f7ifiBiIiI8iI8BiB3IB7i2I2i5I2i2B2i = struct.Struct("<iB7if3iB4i4I2iBf5i5f7ifiBiIiI8iI8BiB3IB7i2I2i5I2i2B2i")
    return _struct_iB7if3iB4i4I2iBf5i5f7ifiBiIiI8iI8BiB3IB7i2I2i5I2i2B2i
