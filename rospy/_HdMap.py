# This Python file uses the following encoding: utf-8
"""autogenerated by genpy from rospy_message_converter/HdMap.msg. Do not edit."""
import codecs
import sys
python3 = True if sys.hexversion > 0x03000000 else False
import genpy
import struct

import rospy_message_converter.msg

class HdMap(genpy.Message):
  _md5sum = "b45e6a1eb28d150e3323daee0e1d726e"
  _type = "rospy_message_converter/HdMap"
  _has_header = False  # flag to mark the presence of a Header object
  _full_text = """HdLaneGroup[] lane_group_list
HdLane[] lane_list
HdLaneBoundary[] lane_boundary_list
HdLinkInfo[] link_list
HdCrosswalk[] crosswalk_list
HdJunction[] junction_list
HdPole[] pole_list
HdTrafficLight[] traffic_light_list
HdTrafficSign[] traffic_sign_list
HdRoadGeoLine[] road_geo_line_list
HdStopLine[] stop_line_list
string map_tile_hash
int32 map_version
string dynamic_map_info_counter
HdParkingArea[] parking_area_list
HdWaitingZone[] waiting_zone_list
uint64 publish_ptp_ts
string publisher_id
uint64 counter
uint64 publish_ts

================================================================================
MSG: rospy_message_converter/HdLaneGroup
uint64 id
uint64[] lane_id
uint64 link_id
uint64[] link_id_list
float64 max_lane_speed_limit

================================================================================
MSG: rospy_message_converter/HdLane
uint64 id
int32 turn
MapPolyline central_line
uint64 left_boundary_id
uint64 right_boundary_id
Predecessor[] predecessors
Successor[] successors
float64 min_speed_limit
float64 max_speed_limit
NeightborSegment left_forward_neighbor
NeightborSegment right_forward_neighbor
NeightborSegment[] left_forward_neighbors
NeightborSegment[] right_forward_neighbors
NeightborSegment[] left_reverse_neighbors
NeightborSegment[] right_reverse_neighbors
Overlap[] overlaps
uint64 lane_group_id
int32 connection_type
int32 sequence_id
int32 lane_type
float64 length
float64[] OBSOLETE_width
float64[] width
float64[] centerline_s
uint32 lane_status
bool lane_used_in_both_directions
uint32 tile_id
float64 advisory_speed_limit
DowngradeLaneSegment[] downgrade_lane_segments
float64 electronic_eye_speed_limit
float64 max_lane_group_speed_limit

================================================================================
MSG: rospy_message_converter/MapPolyline
float64[] x
float64[] y
float64[] z

================================================================================
MSG: rospy_message_converter/Predecessor
uint64 self_id
uint64 other_id

================================================================================
MSG: rospy_message_converter/Successor
uint64 self_id
uint64 other_id

================================================================================
MSG: rospy_message_converter/NeightborSegment
uint64 self_id
uint64 other_id
float64 self_start_s
float64 self_end_s
float64 other_start_s
float64 other_end_s

================================================================================
MSG: rospy_message_converter/Overlap
uint64 self_id
uint64 other_id
int32 type
float64 start_s
float64 end_s

================================================================================
MSG: rospy_message_converter/DowngradeLaneSegment
int32 ad_mode_type
float64 start_s
float64 end_s
int32 info_value
int32 dynamic_info
int32 road_scenario_type

================================================================================
MSG: rospy_message_converter/HdLaneBoundary
uint64 id
MapPolyline central_line
int32[] colors
int32[] types
uint64 left_lane_id
uint64 right_lane_id
int32 sequence_id
uint64[] predecessor_lane_boundary_ids
uint64[] successor_lane_boundary_ids
uint32 lane_separate
FeaturePoint[] feature_points

================================================================================
MSG: rospy_message_converter/FeaturePoint
int32 type
int32 point_index

================================================================================
MSG: rospy_message_converter/HdLinkInfo
uint64 id
float64 length
uint32 average_speed
int32 priority_road_class
int32 travel_direction
int32[] form_way
uint64[] predecessor_link_ids
uint64[] successor_link_ids
uint64[] lane_ids
uint64[] lane_group_ids
uint64[] road_geo_line_ids
bool complex_intersection
LinkFeaturePoint[] feature_points

================================================================================
MSG: rospy_message_converter/LinkFeaturePoint
int32 type
float32 offset
MapPoint position
uint64 link_id

================================================================================
MSG: rospy_message_converter/MapPoint
float64 x
float64 y
float64 z

================================================================================
MSG: rospy_message_converter/HdCrosswalk
uint64 id
MapPolygon surface
uint64[] lane_id

================================================================================
MSG: rospy_message_converter/MapPolygon
float64[] x
float64[] y
float64[] z

================================================================================
MSG: rospy_message_converter/HdJunction
uint64 id
MapPolygon surface
uint64[] lane_id
uint64[] crosswalk_id
uint64[] stop_line_id

================================================================================
MSG: rospy_message_converter/HdPole
uint64 id
MapPoint ground_point
MapPoint top_point

================================================================================
MSG: rospy_message_converter/HdTrafficLight
uint64 id
MapPolygon surface
float64 heading
int32 traffic_light_type
uint64[] lane_id
int32 box_type
MapPoint center

================================================================================
MSG: rospy_message_converter/HdTrafficSign
uint64 id
MapPolygon surface
int32 type
float64 heading
uint64[] lane_id
MapPoint center

================================================================================
MSG: rospy_message_converter/HdRoadGeoLine
uint64 id
uint64 link_id
MapPolyline shape_point
float64[] curvature
float64[] slope
float64[] heading
float64[] shape_point_offset

================================================================================
MSG: rospy_message_converter/HdStopLine
uint64 id
MapPolyline polyline
uint64[] traffic_light_id
uint64[] traffic_sign_id

================================================================================
MSG: rospy_message_converter/HdParkingArea
uint64 id
MapPolygon surface
int32 marking_type
int32 parking_type
float64 heading
LinkFeaturePoint[] link_feature_points
uint64[] link_ids
uint64[] lane_ids

================================================================================
MSG: rospy_message_converter/HdWaitingZone
uint64 id
MapPolygon surface
LinkFeaturePoint[] link_feature_points
uint64[] lane_ids
"""
  __slots__ = ['lane_group_list','lane_list','lane_boundary_list','link_list','crosswalk_list','junction_list','pole_list','traffic_light_list','traffic_sign_list','road_geo_line_list','stop_line_list','map_tile_hash','map_version','dynamic_map_info_counter','parking_area_list','waiting_zone_list','publish_ptp_ts','publisher_id','counter','publish_ts']
  _slot_types = ['rospy_message_converter/HdLaneGroup[]','rospy_message_converter/HdLane[]','rospy_message_converter/HdLaneBoundary[]','rospy_message_converter/HdLinkInfo[]','rospy_message_converter/HdCrosswalk[]','rospy_message_converter/HdJunction[]','rospy_message_converter/HdPole[]','rospy_message_converter/HdTrafficLight[]','rospy_message_converter/HdTrafficSign[]','rospy_message_converter/HdRoadGeoLine[]','rospy_message_converter/HdStopLine[]','string','int32','string','rospy_message_converter/HdParkingArea[]','rospy_message_converter/HdWaitingZone[]','uint64','string','uint64','uint64']

  def __init__(self, *args, **kwds):
    """
    Constructor. Any message fields that are implicitly/explicitly
    set to None will be assigned a default value. The recommend
    use is keyword arguments as this is more robust to future message
    changes.  You cannot mix in-order arguments and keyword arguments.

    The available fields are:
       lane_group_list,lane_list,lane_boundary_list,link_list,crosswalk_list,junction_list,pole_list,traffic_light_list,traffic_sign_list,road_geo_line_list,stop_line_list,map_tile_hash,map_version,dynamic_map_info_counter,parking_area_list,waiting_zone_list,publish_ptp_ts,publisher_id,counter,publish_ts

    :param args: complete set of field values, in .msg order
    :param kwds: use keyword arguments corresponding to message field names
    to set specific fields.
    """
    if args or kwds:
      super(HdMap, self).__init__(*args, **kwds)
      # message fields cannot be None, assign default values for those that are
      if self.lane_group_list is None:
        self.lane_group_list = []
      if self.lane_list is None:
        self.lane_list = []
      if self.lane_boundary_list is None:
        self.lane_boundary_list = []
      if self.link_list is None:
        self.link_list = []
      if self.crosswalk_list is None:
        self.crosswalk_list = []
      if self.junction_list is None:
        self.junction_list = []
      if self.pole_list is None:
        self.pole_list = []
      if self.traffic_light_list is None:
        self.traffic_light_list = []
      if self.traffic_sign_list is None:
        self.traffic_sign_list = []
      if self.road_geo_line_list is None:
        self.road_geo_line_list = []
      if self.stop_line_list is None:
        self.stop_line_list = []
      if self.map_tile_hash is None:
        self.map_tile_hash = ''
      if self.map_version is None:
        self.map_version = 0
      if self.dynamic_map_info_counter is None:
        self.dynamic_map_info_counter = ''
      if self.parking_area_list is None:
        self.parking_area_list = []
      if self.waiting_zone_list is None:
        self.waiting_zone_list = []
      if self.publish_ptp_ts is None:
        self.publish_ptp_ts = 0
      if self.publisher_id is None:
        self.publisher_id = ''
      if self.counter is None:
        self.counter = 0
      if self.publish_ts is None:
        self.publish_ts = 0
    else:
      self.lane_group_list = []
      self.lane_list = []
      self.lane_boundary_list = []
      self.link_list = []
      self.crosswalk_list = []
      self.junction_list = []
      self.pole_list = []
      self.traffic_light_list = []
      self.traffic_sign_list = []
      self.road_geo_line_list = []
      self.stop_line_list = []
      self.map_tile_hash = ''
      self.map_version = 0
      self.dynamic_map_info_counter = ''
      self.parking_area_list = []
      self.waiting_zone_list = []
      self.publish_ptp_ts = 0
      self.publisher_id = ''
      self.counter = 0
      self.publish_ts = 0

  def _get_types(self):
    """
    internal API method
    """
    return self._slot_types

  def serialize(self, buff):
    """
    serialize message into buffer
    :param buff: buffer, ``StringIO``
    """
    try:
      length = len(self.lane_group_list)
      buff.write(_struct_I.pack(length))
      for val1 in self.lane_group_list:
        _x = val1.id
        buff.write(_get_struct_Q().pack(_x))
        length = len(val1.lane_id)
        buff.write(_struct_I.pack(length))
        pattern = '<%sQ'%length
        buff.write(struct.Struct(pattern).pack(*val1.lane_id))
        _x = val1.link_id
        buff.write(_get_struct_Q().pack(_x))
        length = len(val1.link_id_list)
        buff.write(_struct_I.pack(length))
        pattern = '<%sQ'%length
        buff.write(struct.Struct(pattern).pack(*val1.link_id_list))
        _x = val1.max_lane_speed_limit
        buff.write(_get_struct_d().pack(_x))
      length = len(self.lane_list)
      buff.write(_struct_I.pack(length))
      for val1 in self.lane_list:
        _x = val1
        buff.write(_get_struct_Qi().pack(_x.id, _x.turn))
        _v1 = val1.central_line
        length = len(_v1.x)
        buff.write(_struct_I.pack(length))
        pattern = '<%sd'%length
        buff.write(struct.Struct(pattern).pack(*_v1.x))
        length = len(_v1.y)
        buff.write(_struct_I.pack(length))
        pattern = '<%sd'%length
        buff.write(struct.Struct(pattern).pack(*_v1.y))
        length = len(_v1.z)
        buff.write(_struct_I.pack(length))
        pattern = '<%sd'%length
        buff.write(struct.Struct(pattern).pack(*_v1.z))
        _x = val1
        buff.write(_get_struct_2Q().pack(_x.left_boundary_id, _x.right_boundary_id))
        length = len(val1.predecessors)
        buff.write(_struct_I.pack(length))
        for val2 in val1.predecessors:
          _x = val2
          buff.write(_get_struct_2Q().pack(_x.self_id, _x.other_id))
        length = len(val1.successors)
        buff.write(_struct_I.pack(length))
        for val2 in val1.successors:
          _x = val2
          buff.write(_get_struct_2Q().pack(_x.self_id, _x.other_id))
        _x = val1
        buff.write(_get_struct_2d().pack(_x.min_speed_limit, _x.max_speed_limit))
        _v2 = val1.left_forward_neighbor
        _x = _v2
        buff.write(_get_struct_2Q4d().pack(_x.self_id, _x.other_id, _x.self_start_s, _x.self_end_s, _x.other_start_s, _x.other_end_s))
        _v3 = val1.right_forward_neighbor
        _x = _v3
        buff.write(_get_struct_2Q4d().pack(_x.self_id, _x.other_id, _x.self_start_s, _x.self_end_s, _x.other_start_s, _x.other_end_s))
        length = len(val1.left_forward_neighbors)
        buff.write(_struct_I.pack(length))
        for val2 in val1.left_forward_neighbors:
          _x = val2
          buff.write(_get_struct_2Q4d().pack(_x.self_id, _x.other_id, _x.self_start_s, _x.self_end_s, _x.other_start_s, _x.other_end_s))
        length = len(val1.right_forward_neighbors)
        buff.write(_struct_I.pack(length))
        for val2 in val1.right_forward_neighbors:
          _x = val2
          buff.write(_get_struct_2Q4d().pack(_x.self_id, _x.other_id, _x.self_start_s, _x.self_end_s, _x.other_start_s, _x.other_end_s))
        length = len(val1.left_reverse_neighbors)
        buff.write(_struct_I.pack(length))
        for val2 in val1.left_reverse_neighbors:
          _x = val2
          buff.write(_get_struct_2Q4d().pack(_x.self_id, _x.other_id, _x.self_start_s, _x.self_end_s, _x.other_start_s, _x.other_end_s))
        length = len(val1.right_reverse_neighbors)
        buff.write(_struct_I.pack(length))
        for val2 in val1.right_reverse_neighbors:
          _x = val2
          buff.write(_get_struct_2Q4d().pack(_x.self_id, _x.other_id, _x.self_start_s, _x.self_end_s, _x.other_start_s, _x.other_end_s))
        length = len(val1.overlaps)
        buff.write(_struct_I.pack(length))
        for val2 in val1.overlaps:
          _x = val2
          buff.write(_get_struct_2Qi2d().pack(_x.self_id, _x.other_id, _x.type, _x.start_s, _x.end_s))
        _x = val1
        buff.write(_get_struct_Q3id().pack(_x.lane_group_id, _x.connection_type, _x.sequence_id, _x.lane_type, _x.length))
        length = len(val1.OBSOLETE_width)
        buff.write(_struct_I.pack(length))
        pattern = '<%sd'%length
        buff.write(struct.Struct(pattern).pack(*val1.OBSOLETE_width))
        length = len(val1.width)
        buff.write(_struct_I.pack(length))
        pattern = '<%sd'%length
        buff.write(struct.Struct(pattern).pack(*val1.width))
        length = len(val1.centerline_s)
        buff.write(_struct_I.pack(length))
        pattern = '<%sd'%length
        buff.write(struct.Struct(pattern).pack(*val1.centerline_s))
        _x = val1
        buff.write(_get_struct_IBId().pack(_x.lane_status, _x.lane_used_in_both_directions, _x.tile_id, _x.advisory_speed_limit))
        length = len(val1.downgrade_lane_segments)
        buff.write(_struct_I.pack(length))
        for val2 in val1.downgrade_lane_segments:
          _x = val2
          buff.write(_get_struct_i2d3i().pack(_x.ad_mode_type, _x.start_s, _x.end_s, _x.info_value, _x.dynamic_info, _x.road_scenario_type))
        _x = val1
        buff.write(_get_struct_2d().pack(_x.electronic_eye_speed_limit, _x.max_lane_group_speed_limit))
      length = len(self.lane_boundary_list)
      buff.write(_struct_I.pack(length))
      for val1 in self.lane_boundary_list:
        _x = val1.id
        buff.write(_get_struct_Q().pack(_x))
        _v4 = val1.central_line
        length = len(_v4.x)
        buff.write(_struct_I.pack(length))
        pattern = '<%sd'%length
        buff.write(struct.Struct(pattern).pack(*_v4.x))
        length = len(_v4.y)
        buff.write(_struct_I.pack(length))
        pattern = '<%sd'%length
        buff.write(struct.Struct(pattern).pack(*_v4.y))
        length = len(_v4.z)
        buff.write(_struct_I.pack(length))
        pattern = '<%sd'%length
        buff.write(struct.Struct(pattern).pack(*_v4.z))
        length = len(val1.colors)
        buff.write(_struct_I.pack(length))
        pattern = '<%si'%length
        buff.write(struct.Struct(pattern).pack(*val1.colors))
        length = len(val1.types)
        buff.write(_struct_I.pack(length))
        pattern = '<%si'%length
        buff.write(struct.Struct(pattern).pack(*val1.types))
        _x = val1
        buff.write(_get_struct_2Qi().pack(_x.left_lane_id, _x.right_lane_id, _x.sequence_id))
        length = len(val1.predecessor_lane_boundary_ids)
        buff.write(_struct_I.pack(length))
        pattern = '<%sQ'%length
        buff.write(struct.Struct(pattern).pack(*val1.predecessor_lane_boundary_ids))
        length = len(val1.successor_lane_boundary_ids)
        buff.write(_struct_I.pack(length))
        pattern = '<%sQ'%length
        buff.write(struct.Struct(pattern).pack(*val1.successor_lane_boundary_ids))
        _x = val1.lane_separate
        buff.write(_get_struct_I().pack(_x))
        length = len(val1.feature_points)
        buff.write(_struct_I.pack(length))
        for val2 in val1.feature_points:
          _x = val2
          buff.write(_get_struct_2i().pack(_x.type, _x.point_index))
      length = len(self.link_list)
      buff.write(_struct_I.pack(length))
      for val1 in self.link_list:
        _x = val1
        buff.write(_get_struct_QdI2i().pack(_x.id, _x.length, _x.average_speed, _x.priority_road_class, _x.travel_direction))
        length = len(val1.form_way)
        buff.write(_struct_I.pack(length))
        pattern = '<%si'%length
        buff.write(struct.Struct(pattern).pack(*val1.form_way))
        length = len(val1.predecessor_link_ids)
        buff.write(_struct_I.pack(length))
        pattern = '<%sQ'%length
        buff.write(struct.Struct(pattern).pack(*val1.predecessor_link_ids))
        length = len(val1.successor_link_ids)
        buff.write(_struct_I.pack(length))
        pattern = '<%sQ'%length
        buff.write(struct.Struct(pattern).pack(*val1.successor_link_ids))
        length = len(val1.lane_ids)
        buff.write(_struct_I.pack(length))
        pattern = '<%sQ'%length
        buff.write(struct.Struct(pattern).pack(*val1.lane_ids))
        length = len(val1.lane_group_ids)
        buff.write(_struct_I.pack(length))
        pattern = '<%sQ'%length
        buff.write(struct.Struct(pattern).pack(*val1.lane_group_ids))
        length = len(val1.road_geo_line_ids)
        buff.write(_struct_I.pack(length))
        pattern = '<%sQ'%length
        buff.write(struct.Struct(pattern).pack(*val1.road_geo_line_ids))
        _x = val1.complex_intersection
        buff.write(_get_struct_B().pack(_x))
        length = len(val1.feature_points)
        buff.write(_struct_I.pack(length))
        for val2 in val1.feature_points:
          _x = val2
          buff.write(_get_struct_if().pack(_x.type, _x.offset))
          _v5 = val2.position
          _x = _v5
          buff.write(_get_struct_3d().pack(_x.x, _x.y, _x.z))
          _x = val2.link_id
          buff.write(_get_struct_Q().pack(_x))
      length = len(self.crosswalk_list)
      buff.write(_struct_I.pack(length))
      for val1 in self.crosswalk_list:
        _x = val1.id
        buff.write(_get_struct_Q().pack(_x))
        _v6 = val1.surface
        length = len(_v6.x)
        buff.write(_struct_I.pack(length))
        pattern = '<%sd'%length
        buff.write(struct.Struct(pattern).pack(*_v6.x))
        length = len(_v6.y)
        buff.write(_struct_I.pack(length))
        pattern = '<%sd'%length
        buff.write(struct.Struct(pattern).pack(*_v6.y))
        length = len(_v6.z)
        buff.write(_struct_I.pack(length))
        pattern = '<%sd'%length
        buff.write(struct.Struct(pattern).pack(*_v6.z))
        length = len(val1.lane_id)
        buff.write(_struct_I.pack(length))
        pattern = '<%sQ'%length
        buff.write(struct.Struct(pattern).pack(*val1.lane_id))
      length = len(self.junction_list)
      buff.write(_struct_I.pack(length))
      for val1 in self.junction_list:
        _x = val1.id
        buff.write(_get_struct_Q().pack(_x))
        _v7 = val1.surface
        length = len(_v7.x)
        buff.write(_struct_I.pack(length))
        pattern = '<%sd'%length
        buff.write(struct.Struct(pattern).pack(*_v7.x))
        length = len(_v7.y)
        buff.write(_struct_I.pack(length))
        pattern = '<%sd'%length
        buff.write(struct.Struct(pattern).pack(*_v7.y))
        length = len(_v7.z)
        buff.write(_struct_I.pack(length))
        pattern = '<%sd'%length
        buff.write(struct.Struct(pattern).pack(*_v7.z))
        length = len(val1.lane_id)
        buff.write(_struct_I.pack(length))
        pattern = '<%sQ'%length
        buff.write(struct.Struct(pattern).pack(*val1.lane_id))
        length = len(val1.crosswalk_id)
        buff.write(_struct_I.pack(length))
        pattern = '<%sQ'%length
        buff.write(struct.Struct(pattern).pack(*val1.crosswalk_id))
        length = len(val1.stop_line_id)
        buff.write(_struct_I.pack(length))
        pattern = '<%sQ'%length
        buff.write(struct.Struct(pattern).pack(*val1.stop_line_id))
      length = len(self.pole_list)
      buff.write(_struct_I.pack(length))
      for val1 in self.pole_list:
        _x = val1.id
        buff.write(_get_struct_Q().pack(_x))
        _v8 = val1.ground_point
        _x = _v8
        buff.write(_get_struct_3d().pack(_x.x, _x.y, _x.z))
        _v9 = val1.top_point
        _x = _v9
        buff.write(_get_struct_3d().pack(_x.x, _x.y, _x.z))
      length = len(self.traffic_light_list)
      buff.write(_struct_I.pack(length))
      for val1 in self.traffic_light_list:
        _x = val1.id
        buff.write(_get_struct_Q().pack(_x))
        _v10 = val1.surface
        length = len(_v10.x)
        buff.write(_struct_I.pack(length))
        pattern = '<%sd'%length
        buff.write(struct.Struct(pattern).pack(*_v10.x))
        length = len(_v10.y)
        buff.write(_struct_I.pack(length))
        pattern = '<%sd'%length
        buff.write(struct.Struct(pattern).pack(*_v10.y))
        length = len(_v10.z)
        buff.write(_struct_I.pack(length))
        pattern = '<%sd'%length
        buff.write(struct.Struct(pattern).pack(*_v10.z))
        _x = val1
        buff.write(_get_struct_di().pack(_x.heading, _x.traffic_light_type))
        length = len(val1.lane_id)
        buff.write(_struct_I.pack(length))
        pattern = '<%sQ'%length
        buff.write(struct.Struct(pattern).pack(*val1.lane_id))
        _x = val1.box_type
        buff.write(_get_struct_i().pack(_x))
        _v11 = val1.center
        _x = _v11
        buff.write(_get_struct_3d().pack(_x.x, _x.y, _x.z))
      length = len(self.traffic_sign_list)
      buff.write(_struct_I.pack(length))
      for val1 in self.traffic_sign_list:
        _x = val1.id
        buff.write(_get_struct_Q().pack(_x))
        _v12 = val1.surface
        length = len(_v12.x)
        buff.write(_struct_I.pack(length))
        pattern = '<%sd'%length
        buff.write(struct.Struct(pattern).pack(*_v12.x))
        length = len(_v12.y)
        buff.write(_struct_I.pack(length))
        pattern = '<%sd'%length
        buff.write(struct.Struct(pattern).pack(*_v12.y))
        length = len(_v12.z)
        buff.write(_struct_I.pack(length))
        pattern = '<%sd'%length
        buff.write(struct.Struct(pattern).pack(*_v12.z))
        _x = val1
        buff.write(_get_struct_id().pack(_x.type, _x.heading))
        length = len(val1.lane_id)
        buff.write(_struct_I.pack(length))
        pattern = '<%sQ'%length
        buff.write(struct.Struct(pattern).pack(*val1.lane_id))
        _v13 = val1.center
        _x = _v13
        buff.write(_get_struct_3d().pack(_x.x, _x.y, _x.z))
      length = len(self.road_geo_line_list)
      buff.write(_struct_I.pack(length))
      for val1 in self.road_geo_line_list:
        _x = val1
        buff.write(_get_struct_2Q().pack(_x.id, _x.link_id))
        _v14 = val1.shape_point
        length = len(_v14.x)
        buff.write(_struct_I.pack(length))
        pattern = '<%sd'%length
        buff.write(struct.Struct(pattern).pack(*_v14.x))
        length = len(_v14.y)
        buff.write(_struct_I.pack(length))
        pattern = '<%sd'%length
        buff.write(struct.Struct(pattern).pack(*_v14.y))
        length = len(_v14.z)
        buff.write(_struct_I.pack(length))
        pattern = '<%sd'%length
        buff.write(struct.Struct(pattern).pack(*_v14.z))
        length = len(val1.curvature)
        buff.write(_struct_I.pack(length))
        pattern = '<%sd'%length
        buff.write(struct.Struct(pattern).pack(*val1.curvature))
        length = len(val1.slope)
        buff.write(_struct_I.pack(length))
        pattern = '<%sd'%length
        buff.write(struct.Struct(pattern).pack(*val1.slope))
        length = len(val1.heading)
        buff.write(_struct_I.pack(length))
        pattern = '<%sd'%length
        buff.write(struct.Struct(pattern).pack(*val1.heading))
        length = len(val1.shape_point_offset)
        buff.write(_struct_I.pack(length))
        pattern = '<%sd'%length
        buff.write(struct.Struct(pattern).pack(*val1.shape_point_offset))
      length = len(self.stop_line_list)
      buff.write(_struct_I.pack(length))
      for val1 in self.stop_line_list:
        _x = val1.id
        buff.write(_get_struct_Q().pack(_x))
        _v15 = val1.polyline
        length = len(_v15.x)
        buff.write(_struct_I.pack(length))
        pattern = '<%sd'%length
        buff.write(struct.Struct(pattern).pack(*_v15.x))
        length = len(_v15.y)
        buff.write(_struct_I.pack(length))
        pattern = '<%sd'%length
        buff.write(struct.Struct(pattern).pack(*_v15.y))
        length = len(_v15.z)
        buff.write(_struct_I.pack(length))
        pattern = '<%sd'%length
        buff.write(struct.Struct(pattern).pack(*_v15.z))
        length = len(val1.traffic_light_id)
        buff.write(_struct_I.pack(length))
        pattern = '<%sQ'%length
        buff.write(struct.Struct(pattern).pack(*val1.traffic_light_id))
        length = len(val1.traffic_sign_id)
        buff.write(_struct_I.pack(length))
        pattern = '<%sQ'%length
        buff.write(struct.Struct(pattern).pack(*val1.traffic_sign_id))
      _x = self.map_tile_hash
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self.map_version
      buff.write(_get_struct_i().pack(_x))
      _x = self.dynamic_map_info_counter
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      length = len(self.parking_area_list)
      buff.write(_struct_I.pack(length))
      for val1 in self.parking_area_list:
        _x = val1.id
        buff.write(_get_struct_Q().pack(_x))
        _v16 = val1.surface
        length = len(_v16.x)
        buff.write(_struct_I.pack(length))
        pattern = '<%sd'%length
        buff.write(struct.Struct(pattern).pack(*_v16.x))
        length = len(_v16.y)
        buff.write(_struct_I.pack(length))
        pattern = '<%sd'%length
        buff.write(struct.Struct(pattern).pack(*_v16.y))
        length = len(_v16.z)
        buff.write(_struct_I.pack(length))
        pattern = '<%sd'%length
        buff.write(struct.Struct(pattern).pack(*_v16.z))
        _x = val1
        buff.write(_get_struct_2id().pack(_x.marking_type, _x.parking_type, _x.heading))
        length = len(val1.link_feature_points)
        buff.write(_struct_I.pack(length))
        for val2 in val1.link_feature_points:
          _x = val2
          buff.write(_get_struct_if().pack(_x.type, _x.offset))
          _v17 = val2.position
          _x = _v17
          buff.write(_get_struct_3d().pack(_x.x, _x.y, _x.z))
          _x = val2.link_id
          buff.write(_get_struct_Q().pack(_x))
        length = len(val1.link_ids)
        buff.write(_struct_I.pack(length))
        pattern = '<%sQ'%length
        buff.write(struct.Struct(pattern).pack(*val1.link_ids))
        length = len(val1.lane_ids)
        buff.write(_struct_I.pack(length))
        pattern = '<%sQ'%length
        buff.write(struct.Struct(pattern).pack(*val1.lane_ids))
      length = len(self.waiting_zone_list)
      buff.write(_struct_I.pack(length))
      for val1 in self.waiting_zone_list:
        _x = val1.id
        buff.write(_get_struct_Q().pack(_x))
        _v18 = val1.surface
        length = len(_v18.x)
        buff.write(_struct_I.pack(length))
        pattern = '<%sd'%length
        buff.write(struct.Struct(pattern).pack(*_v18.x))
        length = len(_v18.y)
        buff.write(_struct_I.pack(length))
        pattern = '<%sd'%length
        buff.write(struct.Struct(pattern).pack(*_v18.y))
        length = len(_v18.z)
        buff.write(_struct_I.pack(length))
        pattern = '<%sd'%length
        buff.write(struct.Struct(pattern).pack(*_v18.z))
        length = len(val1.link_feature_points)
        buff.write(_struct_I.pack(length))
        for val2 in val1.link_feature_points:
          _x = val2
          buff.write(_get_struct_if().pack(_x.type, _x.offset))
          _v19 = val2.position
          _x = _v19
          buff.write(_get_struct_3d().pack(_x.x, _x.y, _x.z))
          _x = val2.link_id
          buff.write(_get_struct_Q().pack(_x))
        length = len(val1.lane_ids)
        buff.write(_struct_I.pack(length))
        pattern = '<%sQ'%length
        buff.write(struct.Struct(pattern).pack(*val1.lane_ids))
      _x = self.publish_ptp_ts
      buff.write(_get_struct_Q().pack(_x))
      _x = self.publisher_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self
      buff.write(_get_struct_2Q().pack(_x.counter, _x.publish_ts))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize(self, str):
    """
    unpack serialized message in str into this message instance
    :param str: byte array of serialized message, ``str``
    """
    if python3:
      codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      if self.lane_group_list is None:
        self.lane_group_list = None
      if self.lane_list is None:
        self.lane_list = None
      if self.lane_boundary_list is None:
        self.lane_boundary_list = None
      if self.link_list is None:
        self.link_list = None
      if self.crosswalk_list is None:
        self.crosswalk_list = None
      if self.junction_list is None:
        self.junction_list = None
      if self.pole_list is None:
        self.pole_list = None
      if self.traffic_light_list is None:
        self.traffic_light_list = None
      if self.traffic_sign_list is None:
        self.traffic_sign_list = None
      if self.road_geo_line_list is None:
        self.road_geo_line_list = None
      if self.stop_line_list is None:
        self.stop_line_list = None
      if self.parking_area_list is None:
        self.parking_area_list = None
      if self.waiting_zone_list is None:
        self.waiting_zone_list = None
      end = 0
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.lane_group_list = []
      for i in range(0, length):
        val1 = rospy_message_converter.msg.HdLaneGroup()
        start = end
        end += 8
        (val1.id,) = _get_struct_Q().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sQ'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        val1.lane_id = s.unpack(str[start:end])
        start = end
        end += 8
        (val1.link_id,) = _get_struct_Q().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sQ'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        val1.link_id_list = s.unpack(str[start:end])
        start = end
        end += 8
        (val1.max_lane_speed_limit,) = _get_struct_d().unpack(str[start:end])
        self.lane_group_list.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.lane_list = []
      for i in range(0, length):
        val1 = rospy_message_converter.msg.HdLane()
        _x = val1
        start = end
        end += 12
        (_x.id, _x.turn,) = _get_struct_Qi().unpack(str[start:end])
        _v20 = val1.central_line
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sd'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        _v20.x = s.unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sd'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        _v20.y = s.unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sd'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        _v20.z = s.unpack(str[start:end])
        _x = val1
        start = end
        end += 16
        (_x.left_boundary_id, _x.right_boundary_id,) = _get_struct_2Q().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.predecessors = []
        for i in range(0, length):
          val2 = rospy_message_converter.msg.Predecessor()
          _x = val2
          start = end
          end += 16
          (_x.self_id, _x.other_id,) = _get_struct_2Q().unpack(str[start:end])
          val1.predecessors.append(val2)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.successors = []
        for i in range(0, length):
          val2 = rospy_message_converter.msg.Successor()
          _x = val2
          start = end
          end += 16
          (_x.self_id, _x.other_id,) = _get_struct_2Q().unpack(str[start:end])
          val1.successors.append(val2)
        _x = val1
        start = end
        end += 16
        (_x.min_speed_limit, _x.max_speed_limit,) = _get_struct_2d().unpack(str[start:end])
        _v21 = val1.left_forward_neighbor
        _x = _v21
        start = end
        end += 48
        (_x.self_id, _x.other_id, _x.self_start_s, _x.self_end_s, _x.other_start_s, _x.other_end_s,) = _get_struct_2Q4d().unpack(str[start:end])
        _v22 = val1.right_forward_neighbor
        _x = _v22
        start = end
        end += 48
        (_x.self_id, _x.other_id, _x.self_start_s, _x.self_end_s, _x.other_start_s, _x.other_end_s,) = _get_struct_2Q4d().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.left_forward_neighbors = []
        for i in range(0, length):
          val2 = rospy_message_converter.msg.NeightborSegment()
          _x = val2
          start = end
          end += 48
          (_x.self_id, _x.other_id, _x.self_start_s, _x.self_end_s, _x.other_start_s, _x.other_end_s,) = _get_struct_2Q4d().unpack(str[start:end])
          val1.left_forward_neighbors.append(val2)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.right_forward_neighbors = []
        for i in range(0, length):
          val2 = rospy_message_converter.msg.NeightborSegment()
          _x = val2
          start = end
          end += 48
          (_x.self_id, _x.other_id, _x.self_start_s, _x.self_end_s, _x.other_start_s, _x.other_end_s,) = _get_struct_2Q4d().unpack(str[start:end])
          val1.right_forward_neighbors.append(val2)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.left_reverse_neighbors = []
        for i in range(0, length):
          val2 = rospy_message_converter.msg.NeightborSegment()
          _x = val2
          start = end
          end += 48
          (_x.self_id, _x.other_id, _x.self_start_s, _x.self_end_s, _x.other_start_s, _x.other_end_s,) = _get_struct_2Q4d().unpack(str[start:end])
          val1.left_reverse_neighbors.append(val2)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.right_reverse_neighbors = []
        for i in range(0, length):
          val2 = rospy_message_converter.msg.NeightborSegment()
          _x = val2
          start = end
          end += 48
          (_x.self_id, _x.other_id, _x.self_start_s, _x.self_end_s, _x.other_start_s, _x.other_end_s,) = _get_struct_2Q4d().unpack(str[start:end])
          val1.right_reverse_neighbors.append(val2)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.overlaps = []
        for i in range(0, length):
          val2 = rospy_message_converter.msg.Overlap()
          _x = val2
          start = end
          end += 36
          (_x.self_id, _x.other_id, _x.type, _x.start_s, _x.end_s,) = _get_struct_2Qi2d().unpack(str[start:end])
          val1.overlaps.append(val2)
        _x = val1
        start = end
        end += 28
        (_x.lane_group_id, _x.connection_type, _x.sequence_id, _x.lane_type, _x.length,) = _get_struct_Q3id().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sd'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        val1.OBSOLETE_width = s.unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sd'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        val1.width = s.unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sd'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        val1.centerline_s = s.unpack(str[start:end])
        _x = val1
        start = end
        end += 17
        (_x.lane_status, _x.lane_used_in_both_directions, _x.tile_id, _x.advisory_speed_limit,) = _get_struct_IBId().unpack(str[start:end])
        val1.lane_used_in_both_directions = bool(val1.lane_used_in_both_directions)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.downgrade_lane_segments = []
        for i in range(0, length):
          val2 = rospy_message_converter.msg.DowngradeLaneSegment()
          _x = val2
          start = end
          end += 32
          (_x.ad_mode_type, _x.start_s, _x.end_s, _x.info_value, _x.dynamic_info, _x.road_scenario_type,) = _get_struct_i2d3i().unpack(str[start:end])
          val1.downgrade_lane_segments.append(val2)
        _x = val1
        start = end
        end += 16
        (_x.electronic_eye_speed_limit, _x.max_lane_group_speed_limit,) = _get_struct_2d().unpack(str[start:end])
        self.lane_list.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.lane_boundary_list = []
      for i in range(0, length):
        val1 = rospy_message_converter.msg.HdLaneBoundary()
        start = end
        end += 8
        (val1.id,) = _get_struct_Q().unpack(str[start:end])
        _v23 = val1.central_line
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sd'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        _v23.x = s.unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sd'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        _v23.y = s.unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sd'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        _v23.z = s.unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%si'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        val1.colors = s.unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%si'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        val1.types = s.unpack(str[start:end])
        _x = val1
        start = end
        end += 20
        (_x.left_lane_id, _x.right_lane_id, _x.sequence_id,) = _get_struct_2Qi().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sQ'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        val1.predecessor_lane_boundary_ids = s.unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sQ'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        val1.successor_lane_boundary_ids = s.unpack(str[start:end])
        start = end
        end += 4
        (val1.lane_separate,) = _get_struct_I().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.feature_points = []
        for i in range(0, length):
          val2 = rospy_message_converter.msg.FeaturePoint()
          _x = val2
          start = end
          end += 8
          (_x.type, _x.point_index,) = _get_struct_2i().unpack(str[start:end])
          val1.feature_points.append(val2)
        self.lane_boundary_list.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.link_list = []
      for i in range(0, length):
        val1 = rospy_message_converter.msg.HdLinkInfo()
        _x = val1
        start = end
        end += 28
        (_x.id, _x.length, _x.average_speed, _x.priority_road_class, _x.travel_direction,) = _get_struct_QdI2i().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%si'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        val1.form_way = s.unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sQ'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        val1.predecessor_link_ids = s.unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sQ'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        val1.successor_link_ids = s.unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sQ'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        val1.lane_ids = s.unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sQ'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        val1.lane_group_ids = s.unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sQ'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        val1.road_geo_line_ids = s.unpack(str[start:end])
        start = end
        end += 1
        (val1.complex_intersection,) = _get_struct_B().unpack(str[start:end])
        val1.complex_intersection = bool(val1.complex_intersection)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.feature_points = []
        for i in range(0, length):
          val2 = rospy_message_converter.msg.LinkFeaturePoint()
          _x = val2
          start = end
          end += 8
          (_x.type, _x.offset,) = _get_struct_if().unpack(str[start:end])
          _v24 = val2.position
          _x = _v24
          start = end
          end += 24
          (_x.x, _x.y, _x.z,) = _get_struct_3d().unpack(str[start:end])
          start = end
          end += 8
          (val2.link_id,) = _get_struct_Q().unpack(str[start:end])
          val1.feature_points.append(val2)
        self.link_list.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.crosswalk_list = []
      for i in range(0, length):
        val1 = rospy_message_converter.msg.HdCrosswalk()
        start = end
        end += 8
        (val1.id,) = _get_struct_Q().unpack(str[start:end])
        _v25 = val1.surface
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sd'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        _v25.x = s.unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sd'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        _v25.y = s.unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sd'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        _v25.z = s.unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sQ'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        val1.lane_id = s.unpack(str[start:end])
        self.crosswalk_list.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.junction_list = []
      for i in range(0, length):
        val1 = rospy_message_converter.msg.HdJunction()
        start = end
        end += 8
        (val1.id,) = _get_struct_Q().unpack(str[start:end])
        _v26 = val1.surface
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sd'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        _v26.x = s.unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sd'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        _v26.y = s.unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sd'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        _v26.z = s.unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sQ'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        val1.lane_id = s.unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sQ'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        val1.crosswalk_id = s.unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sQ'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        val1.stop_line_id = s.unpack(str[start:end])
        self.junction_list.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.pole_list = []
      for i in range(0, length):
        val1 = rospy_message_converter.msg.HdPole()
        start = end
        end += 8
        (val1.id,) = _get_struct_Q().unpack(str[start:end])
        _v27 = val1.ground_point
        _x = _v27
        start = end
        end += 24
        (_x.x, _x.y, _x.z,) = _get_struct_3d().unpack(str[start:end])
        _v28 = val1.top_point
        _x = _v28
        start = end
        end += 24
        (_x.x, _x.y, _x.z,) = _get_struct_3d().unpack(str[start:end])
        self.pole_list.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.traffic_light_list = []
      for i in range(0, length):
        val1 = rospy_message_converter.msg.HdTrafficLight()
        start = end
        end += 8
        (val1.id,) = _get_struct_Q().unpack(str[start:end])
        _v29 = val1.surface
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sd'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        _v29.x = s.unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sd'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        _v29.y = s.unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sd'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        _v29.z = s.unpack(str[start:end])
        _x = val1
        start = end
        end += 12
        (_x.heading, _x.traffic_light_type,) = _get_struct_di().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sQ'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        val1.lane_id = s.unpack(str[start:end])
        start = end
        end += 4
        (val1.box_type,) = _get_struct_i().unpack(str[start:end])
        _v30 = val1.center
        _x = _v30
        start = end
        end += 24
        (_x.x, _x.y, _x.z,) = _get_struct_3d().unpack(str[start:end])
        self.traffic_light_list.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.traffic_sign_list = []
      for i in range(0, length):
        val1 = rospy_message_converter.msg.HdTrafficSign()
        start = end
        end += 8
        (val1.id,) = _get_struct_Q().unpack(str[start:end])
        _v31 = val1.surface
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sd'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        _v31.x = s.unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sd'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        _v31.y = s.unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sd'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        _v31.z = s.unpack(str[start:end])
        _x = val1
        start = end
        end += 12
        (_x.type, _x.heading,) = _get_struct_id().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sQ'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        val1.lane_id = s.unpack(str[start:end])
        _v32 = val1.center
        _x = _v32
        start = end
        end += 24
        (_x.x, _x.y, _x.z,) = _get_struct_3d().unpack(str[start:end])
        self.traffic_sign_list.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.road_geo_line_list = []
      for i in range(0, length):
        val1 = rospy_message_converter.msg.HdRoadGeoLine()
        _x = val1
        start = end
        end += 16
        (_x.id, _x.link_id,) = _get_struct_2Q().unpack(str[start:end])
        _v33 = val1.shape_point
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sd'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        _v33.x = s.unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sd'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        _v33.y = s.unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sd'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        _v33.z = s.unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sd'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        val1.curvature = s.unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sd'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        val1.slope = s.unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sd'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        val1.heading = s.unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sd'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        val1.shape_point_offset = s.unpack(str[start:end])
        self.road_geo_line_list.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.stop_line_list = []
      for i in range(0, length):
        val1 = rospy_message_converter.msg.HdStopLine()
        start = end
        end += 8
        (val1.id,) = _get_struct_Q().unpack(str[start:end])
        _v34 = val1.polyline
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sd'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        _v34.x = s.unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sd'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        _v34.y = s.unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sd'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        _v34.z = s.unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sQ'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        val1.traffic_light_id = s.unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sQ'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        val1.traffic_sign_id = s.unpack(str[start:end])
        self.stop_line_list.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.map_tile_hash = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.map_tile_hash = str[start:end]
      start = end
      end += 4
      (self.map_version,) = _get_struct_i().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.dynamic_map_info_counter = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.dynamic_map_info_counter = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.parking_area_list = []
      for i in range(0, length):
        val1 = rospy_message_converter.msg.HdParkingArea()
        start = end
        end += 8
        (val1.id,) = _get_struct_Q().unpack(str[start:end])
        _v35 = val1.surface
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sd'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        _v35.x = s.unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sd'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        _v35.y = s.unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sd'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        _v35.z = s.unpack(str[start:end])
        _x = val1
        start = end
        end += 16
        (_x.marking_type, _x.parking_type, _x.heading,) = _get_struct_2id().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.link_feature_points = []
        for i in range(0, length):
          val2 = rospy_message_converter.msg.LinkFeaturePoint()
          _x = val2
          start = end
          end += 8
          (_x.type, _x.offset,) = _get_struct_if().unpack(str[start:end])
          _v36 = val2.position
          _x = _v36
          start = end
          end += 24
          (_x.x, _x.y, _x.z,) = _get_struct_3d().unpack(str[start:end])
          start = end
          end += 8
          (val2.link_id,) = _get_struct_Q().unpack(str[start:end])
          val1.link_feature_points.append(val2)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sQ'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        val1.link_ids = s.unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sQ'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        val1.lane_ids = s.unpack(str[start:end])
        self.parking_area_list.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.waiting_zone_list = []
      for i in range(0, length):
        val1 = rospy_message_converter.msg.HdWaitingZone()
        start = end
        end += 8
        (val1.id,) = _get_struct_Q().unpack(str[start:end])
        _v37 = val1.surface
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sd'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        _v37.x = s.unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sd'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        _v37.y = s.unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sd'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        _v37.z = s.unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.link_feature_points = []
        for i in range(0, length):
          val2 = rospy_message_converter.msg.LinkFeaturePoint()
          _x = val2
          start = end
          end += 8
          (_x.type, _x.offset,) = _get_struct_if().unpack(str[start:end])
          _v38 = val2.position
          _x = _v38
          start = end
          end += 24
          (_x.x, _x.y, _x.z,) = _get_struct_3d().unpack(str[start:end])
          start = end
          end += 8
          (val2.link_id,) = _get_struct_Q().unpack(str[start:end])
          val1.link_feature_points.append(val2)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sQ'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        val1.lane_ids = s.unpack(str[start:end])
        self.waiting_zone_list.append(val1)
      start = end
      end += 8
      (self.publish_ptp_ts,) = _get_struct_Q().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.publisher_id = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.publisher_id = str[start:end]
      _x = self
      start = end
      end += 16
      (_x.counter, _x.publish_ts,) = _get_struct_2Q().unpack(str[start:end])
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill


  def serialize_numpy(self, buff, numpy):
    """
    serialize message with numpy array types into buffer
    :param buff: buffer, ``StringIO``
    :param numpy: numpy python module
    """
    try:
      length = len(self.lane_group_list)
      buff.write(_struct_I.pack(length))
      for val1 in self.lane_group_list:
        _x = val1.id
        buff.write(_get_struct_Q().pack(_x))
        length = len(val1.lane_id)
        buff.write(_struct_I.pack(length))
        pattern = '<%sQ'%length
        buff.write(val1.lane_id.tostring())
        _x = val1.link_id
        buff.write(_get_struct_Q().pack(_x))
        length = len(val1.link_id_list)
        buff.write(_struct_I.pack(length))
        pattern = '<%sQ'%length
        buff.write(val1.link_id_list.tostring())
        _x = val1.max_lane_speed_limit
        buff.write(_get_struct_d().pack(_x))
      length = len(self.lane_list)
      buff.write(_struct_I.pack(length))
      for val1 in self.lane_list:
        _x = val1
        buff.write(_get_struct_Qi().pack(_x.id, _x.turn))
        _v39 = val1.central_line
        length = len(_v39.x)
        buff.write(_struct_I.pack(length))
        pattern = '<%sd'%length
        buff.write(_v39.x.tostring())
        length = len(_v39.y)
        buff.write(_struct_I.pack(length))
        pattern = '<%sd'%length
        buff.write(_v39.y.tostring())
        length = len(_v39.z)
        buff.write(_struct_I.pack(length))
        pattern = '<%sd'%length
        buff.write(_v39.z.tostring())
        _x = val1
        buff.write(_get_struct_2Q().pack(_x.left_boundary_id, _x.right_boundary_id))
        length = len(val1.predecessors)
        buff.write(_struct_I.pack(length))
        for val2 in val1.predecessors:
          _x = val2
          buff.write(_get_struct_2Q().pack(_x.self_id, _x.other_id))
        length = len(val1.successors)
        buff.write(_struct_I.pack(length))
        for val2 in val1.successors:
          _x = val2
          buff.write(_get_struct_2Q().pack(_x.self_id, _x.other_id))
        _x = val1
        buff.write(_get_struct_2d().pack(_x.min_speed_limit, _x.max_speed_limit))
        _v40 = val1.left_forward_neighbor
        _x = _v40
        buff.write(_get_struct_2Q4d().pack(_x.self_id, _x.other_id, _x.self_start_s, _x.self_end_s, _x.other_start_s, _x.other_end_s))
        _v41 = val1.right_forward_neighbor
        _x = _v41
        buff.write(_get_struct_2Q4d().pack(_x.self_id, _x.other_id, _x.self_start_s, _x.self_end_s, _x.other_start_s, _x.other_end_s))
        length = len(val1.left_forward_neighbors)
        buff.write(_struct_I.pack(length))
        for val2 in val1.left_forward_neighbors:
          _x = val2
          buff.write(_get_struct_2Q4d().pack(_x.self_id, _x.other_id, _x.self_start_s, _x.self_end_s, _x.other_start_s, _x.other_end_s))
        length = len(val1.right_forward_neighbors)
        buff.write(_struct_I.pack(length))
        for val2 in val1.right_forward_neighbors:
          _x = val2
          buff.write(_get_struct_2Q4d().pack(_x.self_id, _x.other_id, _x.self_start_s, _x.self_end_s, _x.other_start_s, _x.other_end_s))
        length = len(val1.left_reverse_neighbors)
        buff.write(_struct_I.pack(length))
        for val2 in val1.left_reverse_neighbors:
          _x = val2
          buff.write(_get_struct_2Q4d().pack(_x.self_id, _x.other_id, _x.self_start_s, _x.self_end_s, _x.other_start_s, _x.other_end_s))
        length = len(val1.right_reverse_neighbors)
        buff.write(_struct_I.pack(length))
        for val2 in val1.right_reverse_neighbors:
          _x = val2
          buff.write(_get_struct_2Q4d().pack(_x.self_id, _x.other_id, _x.self_start_s, _x.self_end_s, _x.other_start_s, _x.other_end_s))
        length = len(val1.overlaps)
        buff.write(_struct_I.pack(length))
        for val2 in val1.overlaps:
          _x = val2
          buff.write(_get_struct_2Qi2d().pack(_x.self_id, _x.other_id, _x.type, _x.start_s, _x.end_s))
        _x = val1
        buff.write(_get_struct_Q3id().pack(_x.lane_group_id, _x.connection_type, _x.sequence_id, _x.lane_type, _x.length))
        length = len(val1.OBSOLETE_width)
        buff.write(_struct_I.pack(length))
        pattern = '<%sd'%length
        buff.write(val1.OBSOLETE_width.tostring())
        length = len(val1.width)
        buff.write(_struct_I.pack(length))
        pattern = '<%sd'%length
        buff.write(val1.width.tostring())
        length = len(val1.centerline_s)
        buff.write(_struct_I.pack(length))
        pattern = '<%sd'%length
        buff.write(val1.centerline_s.tostring())
        _x = val1
        buff.write(_get_struct_IBId().pack(_x.lane_status, _x.lane_used_in_both_directions, _x.tile_id, _x.advisory_speed_limit))
        length = len(val1.downgrade_lane_segments)
        buff.write(_struct_I.pack(length))
        for val2 in val1.downgrade_lane_segments:
          _x = val2
          buff.write(_get_struct_i2d3i().pack(_x.ad_mode_type, _x.start_s, _x.end_s, _x.info_value, _x.dynamic_info, _x.road_scenario_type))
        _x = val1
        buff.write(_get_struct_2d().pack(_x.electronic_eye_speed_limit, _x.max_lane_group_speed_limit))
      length = len(self.lane_boundary_list)
      buff.write(_struct_I.pack(length))
      for val1 in self.lane_boundary_list:
        _x = val1.id
        buff.write(_get_struct_Q().pack(_x))
        _v42 = val1.central_line
        length = len(_v42.x)
        buff.write(_struct_I.pack(length))
        pattern = '<%sd'%length
        buff.write(_v42.x.tostring())
        length = len(_v42.y)
        buff.write(_struct_I.pack(length))
        pattern = '<%sd'%length
        buff.write(_v42.y.tostring())
        length = len(_v42.z)
        buff.write(_struct_I.pack(length))
        pattern = '<%sd'%length
        buff.write(_v42.z.tostring())
        length = len(val1.colors)
        buff.write(_struct_I.pack(length))
        pattern = '<%si'%length
        buff.write(val1.colors.tostring())
        length = len(val1.types)
        buff.write(_struct_I.pack(length))
        pattern = '<%si'%length
        buff.write(val1.types.tostring())
        _x = val1
        buff.write(_get_struct_2Qi().pack(_x.left_lane_id, _x.right_lane_id, _x.sequence_id))
        length = len(val1.predecessor_lane_boundary_ids)
        buff.write(_struct_I.pack(length))
        pattern = '<%sQ'%length
        buff.write(val1.predecessor_lane_boundary_ids.tostring())
        length = len(val1.successor_lane_boundary_ids)
        buff.write(_struct_I.pack(length))
        pattern = '<%sQ'%length
        buff.write(val1.successor_lane_boundary_ids.tostring())
        _x = val1.lane_separate
        buff.write(_get_struct_I().pack(_x))
        length = len(val1.feature_points)
        buff.write(_struct_I.pack(length))
        for val2 in val1.feature_points:
          _x = val2
          buff.write(_get_struct_2i().pack(_x.type, _x.point_index))
      length = len(self.link_list)
      buff.write(_struct_I.pack(length))
      for val1 in self.link_list:
        _x = val1
        buff.write(_get_struct_QdI2i().pack(_x.id, _x.length, _x.average_speed, _x.priority_road_class, _x.travel_direction))
        length = len(val1.form_way)
        buff.write(_struct_I.pack(length))
        pattern = '<%si'%length
        buff.write(val1.form_way.tostring())
        length = len(val1.predecessor_link_ids)
        buff.write(_struct_I.pack(length))
        pattern = '<%sQ'%length
        buff.write(val1.predecessor_link_ids.tostring())
        length = len(val1.successor_link_ids)
        buff.write(_struct_I.pack(length))
        pattern = '<%sQ'%length
        buff.write(val1.successor_link_ids.tostring())
        length = len(val1.lane_ids)
        buff.write(_struct_I.pack(length))
        pattern = '<%sQ'%length
        buff.write(val1.lane_ids.tostring())
        length = len(val1.lane_group_ids)
        buff.write(_struct_I.pack(length))
        pattern = '<%sQ'%length
        buff.write(val1.lane_group_ids.tostring())
        length = len(val1.road_geo_line_ids)
        buff.write(_struct_I.pack(length))
        pattern = '<%sQ'%length
        buff.write(val1.road_geo_line_ids.tostring())
        _x = val1.complex_intersection
        buff.write(_get_struct_B().pack(_x))
        length = len(val1.feature_points)
        buff.write(_struct_I.pack(length))
        for val2 in val1.feature_points:
          _x = val2
          buff.write(_get_struct_if().pack(_x.type, _x.offset))
          _v43 = val2.position
          _x = _v43
          buff.write(_get_struct_3d().pack(_x.x, _x.y, _x.z))
          _x = val2.link_id
          buff.write(_get_struct_Q().pack(_x))
      length = len(self.crosswalk_list)
      buff.write(_struct_I.pack(length))
      for val1 in self.crosswalk_list:
        _x = val1.id
        buff.write(_get_struct_Q().pack(_x))
        _v44 = val1.surface
        length = len(_v44.x)
        buff.write(_struct_I.pack(length))
        pattern = '<%sd'%length
        buff.write(_v44.x.tostring())
        length = len(_v44.y)
        buff.write(_struct_I.pack(length))
        pattern = '<%sd'%length
        buff.write(_v44.y.tostring())
        length = len(_v44.z)
        buff.write(_struct_I.pack(length))
        pattern = '<%sd'%length
        buff.write(_v44.z.tostring())
        length = len(val1.lane_id)
        buff.write(_struct_I.pack(length))
        pattern = '<%sQ'%length
        buff.write(val1.lane_id.tostring())
      length = len(self.junction_list)
      buff.write(_struct_I.pack(length))
      for val1 in self.junction_list:
        _x = val1.id
        buff.write(_get_struct_Q().pack(_x))
        _v45 = val1.surface
        length = len(_v45.x)
        buff.write(_struct_I.pack(length))
        pattern = '<%sd'%length
        buff.write(_v45.x.tostring())
        length = len(_v45.y)
        buff.write(_struct_I.pack(length))
        pattern = '<%sd'%length
        buff.write(_v45.y.tostring())
        length = len(_v45.z)
        buff.write(_struct_I.pack(length))
        pattern = '<%sd'%length
        buff.write(_v45.z.tostring())
        length = len(val1.lane_id)
        buff.write(_struct_I.pack(length))
        pattern = '<%sQ'%length
        buff.write(val1.lane_id.tostring())
        length = len(val1.crosswalk_id)
        buff.write(_struct_I.pack(length))
        pattern = '<%sQ'%length
        buff.write(val1.crosswalk_id.tostring())
        length = len(val1.stop_line_id)
        buff.write(_struct_I.pack(length))
        pattern = '<%sQ'%length
        buff.write(val1.stop_line_id.tostring())
      length = len(self.pole_list)
      buff.write(_struct_I.pack(length))
      for val1 in self.pole_list:
        _x = val1.id
        buff.write(_get_struct_Q().pack(_x))
        _v46 = val1.ground_point
        _x = _v46
        buff.write(_get_struct_3d().pack(_x.x, _x.y, _x.z))
        _v47 = val1.top_point
        _x = _v47
        buff.write(_get_struct_3d().pack(_x.x, _x.y, _x.z))
      length = len(self.traffic_light_list)
      buff.write(_struct_I.pack(length))
      for val1 in self.traffic_light_list:
        _x = val1.id
        buff.write(_get_struct_Q().pack(_x))
        _v48 = val1.surface
        length = len(_v48.x)
        buff.write(_struct_I.pack(length))
        pattern = '<%sd'%length
        buff.write(_v48.x.tostring())
        length = len(_v48.y)
        buff.write(_struct_I.pack(length))
        pattern = '<%sd'%length
        buff.write(_v48.y.tostring())
        length = len(_v48.z)
        buff.write(_struct_I.pack(length))
        pattern = '<%sd'%length
        buff.write(_v48.z.tostring())
        _x = val1
        buff.write(_get_struct_di().pack(_x.heading, _x.traffic_light_type))
        length = len(val1.lane_id)
        buff.write(_struct_I.pack(length))
        pattern = '<%sQ'%length
        buff.write(val1.lane_id.tostring())
        _x = val1.box_type
        buff.write(_get_struct_i().pack(_x))
        _v49 = val1.center
        _x = _v49
        buff.write(_get_struct_3d().pack(_x.x, _x.y, _x.z))
      length = len(self.traffic_sign_list)
      buff.write(_struct_I.pack(length))
      for val1 in self.traffic_sign_list:
        _x = val1.id
        buff.write(_get_struct_Q().pack(_x))
        _v50 = val1.surface
        length = len(_v50.x)
        buff.write(_struct_I.pack(length))
        pattern = '<%sd'%length
        buff.write(_v50.x.tostring())
        length = len(_v50.y)
        buff.write(_struct_I.pack(length))
        pattern = '<%sd'%length
        buff.write(_v50.y.tostring())
        length = len(_v50.z)
        buff.write(_struct_I.pack(length))
        pattern = '<%sd'%length
        buff.write(_v50.z.tostring())
        _x = val1
        buff.write(_get_struct_id().pack(_x.type, _x.heading))
        length = len(val1.lane_id)
        buff.write(_struct_I.pack(length))
        pattern = '<%sQ'%length
        buff.write(val1.lane_id.tostring())
        _v51 = val1.center
        _x = _v51
        buff.write(_get_struct_3d().pack(_x.x, _x.y, _x.z))
      length = len(self.road_geo_line_list)
      buff.write(_struct_I.pack(length))
      for val1 in self.road_geo_line_list:
        _x = val1
        buff.write(_get_struct_2Q().pack(_x.id, _x.link_id))
        _v52 = val1.shape_point
        length = len(_v52.x)
        buff.write(_struct_I.pack(length))
        pattern = '<%sd'%length
        buff.write(_v52.x.tostring())
        length = len(_v52.y)
        buff.write(_struct_I.pack(length))
        pattern = '<%sd'%length
        buff.write(_v52.y.tostring())
        length = len(_v52.z)
        buff.write(_struct_I.pack(length))
        pattern = '<%sd'%length
        buff.write(_v52.z.tostring())
        length = len(val1.curvature)
        buff.write(_struct_I.pack(length))
        pattern = '<%sd'%length
        buff.write(val1.curvature.tostring())
        length = len(val1.slope)
        buff.write(_struct_I.pack(length))
        pattern = '<%sd'%length
        buff.write(val1.slope.tostring())
        length = len(val1.heading)
        buff.write(_struct_I.pack(length))
        pattern = '<%sd'%length
        buff.write(val1.heading.tostring())
        length = len(val1.shape_point_offset)
        buff.write(_struct_I.pack(length))
        pattern = '<%sd'%length
        buff.write(val1.shape_point_offset.tostring())
      length = len(self.stop_line_list)
      buff.write(_struct_I.pack(length))
      for val1 in self.stop_line_list:
        _x = val1.id
        buff.write(_get_struct_Q().pack(_x))
        _v53 = val1.polyline
        length = len(_v53.x)
        buff.write(_struct_I.pack(length))
        pattern = '<%sd'%length
        buff.write(_v53.x.tostring())
        length = len(_v53.y)
        buff.write(_struct_I.pack(length))
        pattern = '<%sd'%length
        buff.write(_v53.y.tostring())
        length = len(_v53.z)
        buff.write(_struct_I.pack(length))
        pattern = '<%sd'%length
        buff.write(_v53.z.tostring())
        length = len(val1.traffic_light_id)
        buff.write(_struct_I.pack(length))
        pattern = '<%sQ'%length
        buff.write(val1.traffic_light_id.tostring())
        length = len(val1.traffic_sign_id)
        buff.write(_struct_I.pack(length))
        pattern = '<%sQ'%length
        buff.write(val1.traffic_sign_id.tostring())
      _x = self.map_tile_hash
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self.map_version
      buff.write(_get_struct_i().pack(_x))
      _x = self.dynamic_map_info_counter
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      length = len(self.parking_area_list)
      buff.write(_struct_I.pack(length))
      for val1 in self.parking_area_list:
        _x = val1.id
        buff.write(_get_struct_Q().pack(_x))
        _v54 = val1.surface
        length = len(_v54.x)
        buff.write(_struct_I.pack(length))
        pattern = '<%sd'%length
        buff.write(_v54.x.tostring())
        length = len(_v54.y)
        buff.write(_struct_I.pack(length))
        pattern = '<%sd'%length
        buff.write(_v54.y.tostring())
        length = len(_v54.z)
        buff.write(_struct_I.pack(length))
        pattern = '<%sd'%length
        buff.write(_v54.z.tostring())
        _x = val1
        buff.write(_get_struct_2id().pack(_x.marking_type, _x.parking_type, _x.heading))
        length = len(val1.link_feature_points)
        buff.write(_struct_I.pack(length))
        for val2 in val1.link_feature_points:
          _x = val2
          buff.write(_get_struct_if().pack(_x.type, _x.offset))
          _v55 = val2.position
          _x = _v55
          buff.write(_get_struct_3d().pack(_x.x, _x.y, _x.z))
          _x = val2.link_id
          buff.write(_get_struct_Q().pack(_x))
        length = len(val1.link_ids)
        buff.write(_struct_I.pack(length))
        pattern = '<%sQ'%length
        buff.write(val1.link_ids.tostring())
        length = len(val1.lane_ids)
        buff.write(_struct_I.pack(length))
        pattern = '<%sQ'%length
        buff.write(val1.lane_ids.tostring())
      length = len(self.waiting_zone_list)
      buff.write(_struct_I.pack(length))
      for val1 in self.waiting_zone_list:
        _x = val1.id
        buff.write(_get_struct_Q().pack(_x))
        _v56 = val1.surface
        length = len(_v56.x)
        buff.write(_struct_I.pack(length))
        pattern = '<%sd'%length
        buff.write(_v56.x.tostring())
        length = len(_v56.y)
        buff.write(_struct_I.pack(length))
        pattern = '<%sd'%length
        buff.write(_v56.y.tostring())
        length = len(_v56.z)
        buff.write(_struct_I.pack(length))
        pattern = '<%sd'%length
        buff.write(_v56.z.tostring())
        length = len(val1.link_feature_points)
        buff.write(_struct_I.pack(length))
        for val2 in val1.link_feature_points:
          _x = val2
          buff.write(_get_struct_if().pack(_x.type, _x.offset))
          _v57 = val2.position
          _x = _v57
          buff.write(_get_struct_3d().pack(_x.x, _x.y, _x.z))
          _x = val2.link_id
          buff.write(_get_struct_Q().pack(_x))
        length = len(val1.lane_ids)
        buff.write(_struct_I.pack(length))
        pattern = '<%sQ'%length
        buff.write(val1.lane_ids.tostring())
      _x = self.publish_ptp_ts
      buff.write(_get_struct_Q().pack(_x))
      _x = self.publisher_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self
      buff.write(_get_struct_2Q().pack(_x.counter, _x.publish_ts))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize_numpy(self, str, numpy):
    """
    unpack serialized message in str into this message instance using numpy for array types
    :param str: byte array of serialized message, ``str``
    :param numpy: numpy python module
    """
    if python3:
      codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      if self.lane_group_list is None:
        self.lane_group_list = None
      if self.lane_list is None:
        self.lane_list = None
      if self.lane_boundary_list is None:
        self.lane_boundary_list = None
      if self.link_list is None:
        self.link_list = None
      if self.crosswalk_list is None:
        self.crosswalk_list = None
      if self.junction_list is None:
        self.junction_list = None
      if self.pole_list is None:
        self.pole_list = None
      if self.traffic_light_list is None:
        self.traffic_light_list = None
      if self.traffic_sign_list is None:
        self.traffic_sign_list = None
      if self.road_geo_line_list is None:
        self.road_geo_line_list = None
      if self.stop_line_list is None:
        self.stop_line_list = None
      if self.parking_area_list is None:
        self.parking_area_list = None
      if self.waiting_zone_list is None:
        self.waiting_zone_list = None
      end = 0
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.lane_group_list = []
      for i in range(0, length):
        val1 = rospy_message_converter.msg.HdLaneGroup()
        start = end
        end += 8
        (val1.id,) = _get_struct_Q().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sQ'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        val1.lane_id = numpy.frombuffer(str[start:end], dtype=numpy.uint64, count=length)
        start = end
        end += 8
        (val1.link_id,) = _get_struct_Q().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sQ'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        val1.link_id_list = numpy.frombuffer(str[start:end], dtype=numpy.uint64, count=length)
        start = end
        end += 8
        (val1.max_lane_speed_limit,) = _get_struct_d().unpack(str[start:end])
        self.lane_group_list.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.lane_list = []
      for i in range(0, length):
        val1 = rospy_message_converter.msg.HdLane()
        _x = val1
        start = end
        end += 12
        (_x.id, _x.turn,) = _get_struct_Qi().unpack(str[start:end])
        _v58 = val1.central_line
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sd'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        _v58.x = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sd'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        _v58.y = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sd'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        _v58.z = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
        _x = val1
        start = end
        end += 16
        (_x.left_boundary_id, _x.right_boundary_id,) = _get_struct_2Q().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.predecessors = []
        for i in range(0, length):
          val2 = rospy_message_converter.msg.Predecessor()
          _x = val2
          start = end
          end += 16
          (_x.self_id, _x.other_id,) = _get_struct_2Q().unpack(str[start:end])
          val1.predecessors.append(val2)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.successors = []
        for i in range(0, length):
          val2 = rospy_message_converter.msg.Successor()
          _x = val2
          start = end
          end += 16
          (_x.self_id, _x.other_id,) = _get_struct_2Q().unpack(str[start:end])
          val1.successors.append(val2)
        _x = val1
        start = end
        end += 16
        (_x.min_speed_limit, _x.max_speed_limit,) = _get_struct_2d().unpack(str[start:end])
        _v59 = val1.left_forward_neighbor
        _x = _v59
        start = end
        end += 48
        (_x.self_id, _x.other_id, _x.self_start_s, _x.self_end_s, _x.other_start_s, _x.other_end_s,) = _get_struct_2Q4d().unpack(str[start:end])
        _v60 = val1.right_forward_neighbor
        _x = _v60
        start = end
        end += 48
        (_x.self_id, _x.other_id, _x.self_start_s, _x.self_end_s, _x.other_start_s, _x.other_end_s,) = _get_struct_2Q4d().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.left_forward_neighbors = []
        for i in range(0, length):
          val2 = rospy_message_converter.msg.NeightborSegment()
          _x = val2
          start = end
          end += 48
          (_x.self_id, _x.other_id, _x.self_start_s, _x.self_end_s, _x.other_start_s, _x.other_end_s,) = _get_struct_2Q4d().unpack(str[start:end])
          val1.left_forward_neighbors.append(val2)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.right_forward_neighbors = []
        for i in range(0, length):
          val2 = rospy_message_converter.msg.NeightborSegment()
          _x = val2
          start = end
          end += 48
          (_x.self_id, _x.other_id, _x.self_start_s, _x.self_end_s, _x.other_start_s, _x.other_end_s,) = _get_struct_2Q4d().unpack(str[start:end])
          val1.right_forward_neighbors.append(val2)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.left_reverse_neighbors = []
        for i in range(0, length):
          val2 = rospy_message_converter.msg.NeightborSegment()
          _x = val2
          start = end
          end += 48
          (_x.self_id, _x.other_id, _x.self_start_s, _x.self_end_s, _x.other_start_s, _x.other_end_s,) = _get_struct_2Q4d().unpack(str[start:end])
          val1.left_reverse_neighbors.append(val2)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.right_reverse_neighbors = []
        for i in range(0, length):
          val2 = rospy_message_converter.msg.NeightborSegment()
          _x = val2
          start = end
          end += 48
          (_x.self_id, _x.other_id, _x.self_start_s, _x.self_end_s, _x.other_start_s, _x.other_end_s,) = _get_struct_2Q4d().unpack(str[start:end])
          val1.right_reverse_neighbors.append(val2)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.overlaps = []
        for i in range(0, length):
          val2 = rospy_message_converter.msg.Overlap()
          _x = val2
          start = end
          end += 36
          (_x.self_id, _x.other_id, _x.type, _x.start_s, _x.end_s,) = _get_struct_2Qi2d().unpack(str[start:end])
          val1.overlaps.append(val2)
        _x = val1
        start = end
        end += 28
        (_x.lane_group_id, _x.connection_type, _x.sequence_id, _x.lane_type, _x.length,) = _get_struct_Q3id().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sd'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        val1.OBSOLETE_width = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sd'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        val1.width = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sd'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        val1.centerline_s = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
        _x = val1
        start = end
        end += 17
        (_x.lane_status, _x.lane_used_in_both_directions, _x.tile_id, _x.advisory_speed_limit,) = _get_struct_IBId().unpack(str[start:end])
        val1.lane_used_in_both_directions = bool(val1.lane_used_in_both_directions)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.downgrade_lane_segments = []
        for i in range(0, length):
          val2 = rospy_message_converter.msg.DowngradeLaneSegment()
          _x = val2
          start = end
          end += 32
          (_x.ad_mode_type, _x.start_s, _x.end_s, _x.info_value, _x.dynamic_info, _x.road_scenario_type,) = _get_struct_i2d3i().unpack(str[start:end])
          val1.downgrade_lane_segments.append(val2)
        _x = val1
        start = end
        end += 16
        (_x.electronic_eye_speed_limit, _x.max_lane_group_speed_limit,) = _get_struct_2d().unpack(str[start:end])
        self.lane_list.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.lane_boundary_list = []
      for i in range(0, length):
        val1 = rospy_message_converter.msg.HdLaneBoundary()
        start = end
        end += 8
        (val1.id,) = _get_struct_Q().unpack(str[start:end])
        _v61 = val1.central_line
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sd'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        _v61.x = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sd'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        _v61.y = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sd'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        _v61.z = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%si'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        val1.colors = numpy.frombuffer(str[start:end], dtype=numpy.int32, count=length)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%si'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        val1.types = numpy.frombuffer(str[start:end], dtype=numpy.int32, count=length)
        _x = val1
        start = end
        end += 20
        (_x.left_lane_id, _x.right_lane_id, _x.sequence_id,) = _get_struct_2Qi().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sQ'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        val1.predecessor_lane_boundary_ids = numpy.frombuffer(str[start:end], dtype=numpy.uint64, count=length)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sQ'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        val1.successor_lane_boundary_ids = numpy.frombuffer(str[start:end], dtype=numpy.uint64, count=length)
        start = end
        end += 4
        (val1.lane_separate,) = _get_struct_I().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.feature_points = []
        for i in range(0, length):
          val2 = rospy_message_converter.msg.FeaturePoint()
          _x = val2
          start = end
          end += 8
          (_x.type, _x.point_index,) = _get_struct_2i().unpack(str[start:end])
          val1.feature_points.append(val2)
        self.lane_boundary_list.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.link_list = []
      for i in range(0, length):
        val1 = rospy_message_converter.msg.HdLinkInfo()
        _x = val1
        start = end
        end += 28
        (_x.id, _x.length, _x.average_speed, _x.priority_road_class, _x.travel_direction,) = _get_struct_QdI2i().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%si'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        val1.form_way = numpy.frombuffer(str[start:end], dtype=numpy.int32, count=length)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sQ'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        val1.predecessor_link_ids = numpy.frombuffer(str[start:end], dtype=numpy.uint64, count=length)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sQ'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        val1.successor_link_ids = numpy.frombuffer(str[start:end], dtype=numpy.uint64, count=length)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sQ'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        val1.lane_ids = numpy.frombuffer(str[start:end], dtype=numpy.uint64, count=length)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sQ'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        val1.lane_group_ids = numpy.frombuffer(str[start:end], dtype=numpy.uint64, count=length)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sQ'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        val1.road_geo_line_ids = numpy.frombuffer(str[start:end], dtype=numpy.uint64, count=length)
        start = end
        end += 1
        (val1.complex_intersection,) = _get_struct_B().unpack(str[start:end])
        val1.complex_intersection = bool(val1.complex_intersection)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.feature_points = []
        for i in range(0, length):
          val2 = rospy_message_converter.msg.LinkFeaturePoint()
          _x = val2
          start = end
          end += 8
          (_x.type, _x.offset,) = _get_struct_if().unpack(str[start:end])
          _v62 = val2.position
          _x = _v62
          start = end
          end += 24
          (_x.x, _x.y, _x.z,) = _get_struct_3d().unpack(str[start:end])
          start = end
          end += 8
          (val2.link_id,) = _get_struct_Q().unpack(str[start:end])
          val1.feature_points.append(val2)
        self.link_list.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.crosswalk_list = []
      for i in range(0, length):
        val1 = rospy_message_converter.msg.HdCrosswalk()
        start = end
        end += 8
        (val1.id,) = _get_struct_Q().unpack(str[start:end])
        _v63 = val1.surface
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sd'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        _v63.x = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sd'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        _v63.y = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sd'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        _v63.z = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sQ'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        val1.lane_id = numpy.frombuffer(str[start:end], dtype=numpy.uint64, count=length)
        self.crosswalk_list.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.junction_list = []
      for i in range(0, length):
        val1 = rospy_message_converter.msg.HdJunction()
        start = end
        end += 8
        (val1.id,) = _get_struct_Q().unpack(str[start:end])
        _v64 = val1.surface
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sd'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        _v64.x = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sd'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        _v64.y = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sd'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        _v64.z = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sQ'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        val1.lane_id = numpy.frombuffer(str[start:end], dtype=numpy.uint64, count=length)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sQ'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        val1.crosswalk_id = numpy.frombuffer(str[start:end], dtype=numpy.uint64, count=length)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sQ'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        val1.stop_line_id = numpy.frombuffer(str[start:end], dtype=numpy.uint64, count=length)
        self.junction_list.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.pole_list = []
      for i in range(0, length):
        val1 = rospy_message_converter.msg.HdPole()
        start = end
        end += 8
        (val1.id,) = _get_struct_Q().unpack(str[start:end])
        _v65 = val1.ground_point
        _x = _v65
        start = end
        end += 24
        (_x.x, _x.y, _x.z,) = _get_struct_3d().unpack(str[start:end])
        _v66 = val1.top_point
        _x = _v66
        start = end
        end += 24
        (_x.x, _x.y, _x.z,) = _get_struct_3d().unpack(str[start:end])
        self.pole_list.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.traffic_light_list = []
      for i in range(0, length):
        val1 = rospy_message_converter.msg.HdTrafficLight()
        start = end
        end += 8
        (val1.id,) = _get_struct_Q().unpack(str[start:end])
        _v67 = val1.surface
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sd'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        _v67.x = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sd'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        _v67.y = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sd'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        _v67.z = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
        _x = val1
        start = end
        end += 12
        (_x.heading, _x.traffic_light_type,) = _get_struct_di().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sQ'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        val1.lane_id = numpy.frombuffer(str[start:end], dtype=numpy.uint64, count=length)
        start = end
        end += 4
        (val1.box_type,) = _get_struct_i().unpack(str[start:end])
        _v68 = val1.center
        _x = _v68
        start = end
        end += 24
        (_x.x, _x.y, _x.z,) = _get_struct_3d().unpack(str[start:end])
        self.traffic_light_list.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.traffic_sign_list = []
      for i in range(0, length):
        val1 = rospy_message_converter.msg.HdTrafficSign()
        start = end
        end += 8
        (val1.id,) = _get_struct_Q().unpack(str[start:end])
        _v69 = val1.surface
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sd'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        _v69.x = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sd'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        _v69.y = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sd'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        _v69.z = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
        _x = val1
        start = end
        end += 12
        (_x.type, _x.heading,) = _get_struct_id().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sQ'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        val1.lane_id = numpy.frombuffer(str[start:end], dtype=numpy.uint64, count=length)
        _v70 = val1.center
        _x = _v70
        start = end
        end += 24
        (_x.x, _x.y, _x.z,) = _get_struct_3d().unpack(str[start:end])
        self.traffic_sign_list.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.road_geo_line_list = []
      for i in range(0, length):
        val1 = rospy_message_converter.msg.HdRoadGeoLine()
        _x = val1
        start = end
        end += 16
        (_x.id, _x.link_id,) = _get_struct_2Q().unpack(str[start:end])
        _v71 = val1.shape_point
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sd'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        _v71.x = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sd'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        _v71.y = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sd'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        _v71.z = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sd'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        val1.curvature = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sd'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        val1.slope = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sd'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        val1.heading = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sd'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        val1.shape_point_offset = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
        self.road_geo_line_list.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.stop_line_list = []
      for i in range(0, length):
        val1 = rospy_message_converter.msg.HdStopLine()
        start = end
        end += 8
        (val1.id,) = _get_struct_Q().unpack(str[start:end])
        _v72 = val1.polyline
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sd'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        _v72.x = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sd'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        _v72.y = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sd'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        _v72.z = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sQ'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        val1.traffic_light_id = numpy.frombuffer(str[start:end], dtype=numpy.uint64, count=length)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sQ'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        val1.traffic_sign_id = numpy.frombuffer(str[start:end], dtype=numpy.uint64, count=length)
        self.stop_line_list.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.map_tile_hash = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.map_tile_hash = str[start:end]
      start = end
      end += 4
      (self.map_version,) = _get_struct_i().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.dynamic_map_info_counter = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.dynamic_map_info_counter = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.parking_area_list = []
      for i in range(0, length):
        val1 = rospy_message_converter.msg.HdParkingArea()
        start = end
        end += 8
        (val1.id,) = _get_struct_Q().unpack(str[start:end])
        _v73 = val1.surface
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sd'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        _v73.x = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sd'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        _v73.y = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sd'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        _v73.z = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
        _x = val1
        start = end
        end += 16
        (_x.marking_type, _x.parking_type, _x.heading,) = _get_struct_2id().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.link_feature_points = []
        for i in range(0, length):
          val2 = rospy_message_converter.msg.LinkFeaturePoint()
          _x = val2
          start = end
          end += 8
          (_x.type, _x.offset,) = _get_struct_if().unpack(str[start:end])
          _v74 = val2.position
          _x = _v74
          start = end
          end += 24
          (_x.x, _x.y, _x.z,) = _get_struct_3d().unpack(str[start:end])
          start = end
          end += 8
          (val2.link_id,) = _get_struct_Q().unpack(str[start:end])
          val1.link_feature_points.append(val2)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sQ'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        val1.link_ids = numpy.frombuffer(str[start:end], dtype=numpy.uint64, count=length)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sQ'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        val1.lane_ids = numpy.frombuffer(str[start:end], dtype=numpy.uint64, count=length)
        self.parking_area_list.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.waiting_zone_list = []
      for i in range(0, length):
        val1 = rospy_message_converter.msg.HdWaitingZone()
        start = end
        end += 8
        (val1.id,) = _get_struct_Q().unpack(str[start:end])
        _v75 = val1.surface
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sd'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        _v75.x = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sd'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        _v75.y = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sd'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        _v75.z = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.link_feature_points = []
        for i in range(0, length):
          val2 = rospy_message_converter.msg.LinkFeaturePoint()
          _x = val2
          start = end
          end += 8
          (_x.type, _x.offset,) = _get_struct_if().unpack(str[start:end])
          _v76 = val2.position
          _x = _v76
          start = end
          end += 24
          (_x.x, _x.y, _x.z,) = _get_struct_3d().unpack(str[start:end])
          start = end
          end += 8
          (val2.link_id,) = _get_struct_Q().unpack(str[start:end])
          val1.link_feature_points.append(val2)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sQ'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        val1.lane_ids = numpy.frombuffer(str[start:end], dtype=numpy.uint64, count=length)
        self.waiting_zone_list.append(val1)
      start = end
      end += 8
      (self.publish_ptp_ts,) = _get_struct_Q().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.publisher_id = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.publisher_id = str[start:end]
      _x = self
      start = end
      end += 16
      (_x.counter, _x.publish_ts,) = _get_struct_2Q().unpack(str[start:end])
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill

_struct_I = genpy.struct_I
def _get_struct_I():
    global _struct_I
    return _struct_I
_struct_2Q = None
def _get_struct_2Q():
    global _struct_2Q
    if _struct_2Q is None:
        _struct_2Q = struct.Struct("<2Q")
    return _struct_2Q
_struct_2Q4d = None
def _get_struct_2Q4d():
    global _struct_2Q4d
    if _struct_2Q4d is None:
        _struct_2Q4d = struct.Struct("<2Q4d")
    return _struct_2Q4d
_struct_2Qi = None
def _get_struct_2Qi():
    global _struct_2Qi
    if _struct_2Qi is None:
        _struct_2Qi = struct.Struct("<2Qi")
    return _struct_2Qi
_struct_2Qi2d = None
def _get_struct_2Qi2d():
    global _struct_2Qi2d
    if _struct_2Qi2d is None:
        _struct_2Qi2d = struct.Struct("<2Qi2d")
    return _struct_2Qi2d
_struct_2d = None
def _get_struct_2d():
    global _struct_2d
    if _struct_2d is None:
        _struct_2d = struct.Struct("<2d")
    return _struct_2d
_struct_2i = None
def _get_struct_2i():
    global _struct_2i
    if _struct_2i is None:
        _struct_2i = struct.Struct("<2i")
    return _struct_2i
_struct_2id = None
def _get_struct_2id():
    global _struct_2id
    if _struct_2id is None:
        _struct_2id = struct.Struct("<2id")
    return _struct_2id
_struct_3d = None
def _get_struct_3d():
    global _struct_3d
    if _struct_3d is None:
        _struct_3d = struct.Struct("<3d")
    return _struct_3d
_struct_B = None
def _get_struct_B():
    global _struct_B
    if _struct_B is None:
        _struct_B = struct.Struct("<B")
    return _struct_B
_struct_IBId = None
def _get_struct_IBId():
    global _struct_IBId
    if _struct_IBId is None:
        _struct_IBId = struct.Struct("<IBId")
    return _struct_IBId
_struct_Q = None
def _get_struct_Q():
    global _struct_Q
    if _struct_Q is None:
        _struct_Q = struct.Struct("<Q")
    return _struct_Q
_struct_Q3id = None
def _get_struct_Q3id():
    global _struct_Q3id
    if _struct_Q3id is None:
        _struct_Q3id = struct.Struct("<Q3id")
    return _struct_Q3id
_struct_QdI2i = None
def _get_struct_QdI2i():
    global _struct_QdI2i
    if _struct_QdI2i is None:
        _struct_QdI2i = struct.Struct("<QdI2i")
    return _struct_QdI2i
_struct_Qi = None
def _get_struct_Qi():
    global _struct_Qi
    if _struct_Qi is None:
        _struct_Qi = struct.Struct("<Qi")
    return _struct_Qi
_struct_d = None
def _get_struct_d():
    global _struct_d
    if _struct_d is None:
        _struct_d = struct.Struct("<d")
    return _struct_d
_struct_di = None
def _get_struct_di():
    global _struct_di
    if _struct_di is None:
        _struct_di = struct.Struct("<di")
    return _struct_di
_struct_i = None
def _get_struct_i():
    global _struct_i
    if _struct_i is None:
        _struct_i = struct.Struct("<i")
    return _struct_i
_struct_i2d3i = None
def _get_struct_i2d3i():
    global _struct_i2d3i
    if _struct_i2d3i is None:
        _struct_i2d3i = struct.Struct("<i2d3i")
    return _struct_i2d3i
_struct_id = None
def _get_struct_id():
    global _struct_id
    if _struct_id is None:
        _struct_id = struct.Struct("<id")
    return _struct_id
_struct_if = None
def _get_struct_if():
    global _struct_if
    if _struct_if is None:
        _struct_if = struct.Struct("<if")
    return _struct_if
