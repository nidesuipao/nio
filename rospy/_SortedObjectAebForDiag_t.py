# This Python file uses the following encoding: utf-8
"""autogenerated by genpy from rospy_message_converter/SortedObjectAebForDiag_t.msg. Do not edit."""
import codecs
import sys
python3 = True if sys.hexversion > 0x03000000 else False
import genpy
import struct


class SortedObjectAebForDiag_t(genpy.Message):
  _md5sum = "3a66d6be9c07f3e052ca7d20a5e6a2d9"
  _type = "rospy_message_converter/SortedObjectAebForDiag_t"
  _has_header = False  # flag to mark the presence of a Header object
  _full_text = """uint32 id
uint32 type
bool stillExist
float32 marginsLatInPathCurr
float32 marginsLatInPathPred
float32 marginsLgtForIntv
float32 marginsLatForIntv
float32 offSetLatForPrimaryTarget
uint32 loopIndex
float32[] predCenPosnLgt
float32[] predCenPosnLat
float32[] predCosHeading
float32[] predSinHeading
uint32 objMovingDirection
bool linearOrCurvedPredValid
bool curvedMotion
bool stationary
bool movingOncoming
float32 aNegLgtRqrdForCtrl
float32 crvtReqdLe
float32 crvtRateReqdLe
float32 crvtReqdRi
float32 crvtRateReqdRi
bool[] opCond1
bool[] opCond2
bool[] opCond3
bool[] opCond4
float32 objVx
float32 objVy
float32 objAx
float32 objAy
uint32 ttrIndex
uint32 ttpIndex
uint32[] edgeIndex
uint32[] maxCLeIdx
uint32[] minCRiIdx
uint32[] taLateralThreatMatrixOpl
float32[] objLongPosnRelToHost
float32[] objLatPosnRelToHost
float32[] objLongSpanRelToHost
float32[] objLatSpanRelToHost
float32[] hostLongPosnRelToObj
float32[] hostLatPosnRelToObj
float32[] hostLongSpanRelToObj
float32[] hostLatSpanRelToObj
bool[] isValidUpdateForLongThreat
float32 aNegLgtJerkReqdForIntv
float32 objHeading
float32 aLgtPreCalc1
uint32 mostInPathIndex
float32 posnLatRel
float32 projectedWidth
float32[] xEdges
float32[] yEdges
float32[] egoMotionTime
float32[] egoXc
float32 ttp
uint32 fusionSource
uint32 brkIndex
float32[] objLongDistNear
bool[] inFwdPathResampled
float32[] timeVecResampled
float32 ttheta_left
float32 ttheta_right
float32 tZero
float32 tObjStop
bool flgJustPass
bool flgObjNotInPathAtTZero
bool TargetOnComingDuringHostTurn
bool TargetLowCurvature
bool LessHeadOnAtCollision
float32 headingAtHostStartOfTheTurn
float32 objTrjCurvature
float32 predObjHeadingAtTtc
float32 predHostHeadingChangeAtTtc
float32 predRelativeHeadingAtTtc
bool isGenMovingOnComingScenario
bool hostDrvStraight
bool hostIsTurning
bool targetIsTurning
bool relativePosnOkDuringHostTurn
bool isLtapTargetTurn
bool isLtapHostTurn
bool useStrictInPath
bool inPathCurPosn
float32 availStopdist
float32 rawBrkJerk
float32 rawBrkALgt
float32 impctPosnWithOutIntv
float32 impctPosnWithIntv
"""
  __slots__ = ['id','type','stillExist','marginsLatInPathCurr','marginsLatInPathPred','marginsLgtForIntv','marginsLatForIntv','offSetLatForPrimaryTarget','loopIndex','predCenPosnLgt','predCenPosnLat','predCosHeading','predSinHeading','objMovingDirection','linearOrCurvedPredValid','curvedMotion','stationary','movingOncoming','aNegLgtRqrdForCtrl','crvtReqdLe','crvtRateReqdLe','crvtReqdRi','crvtRateReqdRi','opCond1','opCond2','opCond3','opCond4','objVx','objVy','objAx','objAy','ttrIndex','ttpIndex','edgeIndex','maxCLeIdx','minCRiIdx','taLateralThreatMatrixOpl','objLongPosnRelToHost','objLatPosnRelToHost','objLongSpanRelToHost','objLatSpanRelToHost','hostLongPosnRelToObj','hostLatPosnRelToObj','hostLongSpanRelToObj','hostLatSpanRelToObj','isValidUpdateForLongThreat','aNegLgtJerkReqdForIntv','objHeading','aLgtPreCalc1','mostInPathIndex','posnLatRel','projectedWidth','xEdges','yEdges','egoMotionTime','egoXc','ttp','fusionSource','brkIndex','objLongDistNear','inFwdPathResampled','timeVecResampled','ttheta_left','ttheta_right','tZero','tObjStop','flgJustPass','flgObjNotInPathAtTZero','TargetOnComingDuringHostTurn','TargetLowCurvature','LessHeadOnAtCollision','headingAtHostStartOfTheTurn','objTrjCurvature','predObjHeadingAtTtc','predHostHeadingChangeAtTtc','predRelativeHeadingAtTtc','isGenMovingOnComingScenario','hostDrvStraight','hostIsTurning','targetIsTurning','relativePosnOkDuringHostTurn','isLtapTargetTurn','isLtapHostTurn','useStrictInPath','inPathCurPosn','availStopdist','rawBrkJerk','rawBrkALgt','impctPosnWithOutIntv','impctPosnWithIntv']
  _slot_types = ['uint32','uint32','bool','float32','float32','float32','float32','float32','uint32','float32[]','float32[]','float32[]','float32[]','uint32','bool','bool','bool','bool','float32','float32','float32','float32','float32','bool[]','bool[]','bool[]','bool[]','float32','float32','float32','float32','uint32','uint32','uint32[]','uint32[]','uint32[]','uint32[]','float32[]','float32[]','float32[]','float32[]','float32[]','float32[]','float32[]','float32[]','bool[]','float32','float32','float32','uint32','float32','float32','float32[]','float32[]','float32[]','float32[]','float32','uint32','uint32','float32[]','bool[]','float32[]','float32','float32','float32','float32','bool','bool','bool','bool','bool','float32','float32','float32','float32','float32','bool','bool','bool','bool','bool','bool','bool','bool','bool','float32','float32','float32','float32','float32']

  def __init__(self, *args, **kwds):
    """
    Constructor. Any message fields that are implicitly/explicitly
    set to None will be assigned a default value. The recommend
    use is keyword arguments as this is more robust to future message
    changes.  You cannot mix in-order arguments and keyword arguments.

    The available fields are:
       id,type,stillExist,marginsLatInPathCurr,marginsLatInPathPred,marginsLgtForIntv,marginsLatForIntv,offSetLatForPrimaryTarget,loopIndex,predCenPosnLgt,predCenPosnLat,predCosHeading,predSinHeading,objMovingDirection,linearOrCurvedPredValid,curvedMotion,stationary,movingOncoming,aNegLgtRqrdForCtrl,crvtReqdLe,crvtRateReqdLe,crvtReqdRi,crvtRateReqdRi,opCond1,opCond2,opCond3,opCond4,objVx,objVy,objAx,objAy,ttrIndex,ttpIndex,edgeIndex,maxCLeIdx,minCRiIdx,taLateralThreatMatrixOpl,objLongPosnRelToHost,objLatPosnRelToHost,objLongSpanRelToHost,objLatSpanRelToHost,hostLongPosnRelToObj,hostLatPosnRelToObj,hostLongSpanRelToObj,hostLatSpanRelToObj,isValidUpdateForLongThreat,aNegLgtJerkReqdForIntv,objHeading,aLgtPreCalc1,mostInPathIndex,posnLatRel,projectedWidth,xEdges,yEdges,egoMotionTime,egoXc,ttp,fusionSource,brkIndex,objLongDistNear,inFwdPathResampled,timeVecResampled,ttheta_left,ttheta_right,tZero,tObjStop,flgJustPass,flgObjNotInPathAtTZero,TargetOnComingDuringHostTurn,TargetLowCurvature,LessHeadOnAtCollision,headingAtHostStartOfTheTurn,objTrjCurvature,predObjHeadingAtTtc,predHostHeadingChangeAtTtc,predRelativeHeadingAtTtc,isGenMovingOnComingScenario,hostDrvStraight,hostIsTurning,targetIsTurning,relativePosnOkDuringHostTurn,isLtapTargetTurn,isLtapHostTurn,useStrictInPath,inPathCurPosn,availStopdist,rawBrkJerk,rawBrkALgt,impctPosnWithOutIntv,impctPosnWithIntv

    :param args: complete set of field values, in .msg order
    :param kwds: use keyword arguments corresponding to message field names
    to set specific fields.
    """
    if args or kwds:
      super(SortedObjectAebForDiag_t, self).__init__(*args, **kwds)
      # message fields cannot be None, assign default values for those that are
      if self.id is None:
        self.id = 0
      if self.type is None:
        self.type = 0
      if self.stillExist is None:
        self.stillExist = False
      if self.marginsLatInPathCurr is None:
        self.marginsLatInPathCurr = 0.
      if self.marginsLatInPathPred is None:
        self.marginsLatInPathPred = 0.
      if self.marginsLgtForIntv is None:
        self.marginsLgtForIntv = 0.
      if self.marginsLatForIntv is None:
        self.marginsLatForIntv = 0.
      if self.offSetLatForPrimaryTarget is None:
        self.offSetLatForPrimaryTarget = 0.
      if self.loopIndex is None:
        self.loopIndex = 0
      if self.predCenPosnLgt is None:
        self.predCenPosnLgt = []
      if self.predCenPosnLat is None:
        self.predCenPosnLat = []
      if self.predCosHeading is None:
        self.predCosHeading = []
      if self.predSinHeading is None:
        self.predSinHeading = []
      if self.objMovingDirection is None:
        self.objMovingDirection = 0
      if self.linearOrCurvedPredValid is None:
        self.linearOrCurvedPredValid = False
      if self.curvedMotion is None:
        self.curvedMotion = False
      if self.stationary is None:
        self.stationary = False
      if self.movingOncoming is None:
        self.movingOncoming = False
      if self.aNegLgtRqrdForCtrl is None:
        self.aNegLgtRqrdForCtrl = 0.
      if self.crvtReqdLe is None:
        self.crvtReqdLe = 0.
      if self.crvtRateReqdLe is None:
        self.crvtRateReqdLe = 0.
      if self.crvtReqdRi is None:
        self.crvtReqdRi = 0.
      if self.crvtRateReqdRi is None:
        self.crvtRateReqdRi = 0.
      if self.opCond1 is None:
        self.opCond1 = []
      if self.opCond2 is None:
        self.opCond2 = []
      if self.opCond3 is None:
        self.opCond3 = []
      if self.opCond4 is None:
        self.opCond4 = []
      if self.objVx is None:
        self.objVx = 0.
      if self.objVy is None:
        self.objVy = 0.
      if self.objAx is None:
        self.objAx = 0.
      if self.objAy is None:
        self.objAy = 0.
      if self.ttrIndex is None:
        self.ttrIndex = 0
      if self.ttpIndex is None:
        self.ttpIndex = 0
      if self.edgeIndex is None:
        self.edgeIndex = []
      if self.maxCLeIdx is None:
        self.maxCLeIdx = []
      if self.minCRiIdx is None:
        self.minCRiIdx = []
      if self.taLateralThreatMatrixOpl is None:
        self.taLateralThreatMatrixOpl = []
      if self.objLongPosnRelToHost is None:
        self.objLongPosnRelToHost = []
      if self.objLatPosnRelToHost is None:
        self.objLatPosnRelToHost = []
      if self.objLongSpanRelToHost is None:
        self.objLongSpanRelToHost = []
      if self.objLatSpanRelToHost is None:
        self.objLatSpanRelToHost = []
      if self.hostLongPosnRelToObj is None:
        self.hostLongPosnRelToObj = []
      if self.hostLatPosnRelToObj is None:
        self.hostLatPosnRelToObj = []
      if self.hostLongSpanRelToObj is None:
        self.hostLongSpanRelToObj = []
      if self.hostLatSpanRelToObj is None:
        self.hostLatSpanRelToObj = []
      if self.isValidUpdateForLongThreat is None:
        self.isValidUpdateForLongThreat = []
      if self.aNegLgtJerkReqdForIntv is None:
        self.aNegLgtJerkReqdForIntv = 0.
      if self.objHeading is None:
        self.objHeading = 0.
      if self.aLgtPreCalc1 is None:
        self.aLgtPreCalc1 = 0.
      if self.mostInPathIndex is None:
        self.mostInPathIndex = 0
      if self.posnLatRel is None:
        self.posnLatRel = 0.
      if self.projectedWidth is None:
        self.projectedWidth = 0.
      if self.xEdges is None:
        self.xEdges = []
      if self.yEdges is None:
        self.yEdges = []
      if self.egoMotionTime is None:
        self.egoMotionTime = []
      if self.egoXc is None:
        self.egoXc = []
      if self.ttp is None:
        self.ttp = 0.
      if self.fusionSource is None:
        self.fusionSource = 0
      if self.brkIndex is None:
        self.brkIndex = 0
      if self.objLongDistNear is None:
        self.objLongDistNear = []
      if self.inFwdPathResampled is None:
        self.inFwdPathResampled = []
      if self.timeVecResampled is None:
        self.timeVecResampled = []
      if self.ttheta_left is None:
        self.ttheta_left = 0.
      if self.ttheta_right is None:
        self.ttheta_right = 0.
      if self.tZero is None:
        self.tZero = 0.
      if self.tObjStop is None:
        self.tObjStop = 0.
      if self.flgJustPass is None:
        self.flgJustPass = False
      if self.flgObjNotInPathAtTZero is None:
        self.flgObjNotInPathAtTZero = False
      if self.TargetOnComingDuringHostTurn is None:
        self.TargetOnComingDuringHostTurn = False
      if self.TargetLowCurvature is None:
        self.TargetLowCurvature = False
      if self.LessHeadOnAtCollision is None:
        self.LessHeadOnAtCollision = False
      if self.headingAtHostStartOfTheTurn is None:
        self.headingAtHostStartOfTheTurn = 0.
      if self.objTrjCurvature is None:
        self.objTrjCurvature = 0.
      if self.predObjHeadingAtTtc is None:
        self.predObjHeadingAtTtc = 0.
      if self.predHostHeadingChangeAtTtc is None:
        self.predHostHeadingChangeAtTtc = 0.
      if self.predRelativeHeadingAtTtc is None:
        self.predRelativeHeadingAtTtc = 0.
      if self.isGenMovingOnComingScenario is None:
        self.isGenMovingOnComingScenario = False
      if self.hostDrvStraight is None:
        self.hostDrvStraight = False
      if self.hostIsTurning is None:
        self.hostIsTurning = False
      if self.targetIsTurning is None:
        self.targetIsTurning = False
      if self.relativePosnOkDuringHostTurn is None:
        self.relativePosnOkDuringHostTurn = False
      if self.isLtapTargetTurn is None:
        self.isLtapTargetTurn = False
      if self.isLtapHostTurn is None:
        self.isLtapHostTurn = False
      if self.useStrictInPath is None:
        self.useStrictInPath = False
      if self.inPathCurPosn is None:
        self.inPathCurPosn = False
      if self.availStopdist is None:
        self.availStopdist = 0.
      if self.rawBrkJerk is None:
        self.rawBrkJerk = 0.
      if self.rawBrkALgt is None:
        self.rawBrkALgt = 0.
      if self.impctPosnWithOutIntv is None:
        self.impctPosnWithOutIntv = 0.
      if self.impctPosnWithIntv is None:
        self.impctPosnWithIntv = 0.
    else:
      self.id = 0
      self.type = 0
      self.stillExist = False
      self.marginsLatInPathCurr = 0.
      self.marginsLatInPathPred = 0.
      self.marginsLgtForIntv = 0.
      self.marginsLatForIntv = 0.
      self.offSetLatForPrimaryTarget = 0.
      self.loopIndex = 0
      self.predCenPosnLgt = []
      self.predCenPosnLat = []
      self.predCosHeading = []
      self.predSinHeading = []
      self.objMovingDirection = 0
      self.linearOrCurvedPredValid = False
      self.curvedMotion = False
      self.stationary = False
      self.movingOncoming = False
      self.aNegLgtRqrdForCtrl = 0.
      self.crvtReqdLe = 0.
      self.crvtRateReqdLe = 0.
      self.crvtReqdRi = 0.
      self.crvtRateReqdRi = 0.
      self.opCond1 = []
      self.opCond2 = []
      self.opCond3 = []
      self.opCond4 = []
      self.objVx = 0.
      self.objVy = 0.
      self.objAx = 0.
      self.objAy = 0.
      self.ttrIndex = 0
      self.ttpIndex = 0
      self.edgeIndex = []
      self.maxCLeIdx = []
      self.minCRiIdx = []
      self.taLateralThreatMatrixOpl = []
      self.objLongPosnRelToHost = []
      self.objLatPosnRelToHost = []
      self.objLongSpanRelToHost = []
      self.objLatSpanRelToHost = []
      self.hostLongPosnRelToObj = []
      self.hostLatPosnRelToObj = []
      self.hostLongSpanRelToObj = []
      self.hostLatSpanRelToObj = []
      self.isValidUpdateForLongThreat = []
      self.aNegLgtJerkReqdForIntv = 0.
      self.objHeading = 0.
      self.aLgtPreCalc1 = 0.
      self.mostInPathIndex = 0
      self.posnLatRel = 0.
      self.projectedWidth = 0.
      self.xEdges = []
      self.yEdges = []
      self.egoMotionTime = []
      self.egoXc = []
      self.ttp = 0.
      self.fusionSource = 0
      self.brkIndex = 0
      self.objLongDistNear = []
      self.inFwdPathResampled = []
      self.timeVecResampled = []
      self.ttheta_left = 0.
      self.ttheta_right = 0.
      self.tZero = 0.
      self.tObjStop = 0.
      self.flgJustPass = False
      self.flgObjNotInPathAtTZero = False
      self.TargetOnComingDuringHostTurn = False
      self.TargetLowCurvature = False
      self.LessHeadOnAtCollision = False
      self.headingAtHostStartOfTheTurn = 0.
      self.objTrjCurvature = 0.
      self.predObjHeadingAtTtc = 0.
      self.predHostHeadingChangeAtTtc = 0.
      self.predRelativeHeadingAtTtc = 0.
      self.isGenMovingOnComingScenario = False
      self.hostDrvStraight = False
      self.hostIsTurning = False
      self.targetIsTurning = False
      self.relativePosnOkDuringHostTurn = False
      self.isLtapTargetTurn = False
      self.isLtapHostTurn = False
      self.useStrictInPath = False
      self.inPathCurPosn = False
      self.availStopdist = 0.
      self.rawBrkJerk = 0.
      self.rawBrkALgt = 0.
      self.impctPosnWithOutIntv = 0.
      self.impctPosnWithIntv = 0.

  def _get_types(self):
    """
    internal API method
    """
    return self._slot_types

  def serialize(self, buff):
    """
    serialize message into buffer
    :param buff: buffer, ``StringIO``
    """
    try:
      _x = self
      buff.write(_get_struct_2IB5fI().pack(_x.id, _x.type, _x.stillExist, _x.marginsLatInPathCurr, _x.marginsLatInPathPred, _x.marginsLgtForIntv, _x.marginsLatForIntv, _x.offSetLatForPrimaryTarget, _x.loopIndex))
      length = len(self.predCenPosnLgt)
      buff.write(_struct_I.pack(length))
      pattern = '<%sf'%length
      buff.write(struct.Struct(pattern).pack(*self.predCenPosnLgt))
      length = len(self.predCenPosnLat)
      buff.write(_struct_I.pack(length))
      pattern = '<%sf'%length
      buff.write(struct.Struct(pattern).pack(*self.predCenPosnLat))
      length = len(self.predCosHeading)
      buff.write(_struct_I.pack(length))
      pattern = '<%sf'%length
      buff.write(struct.Struct(pattern).pack(*self.predCosHeading))
      length = len(self.predSinHeading)
      buff.write(_struct_I.pack(length))
      pattern = '<%sf'%length
      buff.write(struct.Struct(pattern).pack(*self.predSinHeading))
      _x = self
      buff.write(_get_struct_I4B5f().pack(_x.objMovingDirection, _x.linearOrCurvedPredValid, _x.curvedMotion, _x.stationary, _x.movingOncoming, _x.aNegLgtRqrdForCtrl, _x.crvtReqdLe, _x.crvtRateReqdLe, _x.crvtReqdRi, _x.crvtRateReqdRi))
      length = len(self.opCond1)
      buff.write(_struct_I.pack(length))
      pattern = '<%sB'%length
      buff.write(struct.Struct(pattern).pack(*self.opCond1))
      length = len(self.opCond2)
      buff.write(_struct_I.pack(length))
      pattern = '<%sB'%length
      buff.write(struct.Struct(pattern).pack(*self.opCond2))
      length = len(self.opCond3)
      buff.write(_struct_I.pack(length))
      pattern = '<%sB'%length
      buff.write(struct.Struct(pattern).pack(*self.opCond3))
      length = len(self.opCond4)
      buff.write(_struct_I.pack(length))
      pattern = '<%sB'%length
      buff.write(struct.Struct(pattern).pack(*self.opCond4))
      _x = self
      buff.write(_get_struct_4f2I().pack(_x.objVx, _x.objVy, _x.objAx, _x.objAy, _x.ttrIndex, _x.ttpIndex))
      length = len(self.edgeIndex)
      buff.write(_struct_I.pack(length))
      pattern = '<%sI'%length
      buff.write(struct.Struct(pattern).pack(*self.edgeIndex))
      length = len(self.maxCLeIdx)
      buff.write(_struct_I.pack(length))
      pattern = '<%sI'%length
      buff.write(struct.Struct(pattern).pack(*self.maxCLeIdx))
      length = len(self.minCRiIdx)
      buff.write(_struct_I.pack(length))
      pattern = '<%sI'%length
      buff.write(struct.Struct(pattern).pack(*self.minCRiIdx))
      length = len(self.taLateralThreatMatrixOpl)
      buff.write(_struct_I.pack(length))
      pattern = '<%sI'%length
      buff.write(struct.Struct(pattern).pack(*self.taLateralThreatMatrixOpl))
      length = len(self.objLongPosnRelToHost)
      buff.write(_struct_I.pack(length))
      pattern = '<%sf'%length
      buff.write(struct.Struct(pattern).pack(*self.objLongPosnRelToHost))
      length = len(self.objLatPosnRelToHost)
      buff.write(_struct_I.pack(length))
      pattern = '<%sf'%length
      buff.write(struct.Struct(pattern).pack(*self.objLatPosnRelToHost))
      length = len(self.objLongSpanRelToHost)
      buff.write(_struct_I.pack(length))
      pattern = '<%sf'%length
      buff.write(struct.Struct(pattern).pack(*self.objLongSpanRelToHost))
      length = len(self.objLatSpanRelToHost)
      buff.write(_struct_I.pack(length))
      pattern = '<%sf'%length
      buff.write(struct.Struct(pattern).pack(*self.objLatSpanRelToHost))
      length = len(self.hostLongPosnRelToObj)
      buff.write(_struct_I.pack(length))
      pattern = '<%sf'%length
      buff.write(struct.Struct(pattern).pack(*self.hostLongPosnRelToObj))
      length = len(self.hostLatPosnRelToObj)
      buff.write(_struct_I.pack(length))
      pattern = '<%sf'%length
      buff.write(struct.Struct(pattern).pack(*self.hostLatPosnRelToObj))
      length = len(self.hostLongSpanRelToObj)
      buff.write(_struct_I.pack(length))
      pattern = '<%sf'%length
      buff.write(struct.Struct(pattern).pack(*self.hostLongSpanRelToObj))
      length = len(self.hostLatSpanRelToObj)
      buff.write(_struct_I.pack(length))
      pattern = '<%sf'%length
      buff.write(struct.Struct(pattern).pack(*self.hostLatSpanRelToObj))
      length = len(self.isValidUpdateForLongThreat)
      buff.write(_struct_I.pack(length))
      pattern = '<%sB'%length
      buff.write(struct.Struct(pattern).pack(*self.isValidUpdateForLongThreat))
      _x = self
      buff.write(_get_struct_3fI2f().pack(_x.aNegLgtJerkReqdForIntv, _x.objHeading, _x.aLgtPreCalc1, _x.mostInPathIndex, _x.posnLatRel, _x.projectedWidth))
      length = len(self.xEdges)
      buff.write(_struct_I.pack(length))
      pattern = '<%sf'%length
      buff.write(struct.Struct(pattern).pack(*self.xEdges))
      length = len(self.yEdges)
      buff.write(_struct_I.pack(length))
      pattern = '<%sf'%length
      buff.write(struct.Struct(pattern).pack(*self.yEdges))
      length = len(self.egoMotionTime)
      buff.write(_struct_I.pack(length))
      pattern = '<%sf'%length
      buff.write(struct.Struct(pattern).pack(*self.egoMotionTime))
      length = len(self.egoXc)
      buff.write(_struct_I.pack(length))
      pattern = '<%sf'%length
      buff.write(struct.Struct(pattern).pack(*self.egoXc))
      _x = self
      buff.write(_get_struct_f2I().pack(_x.ttp, _x.fusionSource, _x.brkIndex))
      length = len(self.objLongDistNear)
      buff.write(_struct_I.pack(length))
      pattern = '<%sf'%length
      buff.write(struct.Struct(pattern).pack(*self.objLongDistNear))
      length = len(self.inFwdPathResampled)
      buff.write(_struct_I.pack(length))
      pattern = '<%sB'%length
      buff.write(struct.Struct(pattern).pack(*self.inFwdPathResampled))
      length = len(self.timeVecResampled)
      buff.write(_struct_I.pack(length))
      pattern = '<%sf'%length
      buff.write(struct.Struct(pattern).pack(*self.timeVecResampled))
      _x = self
      buff.write(_get_struct_4f5B5f9B5f().pack(_x.ttheta_left, _x.ttheta_right, _x.tZero, _x.tObjStop, _x.flgJustPass, _x.flgObjNotInPathAtTZero, _x.TargetOnComingDuringHostTurn, _x.TargetLowCurvature, _x.LessHeadOnAtCollision, _x.headingAtHostStartOfTheTurn, _x.objTrjCurvature, _x.predObjHeadingAtTtc, _x.predHostHeadingChangeAtTtc, _x.predRelativeHeadingAtTtc, _x.isGenMovingOnComingScenario, _x.hostDrvStraight, _x.hostIsTurning, _x.targetIsTurning, _x.relativePosnOkDuringHostTurn, _x.isLtapTargetTurn, _x.isLtapHostTurn, _x.useStrictInPath, _x.inPathCurPosn, _x.availStopdist, _x.rawBrkJerk, _x.rawBrkALgt, _x.impctPosnWithOutIntv, _x.impctPosnWithIntv))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize(self, str):
    """
    unpack serialized message in str into this message instance
    :param str: byte array of serialized message, ``str``
    """
    if python3:
      codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      end = 0
      _x = self
      start = end
      end += 33
      (_x.id, _x.type, _x.stillExist, _x.marginsLatInPathCurr, _x.marginsLatInPathPred, _x.marginsLgtForIntv, _x.marginsLatForIntv, _x.offSetLatForPrimaryTarget, _x.loopIndex,) = _get_struct_2IB5fI().unpack(str[start:end])
      self.stillExist = bool(self.stillExist)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sf'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.predCenPosnLgt = s.unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sf'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.predCenPosnLat = s.unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sf'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.predCosHeading = s.unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sf'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.predSinHeading = s.unpack(str[start:end])
      _x = self
      start = end
      end += 28
      (_x.objMovingDirection, _x.linearOrCurvedPredValid, _x.curvedMotion, _x.stationary, _x.movingOncoming, _x.aNegLgtRqrdForCtrl, _x.crvtReqdLe, _x.crvtRateReqdLe, _x.crvtReqdRi, _x.crvtRateReqdRi,) = _get_struct_I4B5f().unpack(str[start:end])
      self.linearOrCurvedPredValid = bool(self.linearOrCurvedPredValid)
      self.curvedMotion = bool(self.curvedMotion)
      self.stationary = bool(self.stationary)
      self.movingOncoming = bool(self.movingOncoming)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sB'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.opCond1 = s.unpack(str[start:end])
      self.opCond1 = list(map(bool, self.opCond1))
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sB'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.opCond2 = s.unpack(str[start:end])
      self.opCond2 = list(map(bool, self.opCond2))
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sB'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.opCond3 = s.unpack(str[start:end])
      self.opCond3 = list(map(bool, self.opCond3))
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sB'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.opCond4 = s.unpack(str[start:end])
      self.opCond4 = list(map(bool, self.opCond4))
      _x = self
      start = end
      end += 24
      (_x.objVx, _x.objVy, _x.objAx, _x.objAy, _x.ttrIndex, _x.ttpIndex,) = _get_struct_4f2I().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sI'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.edgeIndex = s.unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sI'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.maxCLeIdx = s.unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sI'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.minCRiIdx = s.unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sI'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.taLateralThreatMatrixOpl = s.unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sf'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.objLongPosnRelToHost = s.unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sf'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.objLatPosnRelToHost = s.unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sf'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.objLongSpanRelToHost = s.unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sf'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.objLatSpanRelToHost = s.unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sf'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.hostLongPosnRelToObj = s.unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sf'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.hostLatPosnRelToObj = s.unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sf'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.hostLongSpanRelToObj = s.unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sf'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.hostLatSpanRelToObj = s.unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sB'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.isValidUpdateForLongThreat = s.unpack(str[start:end])
      self.isValidUpdateForLongThreat = list(map(bool, self.isValidUpdateForLongThreat))
      _x = self
      start = end
      end += 24
      (_x.aNegLgtJerkReqdForIntv, _x.objHeading, _x.aLgtPreCalc1, _x.mostInPathIndex, _x.posnLatRel, _x.projectedWidth,) = _get_struct_3fI2f().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sf'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.xEdges = s.unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sf'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.yEdges = s.unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sf'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.egoMotionTime = s.unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sf'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.egoXc = s.unpack(str[start:end])
      _x = self
      start = end
      end += 12
      (_x.ttp, _x.fusionSource, _x.brkIndex,) = _get_struct_f2I().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sf'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.objLongDistNear = s.unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sB'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.inFwdPathResampled = s.unpack(str[start:end])
      self.inFwdPathResampled = list(map(bool, self.inFwdPathResampled))
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sf'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.timeVecResampled = s.unpack(str[start:end])
      _x = self
      start = end
      end += 70
      (_x.ttheta_left, _x.ttheta_right, _x.tZero, _x.tObjStop, _x.flgJustPass, _x.flgObjNotInPathAtTZero, _x.TargetOnComingDuringHostTurn, _x.TargetLowCurvature, _x.LessHeadOnAtCollision, _x.headingAtHostStartOfTheTurn, _x.objTrjCurvature, _x.predObjHeadingAtTtc, _x.predHostHeadingChangeAtTtc, _x.predRelativeHeadingAtTtc, _x.isGenMovingOnComingScenario, _x.hostDrvStraight, _x.hostIsTurning, _x.targetIsTurning, _x.relativePosnOkDuringHostTurn, _x.isLtapTargetTurn, _x.isLtapHostTurn, _x.useStrictInPath, _x.inPathCurPosn, _x.availStopdist, _x.rawBrkJerk, _x.rawBrkALgt, _x.impctPosnWithOutIntv, _x.impctPosnWithIntv,) = _get_struct_4f5B5f9B5f().unpack(str[start:end])
      self.flgJustPass = bool(self.flgJustPass)
      self.flgObjNotInPathAtTZero = bool(self.flgObjNotInPathAtTZero)
      self.TargetOnComingDuringHostTurn = bool(self.TargetOnComingDuringHostTurn)
      self.TargetLowCurvature = bool(self.TargetLowCurvature)
      self.LessHeadOnAtCollision = bool(self.LessHeadOnAtCollision)
      self.isGenMovingOnComingScenario = bool(self.isGenMovingOnComingScenario)
      self.hostDrvStraight = bool(self.hostDrvStraight)
      self.hostIsTurning = bool(self.hostIsTurning)
      self.targetIsTurning = bool(self.targetIsTurning)
      self.relativePosnOkDuringHostTurn = bool(self.relativePosnOkDuringHostTurn)
      self.isLtapTargetTurn = bool(self.isLtapTargetTurn)
      self.isLtapHostTurn = bool(self.isLtapHostTurn)
      self.useStrictInPath = bool(self.useStrictInPath)
      self.inPathCurPosn = bool(self.inPathCurPosn)
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill


  def serialize_numpy(self, buff, numpy):
    """
    serialize message with numpy array types into buffer
    :param buff: buffer, ``StringIO``
    :param numpy: numpy python module
    """
    try:
      _x = self
      buff.write(_get_struct_2IB5fI().pack(_x.id, _x.type, _x.stillExist, _x.marginsLatInPathCurr, _x.marginsLatInPathPred, _x.marginsLgtForIntv, _x.marginsLatForIntv, _x.offSetLatForPrimaryTarget, _x.loopIndex))
      length = len(self.predCenPosnLgt)
      buff.write(_struct_I.pack(length))
      pattern = '<%sf'%length
      buff.write(self.predCenPosnLgt.tostring())
      length = len(self.predCenPosnLat)
      buff.write(_struct_I.pack(length))
      pattern = '<%sf'%length
      buff.write(self.predCenPosnLat.tostring())
      length = len(self.predCosHeading)
      buff.write(_struct_I.pack(length))
      pattern = '<%sf'%length
      buff.write(self.predCosHeading.tostring())
      length = len(self.predSinHeading)
      buff.write(_struct_I.pack(length))
      pattern = '<%sf'%length
      buff.write(self.predSinHeading.tostring())
      _x = self
      buff.write(_get_struct_I4B5f().pack(_x.objMovingDirection, _x.linearOrCurvedPredValid, _x.curvedMotion, _x.stationary, _x.movingOncoming, _x.aNegLgtRqrdForCtrl, _x.crvtReqdLe, _x.crvtRateReqdLe, _x.crvtReqdRi, _x.crvtRateReqdRi))
      length = len(self.opCond1)
      buff.write(_struct_I.pack(length))
      pattern = '<%sB'%length
      buff.write(self.opCond1.tostring())
      length = len(self.opCond2)
      buff.write(_struct_I.pack(length))
      pattern = '<%sB'%length
      buff.write(self.opCond2.tostring())
      length = len(self.opCond3)
      buff.write(_struct_I.pack(length))
      pattern = '<%sB'%length
      buff.write(self.opCond3.tostring())
      length = len(self.opCond4)
      buff.write(_struct_I.pack(length))
      pattern = '<%sB'%length
      buff.write(self.opCond4.tostring())
      _x = self
      buff.write(_get_struct_4f2I().pack(_x.objVx, _x.objVy, _x.objAx, _x.objAy, _x.ttrIndex, _x.ttpIndex))
      length = len(self.edgeIndex)
      buff.write(_struct_I.pack(length))
      pattern = '<%sI'%length
      buff.write(self.edgeIndex.tostring())
      length = len(self.maxCLeIdx)
      buff.write(_struct_I.pack(length))
      pattern = '<%sI'%length
      buff.write(self.maxCLeIdx.tostring())
      length = len(self.minCRiIdx)
      buff.write(_struct_I.pack(length))
      pattern = '<%sI'%length
      buff.write(self.minCRiIdx.tostring())
      length = len(self.taLateralThreatMatrixOpl)
      buff.write(_struct_I.pack(length))
      pattern = '<%sI'%length
      buff.write(self.taLateralThreatMatrixOpl.tostring())
      length = len(self.objLongPosnRelToHost)
      buff.write(_struct_I.pack(length))
      pattern = '<%sf'%length
      buff.write(self.objLongPosnRelToHost.tostring())
      length = len(self.objLatPosnRelToHost)
      buff.write(_struct_I.pack(length))
      pattern = '<%sf'%length
      buff.write(self.objLatPosnRelToHost.tostring())
      length = len(self.objLongSpanRelToHost)
      buff.write(_struct_I.pack(length))
      pattern = '<%sf'%length
      buff.write(self.objLongSpanRelToHost.tostring())
      length = len(self.objLatSpanRelToHost)
      buff.write(_struct_I.pack(length))
      pattern = '<%sf'%length
      buff.write(self.objLatSpanRelToHost.tostring())
      length = len(self.hostLongPosnRelToObj)
      buff.write(_struct_I.pack(length))
      pattern = '<%sf'%length
      buff.write(self.hostLongPosnRelToObj.tostring())
      length = len(self.hostLatPosnRelToObj)
      buff.write(_struct_I.pack(length))
      pattern = '<%sf'%length
      buff.write(self.hostLatPosnRelToObj.tostring())
      length = len(self.hostLongSpanRelToObj)
      buff.write(_struct_I.pack(length))
      pattern = '<%sf'%length
      buff.write(self.hostLongSpanRelToObj.tostring())
      length = len(self.hostLatSpanRelToObj)
      buff.write(_struct_I.pack(length))
      pattern = '<%sf'%length
      buff.write(self.hostLatSpanRelToObj.tostring())
      length = len(self.isValidUpdateForLongThreat)
      buff.write(_struct_I.pack(length))
      pattern = '<%sB'%length
      buff.write(self.isValidUpdateForLongThreat.tostring())
      _x = self
      buff.write(_get_struct_3fI2f().pack(_x.aNegLgtJerkReqdForIntv, _x.objHeading, _x.aLgtPreCalc1, _x.mostInPathIndex, _x.posnLatRel, _x.projectedWidth))
      length = len(self.xEdges)
      buff.write(_struct_I.pack(length))
      pattern = '<%sf'%length
      buff.write(self.xEdges.tostring())
      length = len(self.yEdges)
      buff.write(_struct_I.pack(length))
      pattern = '<%sf'%length
      buff.write(self.yEdges.tostring())
      length = len(self.egoMotionTime)
      buff.write(_struct_I.pack(length))
      pattern = '<%sf'%length
      buff.write(self.egoMotionTime.tostring())
      length = len(self.egoXc)
      buff.write(_struct_I.pack(length))
      pattern = '<%sf'%length
      buff.write(self.egoXc.tostring())
      _x = self
      buff.write(_get_struct_f2I().pack(_x.ttp, _x.fusionSource, _x.brkIndex))
      length = len(self.objLongDistNear)
      buff.write(_struct_I.pack(length))
      pattern = '<%sf'%length
      buff.write(self.objLongDistNear.tostring())
      length = len(self.inFwdPathResampled)
      buff.write(_struct_I.pack(length))
      pattern = '<%sB'%length
      buff.write(self.inFwdPathResampled.tostring())
      length = len(self.timeVecResampled)
      buff.write(_struct_I.pack(length))
      pattern = '<%sf'%length
      buff.write(self.timeVecResampled.tostring())
      _x = self
      buff.write(_get_struct_4f5B5f9B5f().pack(_x.ttheta_left, _x.ttheta_right, _x.tZero, _x.tObjStop, _x.flgJustPass, _x.flgObjNotInPathAtTZero, _x.TargetOnComingDuringHostTurn, _x.TargetLowCurvature, _x.LessHeadOnAtCollision, _x.headingAtHostStartOfTheTurn, _x.objTrjCurvature, _x.predObjHeadingAtTtc, _x.predHostHeadingChangeAtTtc, _x.predRelativeHeadingAtTtc, _x.isGenMovingOnComingScenario, _x.hostDrvStraight, _x.hostIsTurning, _x.targetIsTurning, _x.relativePosnOkDuringHostTurn, _x.isLtapTargetTurn, _x.isLtapHostTurn, _x.useStrictInPath, _x.inPathCurPosn, _x.availStopdist, _x.rawBrkJerk, _x.rawBrkALgt, _x.impctPosnWithOutIntv, _x.impctPosnWithIntv))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize_numpy(self, str, numpy):
    """
    unpack serialized message in str into this message instance using numpy for array types
    :param str: byte array of serialized message, ``str``
    :param numpy: numpy python module
    """
    if python3:
      codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      end = 0
      _x = self
      start = end
      end += 33
      (_x.id, _x.type, _x.stillExist, _x.marginsLatInPathCurr, _x.marginsLatInPathPred, _x.marginsLgtForIntv, _x.marginsLatForIntv, _x.offSetLatForPrimaryTarget, _x.loopIndex,) = _get_struct_2IB5fI().unpack(str[start:end])
      self.stillExist = bool(self.stillExist)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sf'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.predCenPosnLgt = numpy.frombuffer(str[start:end], dtype=numpy.float32, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sf'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.predCenPosnLat = numpy.frombuffer(str[start:end], dtype=numpy.float32, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sf'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.predCosHeading = numpy.frombuffer(str[start:end], dtype=numpy.float32, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sf'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.predSinHeading = numpy.frombuffer(str[start:end], dtype=numpy.float32, count=length)
      _x = self
      start = end
      end += 28
      (_x.objMovingDirection, _x.linearOrCurvedPredValid, _x.curvedMotion, _x.stationary, _x.movingOncoming, _x.aNegLgtRqrdForCtrl, _x.crvtReqdLe, _x.crvtRateReqdLe, _x.crvtReqdRi, _x.crvtRateReqdRi,) = _get_struct_I4B5f().unpack(str[start:end])
      self.linearOrCurvedPredValid = bool(self.linearOrCurvedPredValid)
      self.curvedMotion = bool(self.curvedMotion)
      self.stationary = bool(self.stationary)
      self.movingOncoming = bool(self.movingOncoming)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sB'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.opCond1 = numpy.frombuffer(str[start:end], dtype=numpy.bool, count=length)
      self.opCond1 = list(map(bool, self.opCond1))
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sB'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.opCond2 = numpy.frombuffer(str[start:end], dtype=numpy.bool, count=length)
      self.opCond2 = list(map(bool, self.opCond2))
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sB'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.opCond3 = numpy.frombuffer(str[start:end], dtype=numpy.bool, count=length)
      self.opCond3 = list(map(bool, self.opCond3))
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sB'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.opCond4 = numpy.frombuffer(str[start:end], dtype=numpy.bool, count=length)
      self.opCond4 = list(map(bool, self.opCond4))
      _x = self
      start = end
      end += 24
      (_x.objVx, _x.objVy, _x.objAx, _x.objAy, _x.ttrIndex, _x.ttpIndex,) = _get_struct_4f2I().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sI'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.edgeIndex = numpy.frombuffer(str[start:end], dtype=numpy.uint32, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sI'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.maxCLeIdx = numpy.frombuffer(str[start:end], dtype=numpy.uint32, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sI'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.minCRiIdx = numpy.frombuffer(str[start:end], dtype=numpy.uint32, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sI'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.taLateralThreatMatrixOpl = numpy.frombuffer(str[start:end], dtype=numpy.uint32, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sf'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.objLongPosnRelToHost = numpy.frombuffer(str[start:end], dtype=numpy.float32, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sf'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.objLatPosnRelToHost = numpy.frombuffer(str[start:end], dtype=numpy.float32, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sf'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.objLongSpanRelToHost = numpy.frombuffer(str[start:end], dtype=numpy.float32, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sf'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.objLatSpanRelToHost = numpy.frombuffer(str[start:end], dtype=numpy.float32, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sf'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.hostLongPosnRelToObj = numpy.frombuffer(str[start:end], dtype=numpy.float32, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sf'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.hostLatPosnRelToObj = numpy.frombuffer(str[start:end], dtype=numpy.float32, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sf'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.hostLongSpanRelToObj = numpy.frombuffer(str[start:end], dtype=numpy.float32, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sf'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.hostLatSpanRelToObj = numpy.frombuffer(str[start:end], dtype=numpy.float32, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sB'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.isValidUpdateForLongThreat = numpy.frombuffer(str[start:end], dtype=numpy.bool, count=length)
      self.isValidUpdateForLongThreat = list(map(bool, self.isValidUpdateForLongThreat))
      _x = self
      start = end
      end += 24
      (_x.aNegLgtJerkReqdForIntv, _x.objHeading, _x.aLgtPreCalc1, _x.mostInPathIndex, _x.posnLatRel, _x.projectedWidth,) = _get_struct_3fI2f().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sf'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.xEdges = numpy.frombuffer(str[start:end], dtype=numpy.float32, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sf'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.yEdges = numpy.frombuffer(str[start:end], dtype=numpy.float32, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sf'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.egoMotionTime = numpy.frombuffer(str[start:end], dtype=numpy.float32, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sf'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.egoXc = numpy.frombuffer(str[start:end], dtype=numpy.float32, count=length)
      _x = self
      start = end
      end += 12
      (_x.ttp, _x.fusionSource, _x.brkIndex,) = _get_struct_f2I().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sf'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.objLongDistNear = numpy.frombuffer(str[start:end], dtype=numpy.float32, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sB'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.inFwdPathResampled = numpy.frombuffer(str[start:end], dtype=numpy.bool, count=length)
      self.inFwdPathResampled = list(map(bool, self.inFwdPathResampled))
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sf'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.timeVecResampled = numpy.frombuffer(str[start:end], dtype=numpy.float32, count=length)
      _x = self
      start = end
      end += 70
      (_x.ttheta_left, _x.ttheta_right, _x.tZero, _x.tObjStop, _x.flgJustPass, _x.flgObjNotInPathAtTZero, _x.TargetOnComingDuringHostTurn, _x.TargetLowCurvature, _x.LessHeadOnAtCollision, _x.headingAtHostStartOfTheTurn, _x.objTrjCurvature, _x.predObjHeadingAtTtc, _x.predHostHeadingChangeAtTtc, _x.predRelativeHeadingAtTtc, _x.isGenMovingOnComingScenario, _x.hostDrvStraight, _x.hostIsTurning, _x.targetIsTurning, _x.relativePosnOkDuringHostTurn, _x.isLtapTargetTurn, _x.isLtapHostTurn, _x.useStrictInPath, _x.inPathCurPosn, _x.availStopdist, _x.rawBrkJerk, _x.rawBrkALgt, _x.impctPosnWithOutIntv, _x.impctPosnWithIntv,) = _get_struct_4f5B5f9B5f().unpack(str[start:end])
      self.flgJustPass = bool(self.flgJustPass)
      self.flgObjNotInPathAtTZero = bool(self.flgObjNotInPathAtTZero)
      self.TargetOnComingDuringHostTurn = bool(self.TargetOnComingDuringHostTurn)
      self.TargetLowCurvature = bool(self.TargetLowCurvature)
      self.LessHeadOnAtCollision = bool(self.LessHeadOnAtCollision)
      self.isGenMovingOnComingScenario = bool(self.isGenMovingOnComingScenario)
      self.hostDrvStraight = bool(self.hostDrvStraight)
      self.hostIsTurning = bool(self.hostIsTurning)
      self.targetIsTurning = bool(self.targetIsTurning)
      self.relativePosnOkDuringHostTurn = bool(self.relativePosnOkDuringHostTurn)
      self.isLtapTargetTurn = bool(self.isLtapTargetTurn)
      self.isLtapHostTurn = bool(self.isLtapHostTurn)
      self.useStrictInPath = bool(self.useStrictInPath)
      self.inPathCurPosn = bool(self.inPathCurPosn)
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill

_struct_I = genpy.struct_I
def _get_struct_I():
    global _struct_I
    return _struct_I
_struct_2IB5fI = None
def _get_struct_2IB5fI():
    global _struct_2IB5fI
    if _struct_2IB5fI is None:
        _struct_2IB5fI = struct.Struct("<2IB5fI")
    return _struct_2IB5fI
_struct_3fI2f = None
def _get_struct_3fI2f():
    global _struct_3fI2f
    if _struct_3fI2f is None:
        _struct_3fI2f = struct.Struct("<3fI2f")
    return _struct_3fI2f
_struct_4f2I = None
def _get_struct_4f2I():
    global _struct_4f2I
    if _struct_4f2I is None:
        _struct_4f2I = struct.Struct("<4f2I")
    return _struct_4f2I
_struct_4f5B5f9B5f = None
def _get_struct_4f5B5f9B5f():
    global _struct_4f5B5f9B5f
    if _struct_4f5B5f9B5f is None:
        _struct_4f5B5f9B5f = struct.Struct("<4f5B5f9B5f")
    return _struct_4f5B5f9B5f
_struct_I4B5f = None
def _get_struct_I4B5f():
    global _struct_I4B5f
    if _struct_I4B5f is None:
        _struct_I4B5f = struct.Struct("<I4B5f")
    return _struct_I4B5f
_struct_f2I = None
def _get_struct_f2I():
    global _struct_f2I
    if _struct_f2I is None:
        _struct_f2I = struct.Struct("<f2I")
    return _struct_f2I
