# This Python file uses the following encoding: utf-8
"""autogenerated by genpy from rospy_message_converter/PtInfo.msg. Do not edit."""
import codecs
import sys
python3 = True if sys.hexversion > 0x03000000 else False
import genpy
import struct

import rospy_message_converter.msg

class PtInfo(genpy.Message):
  _md5sum = "ed7d62a21c99bd3a0aab1fb8451037ed"
  _type = "rospy_message_converter/PtInfo"
  _has_header = False  # flag to mark the presence of a Header object
  _full_text = """AccrPedalInfo AccrPedal
GearInfo Gear
MotorInfo[] Motor
bool VCURvsLampReq
bool VCUBrkLampReq
int32 CruiseStatus
int32 VCUEPBReq
float32 CruiseStoredSpeed
bool VCUPtWakeupReq
bool DCChrgrPluginSts
bool ACChrgrPluginSts
bool VCU_VehHldReq
bool VCU_BrkReqEna
bool VCU_ForceFctEna
float32 VCU_TarBrkFReq

================================================================================
MSG: rospy_message_converter/AccrPedalInfo
int32 EfcPosnVld
float32 EfcPosn
int32 ActPosnVld
float32 ActPosn
bool PedlOvrd
uint64 timestamp_ptp_ns

================================================================================
MSG: rospy_message_converter/GearInfo
int32 SlctrPosnVld
int32 ActGearVld
int32 TrgtGearVld
int32 SlctrPosn
int32 ActGear
int32 TrgtGear
uint64 timestamp_ptp_ns

================================================================================
MSG: rospy_message_converter/MotorInfo
int32 IntdMotTqVld
float32 IntdMotTq
int32 ActMotTqVld
float32 ActMotTq
int32 MotSpdVld
float32 MotSpd
uint32 SpdLimForFlt
int32 DampSts
int32 FailrSts
int32 HeatCap
int32 MotHoldSts
uint64[] timestamp_ptp_ns
"""
  __slots__ = ['AccrPedal','Gear','Motor','VCURvsLampReq','VCUBrkLampReq','CruiseStatus','VCUEPBReq','CruiseStoredSpeed','VCUPtWakeupReq','DCChrgrPluginSts','ACChrgrPluginSts','VCU_VehHldReq','VCU_BrkReqEna','VCU_ForceFctEna','VCU_TarBrkFReq']
  _slot_types = ['rospy_message_converter/AccrPedalInfo','rospy_message_converter/GearInfo','rospy_message_converter/MotorInfo[]','bool','bool','int32','int32','float32','bool','bool','bool','bool','bool','bool','float32']

  def __init__(self, *args, **kwds):
    """
    Constructor. Any message fields that are implicitly/explicitly
    set to None will be assigned a default value. The recommend
    use is keyword arguments as this is more robust to future message
    changes.  You cannot mix in-order arguments and keyword arguments.

    The available fields are:
       AccrPedal,Gear,Motor,VCURvsLampReq,VCUBrkLampReq,CruiseStatus,VCUEPBReq,CruiseStoredSpeed,VCUPtWakeupReq,DCChrgrPluginSts,ACChrgrPluginSts,VCU_VehHldReq,VCU_BrkReqEna,VCU_ForceFctEna,VCU_TarBrkFReq

    :param args: complete set of field values, in .msg order
    :param kwds: use keyword arguments corresponding to message field names
    to set specific fields.
    """
    if args or kwds:
      super(PtInfo, self).__init__(*args, **kwds)
      # message fields cannot be None, assign default values for those that are
      if self.AccrPedal is None:
        self.AccrPedal = rospy_message_converter.msg.AccrPedalInfo()
      if self.Gear is None:
        self.Gear = rospy_message_converter.msg.GearInfo()
      if self.Motor is None:
        self.Motor = []
      if self.VCURvsLampReq is None:
        self.VCURvsLampReq = False
      if self.VCUBrkLampReq is None:
        self.VCUBrkLampReq = False
      if self.CruiseStatus is None:
        self.CruiseStatus = 0
      if self.VCUEPBReq is None:
        self.VCUEPBReq = 0
      if self.CruiseStoredSpeed is None:
        self.CruiseStoredSpeed = 0.
      if self.VCUPtWakeupReq is None:
        self.VCUPtWakeupReq = False
      if self.DCChrgrPluginSts is None:
        self.DCChrgrPluginSts = False
      if self.ACChrgrPluginSts is None:
        self.ACChrgrPluginSts = False
      if self.VCU_VehHldReq is None:
        self.VCU_VehHldReq = False
      if self.VCU_BrkReqEna is None:
        self.VCU_BrkReqEna = False
      if self.VCU_ForceFctEna is None:
        self.VCU_ForceFctEna = False
      if self.VCU_TarBrkFReq is None:
        self.VCU_TarBrkFReq = 0.
    else:
      self.AccrPedal = rospy_message_converter.msg.AccrPedalInfo()
      self.Gear = rospy_message_converter.msg.GearInfo()
      self.Motor = []
      self.VCURvsLampReq = False
      self.VCUBrkLampReq = False
      self.CruiseStatus = 0
      self.VCUEPBReq = 0
      self.CruiseStoredSpeed = 0.
      self.VCUPtWakeupReq = False
      self.DCChrgrPluginSts = False
      self.ACChrgrPluginSts = False
      self.VCU_VehHldReq = False
      self.VCU_BrkReqEna = False
      self.VCU_ForceFctEna = False
      self.VCU_TarBrkFReq = 0.

  def _get_types(self):
    """
    internal API method
    """
    return self._slot_types

  def serialize(self, buff):
    """
    serialize message into buffer
    :param buff: buffer, ``StringIO``
    """
    try:
      _x = self
      buff.write(_get_struct_ififBQ6iQ().pack(_x.AccrPedal.EfcPosnVld, _x.AccrPedal.EfcPosn, _x.AccrPedal.ActPosnVld, _x.AccrPedal.ActPosn, _x.AccrPedal.PedlOvrd, _x.AccrPedal.timestamp_ptp_ns, _x.Gear.SlctrPosnVld, _x.Gear.ActGearVld, _x.Gear.TrgtGearVld, _x.Gear.SlctrPosn, _x.Gear.ActGear, _x.Gear.TrgtGear, _x.Gear.timestamp_ptp_ns))
      length = len(self.Motor)
      buff.write(_struct_I.pack(length))
      for val1 in self.Motor:
        _x = val1
        buff.write(_get_struct_ifififI4i().pack(_x.IntdMotTqVld, _x.IntdMotTq, _x.ActMotTqVld, _x.ActMotTq, _x.MotSpdVld, _x.MotSpd, _x.SpdLimForFlt, _x.DampSts, _x.FailrSts, _x.HeatCap, _x.MotHoldSts))
        length = len(val1.timestamp_ptp_ns)
        buff.write(_struct_I.pack(length))
        pattern = '<%sQ'%length
        buff.write(struct.Struct(pattern).pack(*val1.timestamp_ptp_ns))
      _x = self
      buff.write(_get_struct_2B2if6Bf().pack(_x.VCURvsLampReq, _x.VCUBrkLampReq, _x.CruiseStatus, _x.VCUEPBReq, _x.CruiseStoredSpeed, _x.VCUPtWakeupReq, _x.DCChrgrPluginSts, _x.ACChrgrPluginSts, _x.VCU_VehHldReq, _x.VCU_BrkReqEna, _x.VCU_ForceFctEna, _x.VCU_TarBrkFReq))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize(self, str):
    """
    unpack serialized message in str into this message instance
    :param str: byte array of serialized message, ``str``
    """
    if python3:
      codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      if self.AccrPedal is None:
        self.AccrPedal = rospy_message_converter.msg.AccrPedalInfo()
      if self.Gear is None:
        self.Gear = rospy_message_converter.msg.GearInfo()
      if self.Motor is None:
        self.Motor = None
      end = 0
      _x = self
      start = end
      end += 57
      (_x.AccrPedal.EfcPosnVld, _x.AccrPedal.EfcPosn, _x.AccrPedal.ActPosnVld, _x.AccrPedal.ActPosn, _x.AccrPedal.PedlOvrd, _x.AccrPedal.timestamp_ptp_ns, _x.Gear.SlctrPosnVld, _x.Gear.ActGearVld, _x.Gear.TrgtGearVld, _x.Gear.SlctrPosn, _x.Gear.ActGear, _x.Gear.TrgtGear, _x.Gear.timestamp_ptp_ns,) = _get_struct_ififBQ6iQ().unpack(str[start:end])
      self.AccrPedal.PedlOvrd = bool(self.AccrPedal.PedlOvrd)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.Motor = []
      for i in range(0, length):
        val1 = rospy_message_converter.msg.MotorInfo()
        _x = val1
        start = end
        end += 44
        (_x.IntdMotTqVld, _x.IntdMotTq, _x.ActMotTqVld, _x.ActMotTq, _x.MotSpdVld, _x.MotSpd, _x.SpdLimForFlt, _x.DampSts, _x.FailrSts, _x.HeatCap, _x.MotHoldSts,) = _get_struct_ifififI4i().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sQ'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        val1.timestamp_ptp_ns = s.unpack(str[start:end])
        self.Motor.append(val1)
      _x = self
      start = end
      end += 24
      (_x.VCURvsLampReq, _x.VCUBrkLampReq, _x.CruiseStatus, _x.VCUEPBReq, _x.CruiseStoredSpeed, _x.VCUPtWakeupReq, _x.DCChrgrPluginSts, _x.ACChrgrPluginSts, _x.VCU_VehHldReq, _x.VCU_BrkReqEna, _x.VCU_ForceFctEna, _x.VCU_TarBrkFReq,) = _get_struct_2B2if6Bf().unpack(str[start:end])
      self.VCURvsLampReq = bool(self.VCURvsLampReq)
      self.VCUBrkLampReq = bool(self.VCUBrkLampReq)
      self.VCUPtWakeupReq = bool(self.VCUPtWakeupReq)
      self.DCChrgrPluginSts = bool(self.DCChrgrPluginSts)
      self.ACChrgrPluginSts = bool(self.ACChrgrPluginSts)
      self.VCU_VehHldReq = bool(self.VCU_VehHldReq)
      self.VCU_BrkReqEna = bool(self.VCU_BrkReqEna)
      self.VCU_ForceFctEna = bool(self.VCU_ForceFctEna)
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill


  def serialize_numpy(self, buff, numpy):
    """
    serialize message with numpy array types into buffer
    :param buff: buffer, ``StringIO``
    :param numpy: numpy python module
    """
    try:
      _x = self
      buff.write(_get_struct_ififBQ6iQ().pack(_x.AccrPedal.EfcPosnVld, _x.AccrPedal.EfcPosn, _x.AccrPedal.ActPosnVld, _x.AccrPedal.ActPosn, _x.AccrPedal.PedlOvrd, _x.AccrPedal.timestamp_ptp_ns, _x.Gear.SlctrPosnVld, _x.Gear.ActGearVld, _x.Gear.TrgtGearVld, _x.Gear.SlctrPosn, _x.Gear.ActGear, _x.Gear.TrgtGear, _x.Gear.timestamp_ptp_ns))
      length = len(self.Motor)
      buff.write(_struct_I.pack(length))
      for val1 in self.Motor:
        _x = val1
        buff.write(_get_struct_ifififI4i().pack(_x.IntdMotTqVld, _x.IntdMotTq, _x.ActMotTqVld, _x.ActMotTq, _x.MotSpdVld, _x.MotSpd, _x.SpdLimForFlt, _x.DampSts, _x.FailrSts, _x.HeatCap, _x.MotHoldSts))
        length = len(val1.timestamp_ptp_ns)
        buff.write(_struct_I.pack(length))
        pattern = '<%sQ'%length
        buff.write(val1.timestamp_ptp_ns.tostring())
      _x = self
      buff.write(_get_struct_2B2if6Bf().pack(_x.VCURvsLampReq, _x.VCUBrkLampReq, _x.CruiseStatus, _x.VCUEPBReq, _x.CruiseStoredSpeed, _x.VCUPtWakeupReq, _x.DCChrgrPluginSts, _x.ACChrgrPluginSts, _x.VCU_VehHldReq, _x.VCU_BrkReqEna, _x.VCU_ForceFctEna, _x.VCU_TarBrkFReq))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize_numpy(self, str, numpy):
    """
    unpack serialized message in str into this message instance using numpy for array types
    :param str: byte array of serialized message, ``str``
    :param numpy: numpy python module
    """
    if python3:
      codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      if self.AccrPedal is None:
        self.AccrPedal = rospy_message_converter.msg.AccrPedalInfo()
      if self.Gear is None:
        self.Gear = rospy_message_converter.msg.GearInfo()
      if self.Motor is None:
        self.Motor = None
      end = 0
      _x = self
      start = end
      end += 57
      (_x.AccrPedal.EfcPosnVld, _x.AccrPedal.EfcPosn, _x.AccrPedal.ActPosnVld, _x.AccrPedal.ActPosn, _x.AccrPedal.PedlOvrd, _x.AccrPedal.timestamp_ptp_ns, _x.Gear.SlctrPosnVld, _x.Gear.ActGearVld, _x.Gear.TrgtGearVld, _x.Gear.SlctrPosn, _x.Gear.ActGear, _x.Gear.TrgtGear, _x.Gear.timestamp_ptp_ns,) = _get_struct_ififBQ6iQ().unpack(str[start:end])
      self.AccrPedal.PedlOvrd = bool(self.AccrPedal.PedlOvrd)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.Motor = []
      for i in range(0, length):
        val1 = rospy_message_converter.msg.MotorInfo()
        _x = val1
        start = end
        end += 44
        (_x.IntdMotTqVld, _x.IntdMotTq, _x.ActMotTqVld, _x.ActMotTq, _x.MotSpdVld, _x.MotSpd, _x.SpdLimForFlt, _x.DampSts, _x.FailrSts, _x.HeatCap, _x.MotHoldSts,) = _get_struct_ifififI4i().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sQ'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        val1.timestamp_ptp_ns = numpy.frombuffer(str[start:end], dtype=numpy.uint64, count=length)
        self.Motor.append(val1)
      _x = self
      start = end
      end += 24
      (_x.VCURvsLampReq, _x.VCUBrkLampReq, _x.CruiseStatus, _x.VCUEPBReq, _x.CruiseStoredSpeed, _x.VCUPtWakeupReq, _x.DCChrgrPluginSts, _x.ACChrgrPluginSts, _x.VCU_VehHldReq, _x.VCU_BrkReqEna, _x.VCU_ForceFctEna, _x.VCU_TarBrkFReq,) = _get_struct_2B2if6Bf().unpack(str[start:end])
      self.VCURvsLampReq = bool(self.VCURvsLampReq)
      self.VCUBrkLampReq = bool(self.VCUBrkLampReq)
      self.VCUPtWakeupReq = bool(self.VCUPtWakeupReq)
      self.DCChrgrPluginSts = bool(self.DCChrgrPluginSts)
      self.ACChrgrPluginSts = bool(self.ACChrgrPluginSts)
      self.VCU_VehHldReq = bool(self.VCU_VehHldReq)
      self.VCU_BrkReqEna = bool(self.VCU_BrkReqEna)
      self.VCU_ForceFctEna = bool(self.VCU_ForceFctEna)
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill

_struct_I = genpy.struct_I
def _get_struct_I():
    global _struct_I
    return _struct_I
_struct_2B2if6Bf = None
def _get_struct_2B2if6Bf():
    global _struct_2B2if6Bf
    if _struct_2B2if6Bf is None:
        _struct_2B2if6Bf = struct.Struct("<2B2if6Bf")
    return _struct_2B2if6Bf
_struct_ififBQ6iQ = None
def _get_struct_ififBQ6iQ():
    global _struct_ififBQ6iQ
    if _struct_ififBQ6iQ is None:
        _struct_ififBQ6iQ = struct.Struct("<ififBQ6iQ")
    return _struct_ififBQ6iQ
_struct_ifififI4i = None
def _get_struct_ifififI4i():
    global _struct_ifififI4i
    if _struct_ifififI4i is None:
        _struct_ifififI4i = struct.Struct("<ifififI4i")
    return _struct_ifififI4i
