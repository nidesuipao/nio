# This Python file uses the following encoding: utf-8
"""autogenerated by genpy from rospy_message_converter/GlobalRouting.msg. Do not edit."""
import codecs
import sys
python3 = True if sys.hexversion > 0x03000000 else False
import genpy
import struct

import rospy_message_converter.msg

class GlobalRouting(genpy.Message):
  _md5sum = "acb8014e4b63fa712c57c3d64ddaf6cb"
  _type = "rospy_message_converter/GlobalRouting"
  _has_header = False  # flag to mark the presence of a Header object
  _full_text = """int32 route_match_state
bool is_full_routes
uint64 current_hd_link_id
uint64 current_sd_link_id
uint64 last_match_time_ns
uint64 global_routing_counter
SdLinkInfo[] sd_link_info_list
SdMatchedInfo[] sd_matched_info_list
HdLinkSegment[] hd_link_segments
TrafficCongestionInfo traffic_congestion_info
string extended_info
CruiseParkingResponse cruise_parking_response
uint64 publish_ptp_ts
string publisher_id
uint64 counter
uint64 publish_ts

================================================================================
MSG: rospy_message_converter/SdLinkInfo
uint64 sd_link_id
Point3d[] shape_points
float32 link_length

================================================================================
MSG: rospy_message_converter/Point3d
float64 longitude
float64 latitude
float64 altitude

================================================================================
MSG: rospy_message_converter/SdMatchedInfo
uint32 start_sd_link_index
uint32 end_sd_link_index

================================================================================
MSG: rospy_message_converter/HdLinkSegment
HdLinkContent[] hd_link_contents
float32 segment_length_meter
Point3d hd_match_start_point
Point3d hd_match_end_point
float32 offset

================================================================================
MSG: rospy_message_converter/HdLinkContent
uint64 hd_link_id
float64 hd_link_length
HDLaneGroup[] hd_lane_groups
Point3d link_start_point
Point3d link_end_point
uint32 hd_link_lane_status

================================================================================
MSG: rospy_message_converter/HDLaneGroup
uint64 hd_lane_group_id
HDLaneInfo[] hd_lane_infos

================================================================================
MSG: rospy_message_converter/HDLaneInfo
uint64 hd_lane_id
uint64[] entry_lane_ids
uint64[] exit_lane_ids

================================================================================
MSG: rospy_message_converter/TrafficCongestionInfo
uint64 traffic_info_update_time_ns
TrafficCongestionInfoDetail[] traffic_congestion_info_details

================================================================================
MSG: rospy_message_converter/TrafficCongestionInfoDetail
int32 traffic_congestion_info_type
float64 congestion_length_meter
float64 congestion_time_s
float64 traffic_congestion_dist_meter

================================================================================
MSG: rospy_message_converter/CruiseParkingResponse
Point2d power_swap_station_loc
int32 dest_type
string power_swap_station_id
Point3d current_loc
uint64[] current_lane_id_sequence
int32 routing_status
uint64 request_timestamp

================================================================================
MSG: rospy_message_converter/Point2d
float64 longitude
float64 latitude
"""
  __slots__ = ['route_match_state','is_full_routes','current_hd_link_id','current_sd_link_id','last_match_time_ns','global_routing_counter','sd_link_info_list','sd_matched_info_list','hd_link_segments','traffic_congestion_info','extended_info','cruise_parking_response','publish_ptp_ts','publisher_id','counter','publish_ts']
  _slot_types = ['int32','bool','uint64','uint64','uint64','uint64','rospy_message_converter/SdLinkInfo[]','rospy_message_converter/SdMatchedInfo[]','rospy_message_converter/HdLinkSegment[]','rospy_message_converter/TrafficCongestionInfo','string','rospy_message_converter/CruiseParkingResponse','uint64','string','uint64','uint64']

  def __init__(self, *args, **kwds):
    """
    Constructor. Any message fields that are implicitly/explicitly
    set to None will be assigned a default value. The recommend
    use is keyword arguments as this is more robust to future message
    changes.  You cannot mix in-order arguments and keyword arguments.

    The available fields are:
       route_match_state,is_full_routes,current_hd_link_id,current_sd_link_id,last_match_time_ns,global_routing_counter,sd_link_info_list,sd_matched_info_list,hd_link_segments,traffic_congestion_info,extended_info,cruise_parking_response,publish_ptp_ts,publisher_id,counter,publish_ts

    :param args: complete set of field values, in .msg order
    :param kwds: use keyword arguments corresponding to message field names
    to set specific fields.
    """
    if args or kwds:
      super(GlobalRouting, self).__init__(*args, **kwds)
      # message fields cannot be None, assign default values for those that are
      if self.route_match_state is None:
        self.route_match_state = 0
      if self.is_full_routes is None:
        self.is_full_routes = False
      if self.current_hd_link_id is None:
        self.current_hd_link_id = 0
      if self.current_sd_link_id is None:
        self.current_sd_link_id = 0
      if self.last_match_time_ns is None:
        self.last_match_time_ns = 0
      if self.global_routing_counter is None:
        self.global_routing_counter = 0
      if self.sd_link_info_list is None:
        self.sd_link_info_list = []
      if self.sd_matched_info_list is None:
        self.sd_matched_info_list = []
      if self.hd_link_segments is None:
        self.hd_link_segments = []
      if self.traffic_congestion_info is None:
        self.traffic_congestion_info = rospy_message_converter.msg.TrafficCongestionInfo()
      if self.extended_info is None:
        self.extended_info = ''
      if self.cruise_parking_response is None:
        self.cruise_parking_response = rospy_message_converter.msg.CruiseParkingResponse()
      if self.publish_ptp_ts is None:
        self.publish_ptp_ts = 0
      if self.publisher_id is None:
        self.publisher_id = ''
      if self.counter is None:
        self.counter = 0
      if self.publish_ts is None:
        self.publish_ts = 0
    else:
      self.route_match_state = 0
      self.is_full_routes = False
      self.current_hd_link_id = 0
      self.current_sd_link_id = 0
      self.last_match_time_ns = 0
      self.global_routing_counter = 0
      self.sd_link_info_list = []
      self.sd_matched_info_list = []
      self.hd_link_segments = []
      self.traffic_congestion_info = rospy_message_converter.msg.TrafficCongestionInfo()
      self.extended_info = ''
      self.cruise_parking_response = rospy_message_converter.msg.CruiseParkingResponse()
      self.publish_ptp_ts = 0
      self.publisher_id = ''
      self.counter = 0
      self.publish_ts = 0

  def _get_types(self):
    """
    internal API method
    """
    return self._slot_types

  def serialize(self, buff):
    """
    serialize message into buffer
    :param buff: buffer, ``StringIO``
    """
    try:
      _x = self
      buff.write(_get_struct_iB4Q().pack(_x.route_match_state, _x.is_full_routes, _x.current_hd_link_id, _x.current_sd_link_id, _x.last_match_time_ns, _x.global_routing_counter))
      length = len(self.sd_link_info_list)
      buff.write(_struct_I.pack(length))
      for val1 in self.sd_link_info_list:
        _x = val1.sd_link_id
        buff.write(_get_struct_Q().pack(_x))
        length = len(val1.shape_points)
        buff.write(_struct_I.pack(length))
        for val2 in val1.shape_points:
          _x = val2
          buff.write(_get_struct_3d().pack(_x.longitude, _x.latitude, _x.altitude))
        _x = val1.link_length
        buff.write(_get_struct_f().pack(_x))
      length = len(self.sd_matched_info_list)
      buff.write(_struct_I.pack(length))
      for val1 in self.sd_matched_info_list:
        _x = val1
        buff.write(_get_struct_2I().pack(_x.start_sd_link_index, _x.end_sd_link_index))
      length = len(self.hd_link_segments)
      buff.write(_struct_I.pack(length))
      for val1 in self.hd_link_segments:
        length = len(val1.hd_link_contents)
        buff.write(_struct_I.pack(length))
        for val2 in val1.hd_link_contents:
          _x = val2
          buff.write(_get_struct_Qd().pack(_x.hd_link_id, _x.hd_link_length))
          length = len(val2.hd_lane_groups)
          buff.write(_struct_I.pack(length))
          for val3 in val2.hd_lane_groups:
            _x = val3.hd_lane_group_id
            buff.write(_get_struct_Q().pack(_x))
            length = len(val3.hd_lane_infos)
            buff.write(_struct_I.pack(length))
            for val4 in val3.hd_lane_infos:
              _x = val4.hd_lane_id
              buff.write(_get_struct_Q().pack(_x))
              length = len(val4.entry_lane_ids)
              buff.write(_struct_I.pack(length))
              pattern = '<%sQ'%length
              buff.write(struct.Struct(pattern).pack(*val4.entry_lane_ids))
              length = len(val4.exit_lane_ids)
              buff.write(_struct_I.pack(length))
              pattern = '<%sQ'%length
              buff.write(struct.Struct(pattern).pack(*val4.exit_lane_ids))
          _v1 = val2.link_start_point
          _x = _v1
          buff.write(_get_struct_3d().pack(_x.longitude, _x.latitude, _x.altitude))
          _v2 = val2.link_end_point
          _x = _v2
          buff.write(_get_struct_3d().pack(_x.longitude, _x.latitude, _x.altitude))
          _x = val2.hd_link_lane_status
          buff.write(_get_struct_I().pack(_x))
        _x = val1.segment_length_meter
        buff.write(_get_struct_f().pack(_x))
        _v3 = val1.hd_match_start_point
        _x = _v3
        buff.write(_get_struct_3d().pack(_x.longitude, _x.latitude, _x.altitude))
        _v4 = val1.hd_match_end_point
        _x = _v4
        buff.write(_get_struct_3d().pack(_x.longitude, _x.latitude, _x.altitude))
        _x = val1.offset
        buff.write(_get_struct_f().pack(_x))
      _x = self.traffic_congestion_info.traffic_info_update_time_ns
      buff.write(_get_struct_Q().pack(_x))
      length = len(self.traffic_congestion_info.traffic_congestion_info_details)
      buff.write(_struct_I.pack(length))
      for val1 in self.traffic_congestion_info.traffic_congestion_info_details:
        _x = val1
        buff.write(_get_struct_i3d().pack(_x.traffic_congestion_info_type, _x.congestion_length_meter, _x.congestion_time_s, _x.traffic_congestion_dist_meter))
      _x = self.extended_info
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self
      buff.write(_get_struct_2di().pack(_x.cruise_parking_response.power_swap_station_loc.longitude, _x.cruise_parking_response.power_swap_station_loc.latitude, _x.cruise_parking_response.dest_type))
      _x = self.cruise_parking_response.power_swap_station_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self
      buff.write(_get_struct_3d().pack(_x.cruise_parking_response.current_loc.longitude, _x.cruise_parking_response.current_loc.latitude, _x.cruise_parking_response.current_loc.altitude))
      length = len(self.cruise_parking_response.current_lane_id_sequence)
      buff.write(_struct_I.pack(length))
      pattern = '<%sQ'%length
      buff.write(struct.Struct(pattern).pack(*self.cruise_parking_response.current_lane_id_sequence))
      _x = self
      buff.write(_get_struct_i2Q().pack(_x.cruise_parking_response.routing_status, _x.cruise_parking_response.request_timestamp, _x.publish_ptp_ts))
      _x = self.publisher_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self
      buff.write(_get_struct_2Q().pack(_x.counter, _x.publish_ts))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize(self, str):
    """
    unpack serialized message in str into this message instance
    :param str: byte array of serialized message, ``str``
    """
    if python3:
      codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      if self.sd_link_info_list is None:
        self.sd_link_info_list = None
      if self.sd_matched_info_list is None:
        self.sd_matched_info_list = None
      if self.hd_link_segments is None:
        self.hd_link_segments = None
      if self.traffic_congestion_info is None:
        self.traffic_congestion_info = rospy_message_converter.msg.TrafficCongestionInfo()
      if self.cruise_parking_response is None:
        self.cruise_parking_response = rospy_message_converter.msg.CruiseParkingResponse()
      end = 0
      _x = self
      start = end
      end += 37
      (_x.route_match_state, _x.is_full_routes, _x.current_hd_link_id, _x.current_sd_link_id, _x.last_match_time_ns, _x.global_routing_counter,) = _get_struct_iB4Q().unpack(str[start:end])
      self.is_full_routes = bool(self.is_full_routes)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.sd_link_info_list = []
      for i in range(0, length):
        val1 = rospy_message_converter.msg.SdLinkInfo()
        start = end
        end += 8
        (val1.sd_link_id,) = _get_struct_Q().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.shape_points = []
        for i in range(0, length):
          val2 = rospy_message_converter.msg.Point3d()
          _x = val2
          start = end
          end += 24
          (_x.longitude, _x.latitude, _x.altitude,) = _get_struct_3d().unpack(str[start:end])
          val1.shape_points.append(val2)
        start = end
        end += 4
        (val1.link_length,) = _get_struct_f().unpack(str[start:end])
        self.sd_link_info_list.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.sd_matched_info_list = []
      for i in range(0, length):
        val1 = rospy_message_converter.msg.SdMatchedInfo()
        _x = val1
        start = end
        end += 8
        (_x.start_sd_link_index, _x.end_sd_link_index,) = _get_struct_2I().unpack(str[start:end])
        self.sd_matched_info_list.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.hd_link_segments = []
      for i in range(0, length):
        val1 = rospy_message_converter.msg.HdLinkSegment()
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.hd_link_contents = []
        for i in range(0, length):
          val2 = rospy_message_converter.msg.HdLinkContent()
          _x = val2
          start = end
          end += 16
          (_x.hd_link_id, _x.hd_link_length,) = _get_struct_Qd().unpack(str[start:end])
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          val2.hd_lane_groups = []
          for i in range(0, length):
            val3 = rospy_message_converter.msg.HDLaneGroup()
            start = end
            end += 8
            (val3.hd_lane_group_id,) = _get_struct_Q().unpack(str[start:end])
            start = end
            end += 4
            (length,) = _struct_I.unpack(str[start:end])
            val3.hd_lane_infos = []
            for i in range(0, length):
              val4 = rospy_message_converter.msg.HDLaneInfo()
              start = end
              end += 8
              (val4.hd_lane_id,) = _get_struct_Q().unpack(str[start:end])
              start = end
              end += 4
              (length,) = _struct_I.unpack(str[start:end])
              pattern = '<%sQ'%length
              start = end
              s = struct.Struct(pattern)
              end += s.size
              val4.entry_lane_ids = s.unpack(str[start:end])
              start = end
              end += 4
              (length,) = _struct_I.unpack(str[start:end])
              pattern = '<%sQ'%length
              start = end
              s = struct.Struct(pattern)
              end += s.size
              val4.exit_lane_ids = s.unpack(str[start:end])
              val3.hd_lane_infos.append(val4)
            val2.hd_lane_groups.append(val3)
          _v5 = val2.link_start_point
          _x = _v5
          start = end
          end += 24
          (_x.longitude, _x.latitude, _x.altitude,) = _get_struct_3d().unpack(str[start:end])
          _v6 = val2.link_end_point
          _x = _v6
          start = end
          end += 24
          (_x.longitude, _x.latitude, _x.altitude,) = _get_struct_3d().unpack(str[start:end])
          start = end
          end += 4
          (val2.hd_link_lane_status,) = _get_struct_I().unpack(str[start:end])
          val1.hd_link_contents.append(val2)
        start = end
        end += 4
        (val1.segment_length_meter,) = _get_struct_f().unpack(str[start:end])
        _v7 = val1.hd_match_start_point
        _x = _v7
        start = end
        end += 24
        (_x.longitude, _x.latitude, _x.altitude,) = _get_struct_3d().unpack(str[start:end])
        _v8 = val1.hd_match_end_point
        _x = _v8
        start = end
        end += 24
        (_x.longitude, _x.latitude, _x.altitude,) = _get_struct_3d().unpack(str[start:end])
        start = end
        end += 4
        (val1.offset,) = _get_struct_f().unpack(str[start:end])
        self.hd_link_segments.append(val1)
      start = end
      end += 8
      (self.traffic_congestion_info.traffic_info_update_time_ns,) = _get_struct_Q().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.traffic_congestion_info.traffic_congestion_info_details = []
      for i in range(0, length):
        val1 = rospy_message_converter.msg.TrafficCongestionInfoDetail()
        _x = val1
        start = end
        end += 28
        (_x.traffic_congestion_info_type, _x.congestion_length_meter, _x.congestion_time_s, _x.traffic_congestion_dist_meter,) = _get_struct_i3d().unpack(str[start:end])
        self.traffic_congestion_info.traffic_congestion_info_details.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.extended_info = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.extended_info = str[start:end]
      _x = self
      start = end
      end += 20
      (_x.cruise_parking_response.power_swap_station_loc.longitude, _x.cruise_parking_response.power_swap_station_loc.latitude, _x.cruise_parking_response.dest_type,) = _get_struct_2di().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.cruise_parking_response.power_swap_station_id = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.cruise_parking_response.power_swap_station_id = str[start:end]
      _x = self
      start = end
      end += 24
      (_x.cruise_parking_response.current_loc.longitude, _x.cruise_parking_response.current_loc.latitude, _x.cruise_parking_response.current_loc.altitude,) = _get_struct_3d().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sQ'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.cruise_parking_response.current_lane_id_sequence = s.unpack(str[start:end])
      _x = self
      start = end
      end += 20
      (_x.cruise_parking_response.routing_status, _x.cruise_parking_response.request_timestamp, _x.publish_ptp_ts,) = _get_struct_i2Q().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.publisher_id = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.publisher_id = str[start:end]
      _x = self
      start = end
      end += 16
      (_x.counter, _x.publish_ts,) = _get_struct_2Q().unpack(str[start:end])
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill


  def serialize_numpy(self, buff, numpy):
    """
    serialize message with numpy array types into buffer
    :param buff: buffer, ``StringIO``
    :param numpy: numpy python module
    """
    try:
      _x = self
      buff.write(_get_struct_iB4Q().pack(_x.route_match_state, _x.is_full_routes, _x.current_hd_link_id, _x.current_sd_link_id, _x.last_match_time_ns, _x.global_routing_counter))
      length = len(self.sd_link_info_list)
      buff.write(_struct_I.pack(length))
      for val1 in self.sd_link_info_list:
        _x = val1.sd_link_id
        buff.write(_get_struct_Q().pack(_x))
        length = len(val1.shape_points)
        buff.write(_struct_I.pack(length))
        for val2 in val1.shape_points:
          _x = val2
          buff.write(_get_struct_3d().pack(_x.longitude, _x.latitude, _x.altitude))
        _x = val1.link_length
        buff.write(_get_struct_f().pack(_x))
      length = len(self.sd_matched_info_list)
      buff.write(_struct_I.pack(length))
      for val1 in self.sd_matched_info_list:
        _x = val1
        buff.write(_get_struct_2I().pack(_x.start_sd_link_index, _x.end_sd_link_index))
      length = len(self.hd_link_segments)
      buff.write(_struct_I.pack(length))
      for val1 in self.hd_link_segments:
        length = len(val1.hd_link_contents)
        buff.write(_struct_I.pack(length))
        for val2 in val1.hd_link_contents:
          _x = val2
          buff.write(_get_struct_Qd().pack(_x.hd_link_id, _x.hd_link_length))
          length = len(val2.hd_lane_groups)
          buff.write(_struct_I.pack(length))
          for val3 in val2.hd_lane_groups:
            _x = val3.hd_lane_group_id
            buff.write(_get_struct_Q().pack(_x))
            length = len(val3.hd_lane_infos)
            buff.write(_struct_I.pack(length))
            for val4 in val3.hd_lane_infos:
              _x = val4.hd_lane_id
              buff.write(_get_struct_Q().pack(_x))
              length = len(val4.entry_lane_ids)
              buff.write(_struct_I.pack(length))
              pattern = '<%sQ'%length
              buff.write(val4.entry_lane_ids.tostring())
              length = len(val4.exit_lane_ids)
              buff.write(_struct_I.pack(length))
              pattern = '<%sQ'%length
              buff.write(val4.exit_lane_ids.tostring())
          _v9 = val2.link_start_point
          _x = _v9
          buff.write(_get_struct_3d().pack(_x.longitude, _x.latitude, _x.altitude))
          _v10 = val2.link_end_point
          _x = _v10
          buff.write(_get_struct_3d().pack(_x.longitude, _x.latitude, _x.altitude))
          _x = val2.hd_link_lane_status
          buff.write(_get_struct_I().pack(_x))
        _x = val1.segment_length_meter
        buff.write(_get_struct_f().pack(_x))
        _v11 = val1.hd_match_start_point
        _x = _v11
        buff.write(_get_struct_3d().pack(_x.longitude, _x.latitude, _x.altitude))
        _v12 = val1.hd_match_end_point
        _x = _v12
        buff.write(_get_struct_3d().pack(_x.longitude, _x.latitude, _x.altitude))
        _x = val1.offset
        buff.write(_get_struct_f().pack(_x))
      _x = self.traffic_congestion_info.traffic_info_update_time_ns
      buff.write(_get_struct_Q().pack(_x))
      length = len(self.traffic_congestion_info.traffic_congestion_info_details)
      buff.write(_struct_I.pack(length))
      for val1 in self.traffic_congestion_info.traffic_congestion_info_details:
        _x = val1
        buff.write(_get_struct_i3d().pack(_x.traffic_congestion_info_type, _x.congestion_length_meter, _x.congestion_time_s, _x.traffic_congestion_dist_meter))
      _x = self.extended_info
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self
      buff.write(_get_struct_2di().pack(_x.cruise_parking_response.power_swap_station_loc.longitude, _x.cruise_parking_response.power_swap_station_loc.latitude, _x.cruise_parking_response.dest_type))
      _x = self.cruise_parking_response.power_swap_station_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self
      buff.write(_get_struct_3d().pack(_x.cruise_parking_response.current_loc.longitude, _x.cruise_parking_response.current_loc.latitude, _x.cruise_parking_response.current_loc.altitude))
      length = len(self.cruise_parking_response.current_lane_id_sequence)
      buff.write(_struct_I.pack(length))
      pattern = '<%sQ'%length
      buff.write(self.cruise_parking_response.current_lane_id_sequence.tostring())
      _x = self
      buff.write(_get_struct_i2Q().pack(_x.cruise_parking_response.routing_status, _x.cruise_parking_response.request_timestamp, _x.publish_ptp_ts))
      _x = self.publisher_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self
      buff.write(_get_struct_2Q().pack(_x.counter, _x.publish_ts))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize_numpy(self, str, numpy):
    """
    unpack serialized message in str into this message instance using numpy for array types
    :param str: byte array of serialized message, ``str``
    :param numpy: numpy python module
    """
    if python3:
      codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      if self.sd_link_info_list is None:
        self.sd_link_info_list = None
      if self.sd_matched_info_list is None:
        self.sd_matched_info_list = None
      if self.hd_link_segments is None:
        self.hd_link_segments = None
      if self.traffic_congestion_info is None:
        self.traffic_congestion_info = rospy_message_converter.msg.TrafficCongestionInfo()
      if self.cruise_parking_response is None:
        self.cruise_parking_response = rospy_message_converter.msg.CruiseParkingResponse()
      end = 0
      _x = self
      start = end
      end += 37
      (_x.route_match_state, _x.is_full_routes, _x.current_hd_link_id, _x.current_sd_link_id, _x.last_match_time_ns, _x.global_routing_counter,) = _get_struct_iB4Q().unpack(str[start:end])
      self.is_full_routes = bool(self.is_full_routes)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.sd_link_info_list = []
      for i in range(0, length):
        val1 = rospy_message_converter.msg.SdLinkInfo()
        start = end
        end += 8
        (val1.sd_link_id,) = _get_struct_Q().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.shape_points = []
        for i in range(0, length):
          val2 = rospy_message_converter.msg.Point3d()
          _x = val2
          start = end
          end += 24
          (_x.longitude, _x.latitude, _x.altitude,) = _get_struct_3d().unpack(str[start:end])
          val1.shape_points.append(val2)
        start = end
        end += 4
        (val1.link_length,) = _get_struct_f().unpack(str[start:end])
        self.sd_link_info_list.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.sd_matched_info_list = []
      for i in range(0, length):
        val1 = rospy_message_converter.msg.SdMatchedInfo()
        _x = val1
        start = end
        end += 8
        (_x.start_sd_link_index, _x.end_sd_link_index,) = _get_struct_2I().unpack(str[start:end])
        self.sd_matched_info_list.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.hd_link_segments = []
      for i in range(0, length):
        val1 = rospy_message_converter.msg.HdLinkSegment()
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.hd_link_contents = []
        for i in range(0, length):
          val2 = rospy_message_converter.msg.HdLinkContent()
          _x = val2
          start = end
          end += 16
          (_x.hd_link_id, _x.hd_link_length,) = _get_struct_Qd().unpack(str[start:end])
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          val2.hd_lane_groups = []
          for i in range(0, length):
            val3 = rospy_message_converter.msg.HDLaneGroup()
            start = end
            end += 8
            (val3.hd_lane_group_id,) = _get_struct_Q().unpack(str[start:end])
            start = end
            end += 4
            (length,) = _struct_I.unpack(str[start:end])
            val3.hd_lane_infos = []
            for i in range(0, length):
              val4 = rospy_message_converter.msg.HDLaneInfo()
              start = end
              end += 8
              (val4.hd_lane_id,) = _get_struct_Q().unpack(str[start:end])
              start = end
              end += 4
              (length,) = _struct_I.unpack(str[start:end])
              pattern = '<%sQ'%length
              start = end
              s = struct.Struct(pattern)
              end += s.size
              val4.entry_lane_ids = numpy.frombuffer(str[start:end], dtype=numpy.uint64, count=length)
              start = end
              end += 4
              (length,) = _struct_I.unpack(str[start:end])
              pattern = '<%sQ'%length
              start = end
              s = struct.Struct(pattern)
              end += s.size
              val4.exit_lane_ids = numpy.frombuffer(str[start:end], dtype=numpy.uint64, count=length)
              val3.hd_lane_infos.append(val4)
            val2.hd_lane_groups.append(val3)
          _v13 = val2.link_start_point
          _x = _v13
          start = end
          end += 24
          (_x.longitude, _x.latitude, _x.altitude,) = _get_struct_3d().unpack(str[start:end])
          _v14 = val2.link_end_point
          _x = _v14
          start = end
          end += 24
          (_x.longitude, _x.latitude, _x.altitude,) = _get_struct_3d().unpack(str[start:end])
          start = end
          end += 4
          (val2.hd_link_lane_status,) = _get_struct_I().unpack(str[start:end])
          val1.hd_link_contents.append(val2)
        start = end
        end += 4
        (val1.segment_length_meter,) = _get_struct_f().unpack(str[start:end])
        _v15 = val1.hd_match_start_point
        _x = _v15
        start = end
        end += 24
        (_x.longitude, _x.latitude, _x.altitude,) = _get_struct_3d().unpack(str[start:end])
        _v16 = val1.hd_match_end_point
        _x = _v16
        start = end
        end += 24
        (_x.longitude, _x.latitude, _x.altitude,) = _get_struct_3d().unpack(str[start:end])
        start = end
        end += 4
        (val1.offset,) = _get_struct_f().unpack(str[start:end])
        self.hd_link_segments.append(val1)
      start = end
      end += 8
      (self.traffic_congestion_info.traffic_info_update_time_ns,) = _get_struct_Q().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.traffic_congestion_info.traffic_congestion_info_details = []
      for i in range(0, length):
        val1 = rospy_message_converter.msg.TrafficCongestionInfoDetail()
        _x = val1
        start = end
        end += 28
        (_x.traffic_congestion_info_type, _x.congestion_length_meter, _x.congestion_time_s, _x.traffic_congestion_dist_meter,) = _get_struct_i3d().unpack(str[start:end])
        self.traffic_congestion_info.traffic_congestion_info_details.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.extended_info = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.extended_info = str[start:end]
      _x = self
      start = end
      end += 20
      (_x.cruise_parking_response.power_swap_station_loc.longitude, _x.cruise_parking_response.power_swap_station_loc.latitude, _x.cruise_parking_response.dest_type,) = _get_struct_2di().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.cruise_parking_response.power_swap_station_id = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.cruise_parking_response.power_swap_station_id = str[start:end]
      _x = self
      start = end
      end += 24
      (_x.cruise_parking_response.current_loc.longitude, _x.cruise_parking_response.current_loc.latitude, _x.cruise_parking_response.current_loc.altitude,) = _get_struct_3d().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sQ'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.cruise_parking_response.current_lane_id_sequence = numpy.frombuffer(str[start:end], dtype=numpy.uint64, count=length)
      _x = self
      start = end
      end += 20
      (_x.cruise_parking_response.routing_status, _x.cruise_parking_response.request_timestamp, _x.publish_ptp_ts,) = _get_struct_i2Q().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.publisher_id = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.publisher_id = str[start:end]
      _x = self
      start = end
      end += 16
      (_x.counter, _x.publish_ts,) = _get_struct_2Q().unpack(str[start:end])
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill

_struct_I = genpy.struct_I
def _get_struct_I():
    global _struct_I
    return _struct_I
_struct_2I = None
def _get_struct_2I():
    global _struct_2I
    if _struct_2I is None:
        _struct_2I = struct.Struct("<2I")
    return _struct_2I
_struct_2Q = None
def _get_struct_2Q():
    global _struct_2Q
    if _struct_2Q is None:
        _struct_2Q = struct.Struct("<2Q")
    return _struct_2Q
_struct_2di = None
def _get_struct_2di():
    global _struct_2di
    if _struct_2di is None:
        _struct_2di = struct.Struct("<2di")
    return _struct_2di
_struct_3d = None
def _get_struct_3d():
    global _struct_3d
    if _struct_3d is None:
        _struct_3d = struct.Struct("<3d")
    return _struct_3d
_struct_Q = None
def _get_struct_Q():
    global _struct_Q
    if _struct_Q is None:
        _struct_Q = struct.Struct("<Q")
    return _struct_Q
_struct_Qd = None
def _get_struct_Qd():
    global _struct_Qd
    if _struct_Qd is None:
        _struct_Qd = struct.Struct("<Qd")
    return _struct_Qd
_struct_f = None
def _get_struct_f():
    global _struct_f
    if _struct_f is None:
        _struct_f = struct.Struct("<f")
    return _struct_f
_struct_i2Q = None
def _get_struct_i2Q():
    global _struct_i2Q
    if _struct_i2Q is None:
        _struct_i2Q = struct.Struct("<i2Q")
    return _struct_i2Q
_struct_i3d = None
def _get_struct_i3d():
    global _struct_i3d
    if _struct_i3d is None:
        _struct_i3d = struct.Struct("<i3d")
    return _struct_i3d
_struct_iB4Q = None
def _get_struct_iB4Q():
    global _struct_iB4Q
    if _struct_iB4Q is None:
        _struct_iB4Q = struct.Struct("<iB4Q")
    return _struct_iB4Q
