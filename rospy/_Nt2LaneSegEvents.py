# This Python file uses the following encoding: utf-8
"""autogenerated by genpy from rospy_message_converter/Nt2LaneSegEvents.msg. Do not edit."""
import codecs
import sys
python3 = True if sys.hexversion > 0x03000000 else False
import genpy
import struct

import rospy_message_converter.msg

class Nt2LaneSegEvents(genpy.Message):
  _md5sum = "317e9735a42a9be1f8ab69019ccbe8f8"
  _type = "rospy_message_converter/Nt2LaneSegEvents"
  _has_header = False  # flag to mark the presence of a Header object
  _full_text = """Nt2LaneSegEvent[] events

================================================================================
MSG: rospy_message_converter/Nt2LaneSegEvent
EventBase event_base
EventCondition event_condition
EventAction event_action

================================================================================
MSG: rospy_message_converter/EventBase
string event_id
int32 OBSOLETE_event_type
int32 message_type
string event_base_type

================================================================================
MSG: rospy_message_converter/EventCondition
string vehicle_model
string software_version
string hardware_version
string map_version
Point2D event_gps
string event_start_time
string event_end_time
ScenarioType scenario_type
int32 driver_filter
string range_start_time
string range_end_time

================================================================================
MSG: rospy_message_converter/Point2D
float64 x
float64 y

================================================================================
MSG: rospy_message_converter/ScenarioType
int32 weather_type
int32 lighting_type

================================================================================
MSG: rospy_message_converter/EventAction
int32 ad_mode_type
DrivingAction driving_action
ParkingAction parking_action
DMSAction dms_action

================================================================================
MSG: rospy_message_converter/DrivingAction
DrivingActionRule action_rule
DrivingActionContext action_context

================================================================================
MSG: rospy_message_converter/DrivingActionRule
LaneSegLink[] lane_seg_link

================================================================================
MSG: rospy_message_converter/LaneSegLink
int32 offset_start
int32 offset_end
string lane_id

================================================================================
MSG: rospy_message_converter/DrivingActionContext
InfoConfig[] info_config

================================================================================
MSG: rospy_message_converter/InfoConfig
int32 info_value
int32 static_info
int32 dynamic_info
int32 road_scenario_type

================================================================================
MSG: rospy_message_converter/ParkingAction
PackingActionRule action_rule
PackingActionContext action_context

================================================================================
MSG: rospy_message_converter/PackingActionRule
string park_station_id
ParkLaneId park_lane_id

================================================================================
MSG: rospy_message_converter/ParkLaneId
string lane_id
LaneSegLink[] lane_seg_link

================================================================================
MSG: rospy_message_converter/PackingActionContext
InfoConfig[] info_config

================================================================================
MSG: rospy_message_converter/DMSAction
DrowsinessConfig drowsiness_config
DistractionConfig distraction_config
bool DMSDistractionSwitch_cloud
bool DMSDrowsinessSwitch_cloud_light
bool DMSDrowsinessSwitch_cloud_medium
bool DMSDrowsinessSwitch_cloud_heavy

================================================================================
MSG: rospy_message_converter/DrowsinessConfig
EyeConfig eye_config
MouthConfig mouth_config
Customized customized

================================================================================
MSG: rospy_message_converter/EyeConfig
float64 perclos_light
float64 perclos_medium
float64 perclos_window_time

================================================================================
MSG: rospy_message_converter/MouthConfig
int32 yawn_light
int32 yawn_medium
float64 yawn_windown_time

================================================================================
MSG: rospy_message_converter/Customized
float64 eye_close_thr
float64 eye_open_thr

================================================================================
MSG: rospy_message_converter/DistractionConfig
DistractionScoreThr distraction_score_thr
DistractionRectangle distraction_rectangle
float64 distraction_fast_fade_time

================================================================================
MSG: rospy_message_converter/DistractionScoreThr
float64 distraction_light_thr
float64 distraction_medium_thr
float64 distraction_heavy_thr

================================================================================
MSG: rospy_message_converter/DistractionRectangle
Gaze3DPoint gaze_3D_point
HeadPose head_pose

================================================================================
MSG: rospy_message_converter/Gaze3DPoint
Zones X
Zones Y

================================================================================
MSG: rospy_message_converter/Zones
float64 min
float64 max

================================================================================
MSG: rospy_message_converter/HeadPose
Zones yaw
Zones pitch
Zones roll
"""
  __slots__ = ['events']
  _slot_types = ['rospy_message_converter/Nt2LaneSegEvent[]']

  def __init__(self, *args, **kwds):
    """
    Constructor. Any message fields that are implicitly/explicitly
    set to None will be assigned a default value. The recommend
    use is keyword arguments as this is more robust to future message
    changes.  You cannot mix in-order arguments and keyword arguments.

    The available fields are:
       events

    :param args: complete set of field values, in .msg order
    :param kwds: use keyword arguments corresponding to message field names
    to set specific fields.
    """
    if args or kwds:
      super(Nt2LaneSegEvents, self).__init__(*args, **kwds)
      # message fields cannot be None, assign default values for those that are
      if self.events is None:
        self.events = []
    else:
      self.events = []

  def _get_types(self):
    """
    internal API method
    """
    return self._slot_types

  def serialize(self, buff):
    """
    serialize message into buffer
    :param buff: buffer, ``StringIO``
    """
    try:
      length = len(self.events)
      buff.write(_struct_I.pack(length))
      for val1 in self.events:
        _v1 = val1.event_base
        _x = _v1.event_id
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
        _x = _v1
        buff.write(_get_struct_2i().pack(_x.OBSOLETE_event_type, _x.message_type))
        _x = _v1.event_base_type
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
        _v2 = val1.event_condition
        _x = _v2.vehicle_model
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
        _x = _v2.software_version
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
        _x = _v2.hardware_version
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
        _x = _v2.map_version
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
        _v3 = _v2.event_gps
        _x = _v3
        buff.write(_get_struct_2d().pack(_x.x, _x.y))
        _x = _v2.event_start_time
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
        _x = _v2.event_end_time
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
        _v4 = _v2.scenario_type
        _x = _v4
        buff.write(_get_struct_2i().pack(_x.weather_type, _x.lighting_type))
        _x = _v2.driver_filter
        buff.write(_get_struct_i().pack(_x))
        _x = _v2.range_start_time
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
        _x = _v2.range_end_time
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
        _v5 = val1.event_action
        _x = _v5.ad_mode_type
        buff.write(_get_struct_i().pack(_x))
        _v6 = _v5.driving_action
        _v7 = _v6.action_rule
        length = len(_v7.lane_seg_link)
        buff.write(_struct_I.pack(length))
        for val5 in _v7.lane_seg_link:
          _x = val5
          buff.write(_get_struct_2i().pack(_x.offset_start, _x.offset_end))
          _x = val5.lane_id
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
        _v8 = _v6.action_context
        length = len(_v8.info_config)
        buff.write(_struct_I.pack(length))
        for val5 in _v8.info_config:
          _x = val5
          buff.write(_get_struct_4i().pack(_x.info_value, _x.static_info, _x.dynamic_info, _x.road_scenario_type))
        _v9 = _v5.parking_action
        _v10 = _v9.action_rule
        _x = _v10.park_station_id
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
        _v11 = _v10.park_lane_id
        _x = _v11.lane_id
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
        length = len(_v11.lane_seg_link)
        buff.write(_struct_I.pack(length))
        for val6 in _v11.lane_seg_link:
          _x = val6
          buff.write(_get_struct_2i().pack(_x.offset_start, _x.offset_end))
          _x = val6.lane_id
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
        _v12 = _v9.action_context
        length = len(_v12.info_config)
        buff.write(_struct_I.pack(length))
        for val5 in _v12.info_config:
          _x = val5
          buff.write(_get_struct_4i().pack(_x.info_value, _x.static_info, _x.dynamic_info, _x.road_scenario_type))
        _v13 = _v5.dms_action
        _v14 = _v13.drowsiness_config
        _v15 = _v14.eye_config
        _x = _v15
        buff.write(_get_struct_3d().pack(_x.perclos_light, _x.perclos_medium, _x.perclos_window_time))
        _v16 = _v14.mouth_config
        _x = _v16
        buff.write(_get_struct_2id().pack(_x.yawn_light, _x.yawn_medium, _x.yawn_windown_time))
        _v17 = _v14.customized
        _x = _v17
        buff.write(_get_struct_2d().pack(_x.eye_close_thr, _x.eye_open_thr))
        _v18 = _v13.distraction_config
        _v19 = _v18.distraction_score_thr
        _x = _v19
        buff.write(_get_struct_3d().pack(_x.distraction_light_thr, _x.distraction_medium_thr, _x.distraction_heavy_thr))
        _v20 = _v18.distraction_rectangle
        _v21 = _v20.gaze_3D_point
        _v22 = _v21.X
        _x = _v22
        buff.write(_get_struct_2d().pack(_x.min, _x.max))
        _v23 = _v21.Y
        _x = _v23
        buff.write(_get_struct_2d().pack(_x.min, _x.max))
        _v24 = _v20.head_pose
        _v25 = _v24.yaw
        _x = _v25
        buff.write(_get_struct_2d().pack(_x.min, _x.max))
        _v26 = _v24.pitch
        _x = _v26
        buff.write(_get_struct_2d().pack(_x.min, _x.max))
        _v27 = _v24.roll
        _x = _v27
        buff.write(_get_struct_2d().pack(_x.min, _x.max))
        _x = _v18.distraction_fast_fade_time
        buff.write(_get_struct_d().pack(_x))
        _x = _v13
        buff.write(_get_struct_4B().pack(_x.DMSDistractionSwitch_cloud, _x.DMSDrowsinessSwitch_cloud_light, _x.DMSDrowsinessSwitch_cloud_medium, _x.DMSDrowsinessSwitch_cloud_heavy))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize(self, str):
    """
    unpack serialized message in str into this message instance
    :param str: byte array of serialized message, ``str``
    """
    if python3:
      codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      if self.events is None:
        self.events = None
      end = 0
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.events = []
      for i in range(0, length):
        val1 = rospy_message_converter.msg.Nt2LaneSegEvent()
        _v28 = val1.event_base
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          _v28.event_id = str[start:end].decode('utf-8', 'rosmsg')
        else:
          _v28.event_id = str[start:end]
        _x = _v28
        start = end
        end += 8
        (_x.OBSOLETE_event_type, _x.message_type,) = _get_struct_2i().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          _v28.event_base_type = str[start:end].decode('utf-8', 'rosmsg')
        else:
          _v28.event_base_type = str[start:end]
        _v29 = val1.event_condition
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          _v29.vehicle_model = str[start:end].decode('utf-8', 'rosmsg')
        else:
          _v29.vehicle_model = str[start:end]
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          _v29.software_version = str[start:end].decode('utf-8', 'rosmsg')
        else:
          _v29.software_version = str[start:end]
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          _v29.hardware_version = str[start:end].decode('utf-8', 'rosmsg')
        else:
          _v29.hardware_version = str[start:end]
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          _v29.map_version = str[start:end].decode('utf-8', 'rosmsg')
        else:
          _v29.map_version = str[start:end]
        _v30 = _v29.event_gps
        _x = _v30
        start = end
        end += 16
        (_x.x, _x.y,) = _get_struct_2d().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          _v29.event_start_time = str[start:end].decode('utf-8', 'rosmsg')
        else:
          _v29.event_start_time = str[start:end]
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          _v29.event_end_time = str[start:end].decode('utf-8', 'rosmsg')
        else:
          _v29.event_end_time = str[start:end]
        _v31 = _v29.scenario_type
        _x = _v31
        start = end
        end += 8
        (_x.weather_type, _x.lighting_type,) = _get_struct_2i().unpack(str[start:end])
        start = end
        end += 4
        (_v29.driver_filter,) = _get_struct_i().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          _v29.range_start_time = str[start:end].decode('utf-8', 'rosmsg')
        else:
          _v29.range_start_time = str[start:end]
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          _v29.range_end_time = str[start:end].decode('utf-8', 'rosmsg')
        else:
          _v29.range_end_time = str[start:end]
        _v32 = val1.event_action
        start = end
        end += 4
        (_v32.ad_mode_type,) = _get_struct_i().unpack(str[start:end])
        _v33 = _v32.driving_action
        _v34 = _v33.action_rule
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v34.lane_seg_link = []
        for i in range(0, length):
          val5 = rospy_message_converter.msg.LaneSegLink()
          _x = val5
          start = end
          end += 8
          (_x.offset_start, _x.offset_end,) = _get_struct_2i().unpack(str[start:end])
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val5.lane_id = str[start:end].decode('utf-8', 'rosmsg')
          else:
            val5.lane_id = str[start:end]
          _v34.lane_seg_link.append(val5)
        _v35 = _v33.action_context
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v35.info_config = []
        for i in range(0, length):
          val5 = rospy_message_converter.msg.InfoConfig()
          _x = val5
          start = end
          end += 16
          (_x.info_value, _x.static_info, _x.dynamic_info, _x.road_scenario_type,) = _get_struct_4i().unpack(str[start:end])
          _v35.info_config.append(val5)
        _v36 = _v32.parking_action
        _v37 = _v36.action_rule
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          _v37.park_station_id = str[start:end].decode('utf-8', 'rosmsg')
        else:
          _v37.park_station_id = str[start:end]
        _v38 = _v37.park_lane_id
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          _v38.lane_id = str[start:end].decode('utf-8', 'rosmsg')
        else:
          _v38.lane_id = str[start:end]
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v38.lane_seg_link = []
        for i in range(0, length):
          val6 = rospy_message_converter.msg.LaneSegLink()
          _x = val6
          start = end
          end += 8
          (_x.offset_start, _x.offset_end,) = _get_struct_2i().unpack(str[start:end])
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val6.lane_id = str[start:end].decode('utf-8', 'rosmsg')
          else:
            val6.lane_id = str[start:end]
          _v38.lane_seg_link.append(val6)
        _v39 = _v36.action_context
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v39.info_config = []
        for i in range(0, length):
          val5 = rospy_message_converter.msg.InfoConfig()
          _x = val5
          start = end
          end += 16
          (_x.info_value, _x.static_info, _x.dynamic_info, _x.road_scenario_type,) = _get_struct_4i().unpack(str[start:end])
          _v39.info_config.append(val5)
        _v40 = _v32.dms_action
        _v41 = _v40.drowsiness_config
        _v42 = _v41.eye_config
        _x = _v42
        start = end
        end += 24
        (_x.perclos_light, _x.perclos_medium, _x.perclos_window_time,) = _get_struct_3d().unpack(str[start:end])
        _v43 = _v41.mouth_config
        _x = _v43
        start = end
        end += 16
        (_x.yawn_light, _x.yawn_medium, _x.yawn_windown_time,) = _get_struct_2id().unpack(str[start:end])
        _v44 = _v41.customized
        _x = _v44
        start = end
        end += 16
        (_x.eye_close_thr, _x.eye_open_thr,) = _get_struct_2d().unpack(str[start:end])
        _v45 = _v40.distraction_config
        _v46 = _v45.distraction_score_thr
        _x = _v46
        start = end
        end += 24
        (_x.distraction_light_thr, _x.distraction_medium_thr, _x.distraction_heavy_thr,) = _get_struct_3d().unpack(str[start:end])
        _v47 = _v45.distraction_rectangle
        _v48 = _v47.gaze_3D_point
        _v49 = _v48.X
        _x = _v49
        start = end
        end += 16
        (_x.min, _x.max,) = _get_struct_2d().unpack(str[start:end])
        _v50 = _v48.Y
        _x = _v50
        start = end
        end += 16
        (_x.min, _x.max,) = _get_struct_2d().unpack(str[start:end])
        _v51 = _v47.head_pose
        _v52 = _v51.yaw
        _x = _v52
        start = end
        end += 16
        (_x.min, _x.max,) = _get_struct_2d().unpack(str[start:end])
        _v53 = _v51.pitch
        _x = _v53
        start = end
        end += 16
        (_x.min, _x.max,) = _get_struct_2d().unpack(str[start:end])
        _v54 = _v51.roll
        _x = _v54
        start = end
        end += 16
        (_x.min, _x.max,) = _get_struct_2d().unpack(str[start:end])
        start = end
        end += 8
        (_v45.distraction_fast_fade_time,) = _get_struct_d().unpack(str[start:end])
        _x = _v40
        start = end
        end += 4
        (_x.DMSDistractionSwitch_cloud, _x.DMSDrowsinessSwitch_cloud_light, _x.DMSDrowsinessSwitch_cloud_medium, _x.DMSDrowsinessSwitch_cloud_heavy,) = _get_struct_4B().unpack(str[start:end])
        _v40.DMSDistractionSwitch_cloud = bool(_v40.DMSDistractionSwitch_cloud)
        _v40.DMSDrowsinessSwitch_cloud_light = bool(_v40.DMSDrowsinessSwitch_cloud_light)
        _v40.DMSDrowsinessSwitch_cloud_medium = bool(_v40.DMSDrowsinessSwitch_cloud_medium)
        _v40.DMSDrowsinessSwitch_cloud_heavy = bool(_v40.DMSDrowsinessSwitch_cloud_heavy)
        self.events.append(val1)
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill


  def serialize_numpy(self, buff, numpy):
    """
    serialize message with numpy array types into buffer
    :param buff: buffer, ``StringIO``
    :param numpy: numpy python module
    """
    try:
      length = len(self.events)
      buff.write(_struct_I.pack(length))
      for val1 in self.events:
        _v55 = val1.event_base
        _x = _v55.event_id
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
        _x = _v55
        buff.write(_get_struct_2i().pack(_x.OBSOLETE_event_type, _x.message_type))
        _x = _v55.event_base_type
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
        _v56 = val1.event_condition
        _x = _v56.vehicle_model
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
        _x = _v56.software_version
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
        _x = _v56.hardware_version
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
        _x = _v56.map_version
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
        _v57 = _v56.event_gps
        _x = _v57
        buff.write(_get_struct_2d().pack(_x.x, _x.y))
        _x = _v56.event_start_time
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
        _x = _v56.event_end_time
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
        _v58 = _v56.scenario_type
        _x = _v58
        buff.write(_get_struct_2i().pack(_x.weather_type, _x.lighting_type))
        _x = _v56.driver_filter
        buff.write(_get_struct_i().pack(_x))
        _x = _v56.range_start_time
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
        _x = _v56.range_end_time
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
        _v59 = val1.event_action
        _x = _v59.ad_mode_type
        buff.write(_get_struct_i().pack(_x))
        _v60 = _v59.driving_action
        _v61 = _v60.action_rule
        length = len(_v61.lane_seg_link)
        buff.write(_struct_I.pack(length))
        for val5 in _v61.lane_seg_link:
          _x = val5
          buff.write(_get_struct_2i().pack(_x.offset_start, _x.offset_end))
          _x = val5.lane_id
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
        _v62 = _v60.action_context
        length = len(_v62.info_config)
        buff.write(_struct_I.pack(length))
        for val5 in _v62.info_config:
          _x = val5
          buff.write(_get_struct_4i().pack(_x.info_value, _x.static_info, _x.dynamic_info, _x.road_scenario_type))
        _v63 = _v59.parking_action
        _v64 = _v63.action_rule
        _x = _v64.park_station_id
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
        _v65 = _v64.park_lane_id
        _x = _v65.lane_id
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
        length = len(_v65.lane_seg_link)
        buff.write(_struct_I.pack(length))
        for val6 in _v65.lane_seg_link:
          _x = val6
          buff.write(_get_struct_2i().pack(_x.offset_start, _x.offset_end))
          _x = val6.lane_id
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
        _v66 = _v63.action_context
        length = len(_v66.info_config)
        buff.write(_struct_I.pack(length))
        for val5 in _v66.info_config:
          _x = val5
          buff.write(_get_struct_4i().pack(_x.info_value, _x.static_info, _x.dynamic_info, _x.road_scenario_type))
        _v67 = _v59.dms_action
        _v68 = _v67.drowsiness_config
        _v69 = _v68.eye_config
        _x = _v69
        buff.write(_get_struct_3d().pack(_x.perclos_light, _x.perclos_medium, _x.perclos_window_time))
        _v70 = _v68.mouth_config
        _x = _v70
        buff.write(_get_struct_2id().pack(_x.yawn_light, _x.yawn_medium, _x.yawn_windown_time))
        _v71 = _v68.customized
        _x = _v71
        buff.write(_get_struct_2d().pack(_x.eye_close_thr, _x.eye_open_thr))
        _v72 = _v67.distraction_config
        _v73 = _v72.distraction_score_thr
        _x = _v73
        buff.write(_get_struct_3d().pack(_x.distraction_light_thr, _x.distraction_medium_thr, _x.distraction_heavy_thr))
        _v74 = _v72.distraction_rectangle
        _v75 = _v74.gaze_3D_point
        _v76 = _v75.X
        _x = _v76
        buff.write(_get_struct_2d().pack(_x.min, _x.max))
        _v77 = _v75.Y
        _x = _v77
        buff.write(_get_struct_2d().pack(_x.min, _x.max))
        _v78 = _v74.head_pose
        _v79 = _v78.yaw
        _x = _v79
        buff.write(_get_struct_2d().pack(_x.min, _x.max))
        _v80 = _v78.pitch
        _x = _v80
        buff.write(_get_struct_2d().pack(_x.min, _x.max))
        _v81 = _v78.roll
        _x = _v81
        buff.write(_get_struct_2d().pack(_x.min, _x.max))
        _x = _v72.distraction_fast_fade_time
        buff.write(_get_struct_d().pack(_x))
        _x = _v67
        buff.write(_get_struct_4B().pack(_x.DMSDistractionSwitch_cloud, _x.DMSDrowsinessSwitch_cloud_light, _x.DMSDrowsinessSwitch_cloud_medium, _x.DMSDrowsinessSwitch_cloud_heavy))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize_numpy(self, str, numpy):
    """
    unpack serialized message in str into this message instance using numpy for array types
    :param str: byte array of serialized message, ``str``
    :param numpy: numpy python module
    """
    if python3:
      codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      if self.events is None:
        self.events = None
      end = 0
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.events = []
      for i in range(0, length):
        val1 = rospy_message_converter.msg.Nt2LaneSegEvent()
        _v82 = val1.event_base
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          _v82.event_id = str[start:end].decode('utf-8', 'rosmsg')
        else:
          _v82.event_id = str[start:end]
        _x = _v82
        start = end
        end += 8
        (_x.OBSOLETE_event_type, _x.message_type,) = _get_struct_2i().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          _v82.event_base_type = str[start:end].decode('utf-8', 'rosmsg')
        else:
          _v82.event_base_type = str[start:end]
        _v83 = val1.event_condition
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          _v83.vehicle_model = str[start:end].decode('utf-8', 'rosmsg')
        else:
          _v83.vehicle_model = str[start:end]
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          _v83.software_version = str[start:end].decode('utf-8', 'rosmsg')
        else:
          _v83.software_version = str[start:end]
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          _v83.hardware_version = str[start:end].decode('utf-8', 'rosmsg')
        else:
          _v83.hardware_version = str[start:end]
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          _v83.map_version = str[start:end].decode('utf-8', 'rosmsg')
        else:
          _v83.map_version = str[start:end]
        _v84 = _v83.event_gps
        _x = _v84
        start = end
        end += 16
        (_x.x, _x.y,) = _get_struct_2d().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          _v83.event_start_time = str[start:end].decode('utf-8', 'rosmsg')
        else:
          _v83.event_start_time = str[start:end]
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          _v83.event_end_time = str[start:end].decode('utf-8', 'rosmsg')
        else:
          _v83.event_end_time = str[start:end]
        _v85 = _v83.scenario_type
        _x = _v85
        start = end
        end += 8
        (_x.weather_type, _x.lighting_type,) = _get_struct_2i().unpack(str[start:end])
        start = end
        end += 4
        (_v83.driver_filter,) = _get_struct_i().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          _v83.range_start_time = str[start:end].decode('utf-8', 'rosmsg')
        else:
          _v83.range_start_time = str[start:end]
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          _v83.range_end_time = str[start:end].decode('utf-8', 'rosmsg')
        else:
          _v83.range_end_time = str[start:end]
        _v86 = val1.event_action
        start = end
        end += 4
        (_v86.ad_mode_type,) = _get_struct_i().unpack(str[start:end])
        _v87 = _v86.driving_action
        _v88 = _v87.action_rule
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v88.lane_seg_link = []
        for i in range(0, length):
          val5 = rospy_message_converter.msg.LaneSegLink()
          _x = val5
          start = end
          end += 8
          (_x.offset_start, _x.offset_end,) = _get_struct_2i().unpack(str[start:end])
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val5.lane_id = str[start:end].decode('utf-8', 'rosmsg')
          else:
            val5.lane_id = str[start:end]
          _v88.lane_seg_link.append(val5)
        _v89 = _v87.action_context
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v89.info_config = []
        for i in range(0, length):
          val5 = rospy_message_converter.msg.InfoConfig()
          _x = val5
          start = end
          end += 16
          (_x.info_value, _x.static_info, _x.dynamic_info, _x.road_scenario_type,) = _get_struct_4i().unpack(str[start:end])
          _v89.info_config.append(val5)
        _v90 = _v86.parking_action
        _v91 = _v90.action_rule
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          _v91.park_station_id = str[start:end].decode('utf-8', 'rosmsg')
        else:
          _v91.park_station_id = str[start:end]
        _v92 = _v91.park_lane_id
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          _v92.lane_id = str[start:end].decode('utf-8', 'rosmsg')
        else:
          _v92.lane_id = str[start:end]
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v92.lane_seg_link = []
        for i in range(0, length):
          val6 = rospy_message_converter.msg.LaneSegLink()
          _x = val6
          start = end
          end += 8
          (_x.offset_start, _x.offset_end,) = _get_struct_2i().unpack(str[start:end])
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val6.lane_id = str[start:end].decode('utf-8', 'rosmsg')
          else:
            val6.lane_id = str[start:end]
          _v92.lane_seg_link.append(val6)
        _v93 = _v90.action_context
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v93.info_config = []
        for i in range(0, length):
          val5 = rospy_message_converter.msg.InfoConfig()
          _x = val5
          start = end
          end += 16
          (_x.info_value, _x.static_info, _x.dynamic_info, _x.road_scenario_type,) = _get_struct_4i().unpack(str[start:end])
          _v93.info_config.append(val5)
        _v94 = _v86.dms_action
        _v95 = _v94.drowsiness_config
        _v96 = _v95.eye_config
        _x = _v96
        start = end
        end += 24
        (_x.perclos_light, _x.perclos_medium, _x.perclos_window_time,) = _get_struct_3d().unpack(str[start:end])
        _v97 = _v95.mouth_config
        _x = _v97
        start = end
        end += 16
        (_x.yawn_light, _x.yawn_medium, _x.yawn_windown_time,) = _get_struct_2id().unpack(str[start:end])
        _v98 = _v95.customized
        _x = _v98
        start = end
        end += 16
        (_x.eye_close_thr, _x.eye_open_thr,) = _get_struct_2d().unpack(str[start:end])
        _v99 = _v94.distraction_config
        _v100 = _v99.distraction_score_thr
        _x = _v100
        start = end
        end += 24
        (_x.distraction_light_thr, _x.distraction_medium_thr, _x.distraction_heavy_thr,) = _get_struct_3d().unpack(str[start:end])
        _v101 = _v99.distraction_rectangle
        _v102 = _v101.gaze_3D_point
        _v103 = _v102.X
        _x = _v103
        start = end
        end += 16
        (_x.min, _x.max,) = _get_struct_2d().unpack(str[start:end])
        _v104 = _v102.Y
        _x = _v104
        start = end
        end += 16
        (_x.min, _x.max,) = _get_struct_2d().unpack(str[start:end])
        _v105 = _v101.head_pose
        _v106 = _v105.yaw
        _x = _v106
        start = end
        end += 16
        (_x.min, _x.max,) = _get_struct_2d().unpack(str[start:end])
        _v107 = _v105.pitch
        _x = _v107
        start = end
        end += 16
        (_x.min, _x.max,) = _get_struct_2d().unpack(str[start:end])
        _v108 = _v105.roll
        _x = _v108
        start = end
        end += 16
        (_x.min, _x.max,) = _get_struct_2d().unpack(str[start:end])
        start = end
        end += 8
        (_v99.distraction_fast_fade_time,) = _get_struct_d().unpack(str[start:end])
        _x = _v94
        start = end
        end += 4
        (_x.DMSDistractionSwitch_cloud, _x.DMSDrowsinessSwitch_cloud_light, _x.DMSDrowsinessSwitch_cloud_medium, _x.DMSDrowsinessSwitch_cloud_heavy,) = _get_struct_4B().unpack(str[start:end])
        _v94.DMSDistractionSwitch_cloud = bool(_v94.DMSDistractionSwitch_cloud)
        _v94.DMSDrowsinessSwitch_cloud_light = bool(_v94.DMSDrowsinessSwitch_cloud_light)
        _v94.DMSDrowsinessSwitch_cloud_medium = bool(_v94.DMSDrowsinessSwitch_cloud_medium)
        _v94.DMSDrowsinessSwitch_cloud_heavy = bool(_v94.DMSDrowsinessSwitch_cloud_heavy)
        self.events.append(val1)
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill

_struct_I = genpy.struct_I
def _get_struct_I():
    global _struct_I
    return _struct_I
_struct_2d = None
def _get_struct_2d():
    global _struct_2d
    if _struct_2d is None:
        _struct_2d = struct.Struct("<2d")
    return _struct_2d
_struct_2i = None
def _get_struct_2i():
    global _struct_2i
    if _struct_2i is None:
        _struct_2i = struct.Struct("<2i")
    return _struct_2i
_struct_2id = None
def _get_struct_2id():
    global _struct_2id
    if _struct_2id is None:
        _struct_2id = struct.Struct("<2id")
    return _struct_2id
_struct_3d = None
def _get_struct_3d():
    global _struct_3d
    if _struct_3d is None:
        _struct_3d = struct.Struct("<3d")
    return _struct_3d
_struct_4B = None
def _get_struct_4B():
    global _struct_4B
    if _struct_4B is None:
        _struct_4B = struct.Struct("<4B")
    return _struct_4B
_struct_4i = None
def _get_struct_4i():
    global _struct_4i
    if _struct_4i is None:
        _struct_4i = struct.Struct("<4i")
    return _struct_4i
_struct_d = None
def _get_struct_d():
    global _struct_d
    if _struct_d is None:
        _struct_d = struct.Struct("<d")
    return _struct_d
_struct_i = None
def _get_struct_i():
    global _struct_i
    if _struct_i is None:
        _struct_i = struct.Struct("<i")
    return _struct_i
