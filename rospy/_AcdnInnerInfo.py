# This Python file uses the following encoding: utf-8
"""autogenerated by genpy from rospy_message_converter/AcdnInnerInfo.msg. Do not edit."""
import codecs
import sys
python3 = True if sys.hexversion > 0x03000000 else False
import genpy
import struct

import rospy_message_converter.msg

class AcdnInnerInfo(genpy.Message):
  _md5sum = "c2ae15ce00150983ca963b5c5518d29c"
  _type = "rospy_message_converter/AcdnInnerInfo"
  _has_header = False  # flag to mark the presence of a Header object
  _full_text = """float32 thdFcwTtcCompens
bool isSafeDistance
bool isSafeLgtRelSpd
bool isSafeLgtRelAcc
bool dangerRelease
float32 objLongDistCorr
uint32 fcwCodeWord
uint32 aebCodeWord
float32 crvtReqdLe
float32 crvtReqdRi
float32 driverCapCrvtCmfLe
float32 driverCapCrvtCmfRi
float32 driverCapCrvtMaxLe
float32 driverCapCrvtMaxRi
uint32 oldGearAct
float32 objLatDistGap
float32 flgLatEscapeLe
float32 flgLatEscapeRi
float32 isProceedDangerRelease
float32[] floatAcdnInnerReserve
uint32[] intAcdnInnerReserve
bool[] boolAcdnInnerReserve
DrilInnerInfo drilInnerInfo
HooaInnerInfo hooaInnerInfo
float32 aFcwALatCritByDrvr
float32 crvtFcwALatCritByDrvrThd
float32 tTtcFcwTriger
float32 facDriverIntvFcw
bool isHeadOnObjTrjOverlap

================================================================================
MSG: rospy_message_converter/DrilInnerInfo
DriverAction driverAction
float32 dirverIntvFactor
float32 dirverStrFactor
bool isDirverFocuseOnMaxDelay
bool isDriverAcc2Overtake
bool isDriverAvoidanceObj
bool isDriverChgPedlAct
bool isDriverDecelAvoid
bool isDriverTurnning
DriAvdObjInfo driAvdObjInfo

================================================================================
MSG: rospy_message_converter/DriverAction
bool isObjChange
bool isDriverStrAction
bool isDriAccPedalAction

================================================================================
MSG: rospy_message_converter/DriAvdObjInfo
bool objCrvtAbsReqLeBigger
float32 objCrvtAbsReqLe
float32 objCrvtAbsReqRi

================================================================================
MSG: rospy_message_converter/HooaInnerInfo
float32[] floatHooaInnerReserve
uint32[] intHooaInnerReserve
bool[] boolHooaInnerReserve
"""
  __slots__ = ['thdFcwTtcCompens','isSafeDistance','isSafeLgtRelSpd','isSafeLgtRelAcc','dangerRelease','objLongDistCorr','fcwCodeWord','aebCodeWord','crvtReqdLe','crvtReqdRi','driverCapCrvtCmfLe','driverCapCrvtCmfRi','driverCapCrvtMaxLe','driverCapCrvtMaxRi','oldGearAct','objLatDistGap','flgLatEscapeLe','flgLatEscapeRi','isProceedDangerRelease','floatAcdnInnerReserve','intAcdnInnerReserve','boolAcdnInnerReserve','drilInnerInfo','hooaInnerInfo','aFcwALatCritByDrvr','crvtFcwALatCritByDrvrThd','tTtcFcwTriger','facDriverIntvFcw','isHeadOnObjTrjOverlap']
  _slot_types = ['float32','bool','bool','bool','bool','float32','uint32','uint32','float32','float32','float32','float32','float32','float32','uint32','float32','float32','float32','float32','float32[]','uint32[]','bool[]','rospy_message_converter/DrilInnerInfo','rospy_message_converter/HooaInnerInfo','float32','float32','float32','float32','bool']

  def __init__(self, *args, **kwds):
    """
    Constructor. Any message fields that are implicitly/explicitly
    set to None will be assigned a default value. The recommend
    use is keyword arguments as this is more robust to future message
    changes.  You cannot mix in-order arguments and keyword arguments.

    The available fields are:
       thdFcwTtcCompens,isSafeDistance,isSafeLgtRelSpd,isSafeLgtRelAcc,dangerRelease,objLongDistCorr,fcwCodeWord,aebCodeWord,crvtReqdLe,crvtReqdRi,driverCapCrvtCmfLe,driverCapCrvtCmfRi,driverCapCrvtMaxLe,driverCapCrvtMaxRi,oldGearAct,objLatDistGap,flgLatEscapeLe,flgLatEscapeRi,isProceedDangerRelease,floatAcdnInnerReserve,intAcdnInnerReserve,boolAcdnInnerReserve,drilInnerInfo,hooaInnerInfo,aFcwALatCritByDrvr,crvtFcwALatCritByDrvrThd,tTtcFcwTriger,facDriverIntvFcw,isHeadOnObjTrjOverlap

    :param args: complete set of field values, in .msg order
    :param kwds: use keyword arguments corresponding to message field names
    to set specific fields.
    """
    if args or kwds:
      super(AcdnInnerInfo, self).__init__(*args, **kwds)
      # message fields cannot be None, assign default values for those that are
      if self.thdFcwTtcCompens is None:
        self.thdFcwTtcCompens = 0.
      if self.isSafeDistance is None:
        self.isSafeDistance = False
      if self.isSafeLgtRelSpd is None:
        self.isSafeLgtRelSpd = False
      if self.isSafeLgtRelAcc is None:
        self.isSafeLgtRelAcc = False
      if self.dangerRelease is None:
        self.dangerRelease = False
      if self.objLongDistCorr is None:
        self.objLongDistCorr = 0.
      if self.fcwCodeWord is None:
        self.fcwCodeWord = 0
      if self.aebCodeWord is None:
        self.aebCodeWord = 0
      if self.crvtReqdLe is None:
        self.crvtReqdLe = 0.
      if self.crvtReqdRi is None:
        self.crvtReqdRi = 0.
      if self.driverCapCrvtCmfLe is None:
        self.driverCapCrvtCmfLe = 0.
      if self.driverCapCrvtCmfRi is None:
        self.driverCapCrvtCmfRi = 0.
      if self.driverCapCrvtMaxLe is None:
        self.driverCapCrvtMaxLe = 0.
      if self.driverCapCrvtMaxRi is None:
        self.driverCapCrvtMaxRi = 0.
      if self.oldGearAct is None:
        self.oldGearAct = 0
      if self.objLatDistGap is None:
        self.objLatDistGap = 0.
      if self.flgLatEscapeLe is None:
        self.flgLatEscapeLe = 0.
      if self.flgLatEscapeRi is None:
        self.flgLatEscapeRi = 0.
      if self.isProceedDangerRelease is None:
        self.isProceedDangerRelease = 0.
      if self.floatAcdnInnerReserve is None:
        self.floatAcdnInnerReserve = []
      if self.intAcdnInnerReserve is None:
        self.intAcdnInnerReserve = []
      if self.boolAcdnInnerReserve is None:
        self.boolAcdnInnerReserve = []
      if self.drilInnerInfo is None:
        self.drilInnerInfo = rospy_message_converter.msg.DrilInnerInfo()
      if self.hooaInnerInfo is None:
        self.hooaInnerInfo = rospy_message_converter.msg.HooaInnerInfo()
      if self.aFcwALatCritByDrvr is None:
        self.aFcwALatCritByDrvr = 0.
      if self.crvtFcwALatCritByDrvrThd is None:
        self.crvtFcwALatCritByDrvrThd = 0.
      if self.tTtcFcwTriger is None:
        self.tTtcFcwTriger = 0.
      if self.facDriverIntvFcw is None:
        self.facDriverIntvFcw = 0.
      if self.isHeadOnObjTrjOverlap is None:
        self.isHeadOnObjTrjOverlap = False
    else:
      self.thdFcwTtcCompens = 0.
      self.isSafeDistance = False
      self.isSafeLgtRelSpd = False
      self.isSafeLgtRelAcc = False
      self.dangerRelease = False
      self.objLongDistCorr = 0.
      self.fcwCodeWord = 0
      self.aebCodeWord = 0
      self.crvtReqdLe = 0.
      self.crvtReqdRi = 0.
      self.driverCapCrvtCmfLe = 0.
      self.driverCapCrvtCmfRi = 0.
      self.driverCapCrvtMaxLe = 0.
      self.driverCapCrvtMaxRi = 0.
      self.oldGearAct = 0
      self.objLatDistGap = 0.
      self.flgLatEscapeLe = 0.
      self.flgLatEscapeRi = 0.
      self.isProceedDangerRelease = 0.
      self.floatAcdnInnerReserve = []
      self.intAcdnInnerReserve = []
      self.boolAcdnInnerReserve = []
      self.drilInnerInfo = rospy_message_converter.msg.DrilInnerInfo()
      self.hooaInnerInfo = rospy_message_converter.msg.HooaInnerInfo()
      self.aFcwALatCritByDrvr = 0.
      self.crvtFcwALatCritByDrvrThd = 0.
      self.tTtcFcwTriger = 0.
      self.facDriverIntvFcw = 0.
      self.isHeadOnObjTrjOverlap = False

  def _get_types(self):
    """
    internal API method
    """
    return self._slot_types

  def serialize(self, buff):
    """
    serialize message into buffer
    :param buff: buffer, ``StringIO``
    """
    try:
      _x = self
      buff.write(_get_struct_f4Bf2I6fI4f().pack(_x.thdFcwTtcCompens, _x.isSafeDistance, _x.isSafeLgtRelSpd, _x.isSafeLgtRelAcc, _x.dangerRelease, _x.objLongDistCorr, _x.fcwCodeWord, _x.aebCodeWord, _x.crvtReqdLe, _x.crvtReqdRi, _x.driverCapCrvtCmfLe, _x.driverCapCrvtCmfRi, _x.driverCapCrvtMaxLe, _x.driverCapCrvtMaxRi, _x.oldGearAct, _x.objLatDistGap, _x.flgLatEscapeLe, _x.flgLatEscapeRi, _x.isProceedDangerRelease))
      length = len(self.floatAcdnInnerReserve)
      buff.write(_struct_I.pack(length))
      pattern = '<%sf'%length
      buff.write(struct.Struct(pattern).pack(*self.floatAcdnInnerReserve))
      length = len(self.intAcdnInnerReserve)
      buff.write(_struct_I.pack(length))
      pattern = '<%sI'%length
      buff.write(struct.Struct(pattern).pack(*self.intAcdnInnerReserve))
      length = len(self.boolAcdnInnerReserve)
      buff.write(_struct_I.pack(length))
      pattern = '<%sB'%length
      buff.write(struct.Struct(pattern).pack(*self.boolAcdnInnerReserve))
      _x = self
      buff.write(_get_struct_3B2f7B2f().pack(_x.drilInnerInfo.driverAction.isObjChange, _x.drilInnerInfo.driverAction.isDriverStrAction, _x.drilInnerInfo.driverAction.isDriAccPedalAction, _x.drilInnerInfo.dirverIntvFactor, _x.drilInnerInfo.dirverStrFactor, _x.drilInnerInfo.isDirverFocuseOnMaxDelay, _x.drilInnerInfo.isDriverAcc2Overtake, _x.drilInnerInfo.isDriverAvoidanceObj, _x.drilInnerInfo.isDriverChgPedlAct, _x.drilInnerInfo.isDriverDecelAvoid, _x.drilInnerInfo.isDriverTurnning, _x.drilInnerInfo.driAvdObjInfo.objCrvtAbsReqLeBigger, _x.drilInnerInfo.driAvdObjInfo.objCrvtAbsReqLe, _x.drilInnerInfo.driAvdObjInfo.objCrvtAbsReqRi))
      length = len(self.hooaInnerInfo.floatHooaInnerReserve)
      buff.write(_struct_I.pack(length))
      pattern = '<%sf'%length
      buff.write(struct.Struct(pattern).pack(*self.hooaInnerInfo.floatHooaInnerReserve))
      length = len(self.hooaInnerInfo.intHooaInnerReserve)
      buff.write(_struct_I.pack(length))
      pattern = '<%sI'%length
      buff.write(struct.Struct(pattern).pack(*self.hooaInnerInfo.intHooaInnerReserve))
      length = len(self.hooaInnerInfo.boolHooaInnerReserve)
      buff.write(_struct_I.pack(length))
      pattern = '<%sB'%length
      buff.write(struct.Struct(pattern).pack(*self.hooaInnerInfo.boolHooaInnerReserve))
      _x = self
      buff.write(_get_struct_4fB().pack(_x.aFcwALatCritByDrvr, _x.crvtFcwALatCritByDrvrThd, _x.tTtcFcwTriger, _x.facDriverIntvFcw, _x.isHeadOnObjTrjOverlap))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize(self, str):
    """
    unpack serialized message in str into this message instance
    :param str: byte array of serialized message, ``str``
    """
    if python3:
      codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      if self.drilInnerInfo is None:
        self.drilInnerInfo = rospy_message_converter.msg.DrilInnerInfo()
      if self.hooaInnerInfo is None:
        self.hooaInnerInfo = rospy_message_converter.msg.HooaInnerInfo()
      end = 0
      _x = self
      start = end
      end += 64
      (_x.thdFcwTtcCompens, _x.isSafeDistance, _x.isSafeLgtRelSpd, _x.isSafeLgtRelAcc, _x.dangerRelease, _x.objLongDistCorr, _x.fcwCodeWord, _x.aebCodeWord, _x.crvtReqdLe, _x.crvtReqdRi, _x.driverCapCrvtCmfLe, _x.driverCapCrvtCmfRi, _x.driverCapCrvtMaxLe, _x.driverCapCrvtMaxRi, _x.oldGearAct, _x.objLatDistGap, _x.flgLatEscapeLe, _x.flgLatEscapeRi, _x.isProceedDangerRelease,) = _get_struct_f4Bf2I6fI4f().unpack(str[start:end])
      self.isSafeDistance = bool(self.isSafeDistance)
      self.isSafeLgtRelSpd = bool(self.isSafeLgtRelSpd)
      self.isSafeLgtRelAcc = bool(self.isSafeLgtRelAcc)
      self.dangerRelease = bool(self.dangerRelease)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sf'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.floatAcdnInnerReserve = s.unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sI'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.intAcdnInnerReserve = s.unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sB'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.boolAcdnInnerReserve = s.unpack(str[start:end])
      self.boolAcdnInnerReserve = list(map(bool, self.boolAcdnInnerReserve))
      _x = self
      start = end
      end += 26
      (_x.drilInnerInfo.driverAction.isObjChange, _x.drilInnerInfo.driverAction.isDriverStrAction, _x.drilInnerInfo.driverAction.isDriAccPedalAction, _x.drilInnerInfo.dirverIntvFactor, _x.drilInnerInfo.dirverStrFactor, _x.drilInnerInfo.isDirverFocuseOnMaxDelay, _x.drilInnerInfo.isDriverAcc2Overtake, _x.drilInnerInfo.isDriverAvoidanceObj, _x.drilInnerInfo.isDriverChgPedlAct, _x.drilInnerInfo.isDriverDecelAvoid, _x.drilInnerInfo.isDriverTurnning, _x.drilInnerInfo.driAvdObjInfo.objCrvtAbsReqLeBigger, _x.drilInnerInfo.driAvdObjInfo.objCrvtAbsReqLe, _x.drilInnerInfo.driAvdObjInfo.objCrvtAbsReqRi,) = _get_struct_3B2f7B2f().unpack(str[start:end])
      self.drilInnerInfo.driverAction.isObjChange = bool(self.drilInnerInfo.driverAction.isObjChange)
      self.drilInnerInfo.driverAction.isDriverStrAction = bool(self.drilInnerInfo.driverAction.isDriverStrAction)
      self.drilInnerInfo.driverAction.isDriAccPedalAction = bool(self.drilInnerInfo.driverAction.isDriAccPedalAction)
      self.drilInnerInfo.isDirverFocuseOnMaxDelay = bool(self.drilInnerInfo.isDirverFocuseOnMaxDelay)
      self.drilInnerInfo.isDriverAcc2Overtake = bool(self.drilInnerInfo.isDriverAcc2Overtake)
      self.drilInnerInfo.isDriverAvoidanceObj = bool(self.drilInnerInfo.isDriverAvoidanceObj)
      self.drilInnerInfo.isDriverChgPedlAct = bool(self.drilInnerInfo.isDriverChgPedlAct)
      self.drilInnerInfo.isDriverDecelAvoid = bool(self.drilInnerInfo.isDriverDecelAvoid)
      self.drilInnerInfo.isDriverTurnning = bool(self.drilInnerInfo.isDriverTurnning)
      self.drilInnerInfo.driAvdObjInfo.objCrvtAbsReqLeBigger = bool(self.drilInnerInfo.driAvdObjInfo.objCrvtAbsReqLeBigger)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sf'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.hooaInnerInfo.floatHooaInnerReserve = s.unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sI'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.hooaInnerInfo.intHooaInnerReserve = s.unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sB'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.hooaInnerInfo.boolHooaInnerReserve = s.unpack(str[start:end])
      self.hooaInnerInfo.boolHooaInnerReserve = list(map(bool, self.hooaInnerInfo.boolHooaInnerReserve))
      _x = self
      start = end
      end += 17
      (_x.aFcwALatCritByDrvr, _x.crvtFcwALatCritByDrvrThd, _x.tTtcFcwTriger, _x.facDriverIntvFcw, _x.isHeadOnObjTrjOverlap,) = _get_struct_4fB().unpack(str[start:end])
      self.isHeadOnObjTrjOverlap = bool(self.isHeadOnObjTrjOverlap)
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill


  def serialize_numpy(self, buff, numpy):
    """
    serialize message with numpy array types into buffer
    :param buff: buffer, ``StringIO``
    :param numpy: numpy python module
    """
    try:
      _x = self
      buff.write(_get_struct_f4Bf2I6fI4f().pack(_x.thdFcwTtcCompens, _x.isSafeDistance, _x.isSafeLgtRelSpd, _x.isSafeLgtRelAcc, _x.dangerRelease, _x.objLongDistCorr, _x.fcwCodeWord, _x.aebCodeWord, _x.crvtReqdLe, _x.crvtReqdRi, _x.driverCapCrvtCmfLe, _x.driverCapCrvtCmfRi, _x.driverCapCrvtMaxLe, _x.driverCapCrvtMaxRi, _x.oldGearAct, _x.objLatDistGap, _x.flgLatEscapeLe, _x.flgLatEscapeRi, _x.isProceedDangerRelease))
      length = len(self.floatAcdnInnerReserve)
      buff.write(_struct_I.pack(length))
      pattern = '<%sf'%length
      buff.write(self.floatAcdnInnerReserve.tostring())
      length = len(self.intAcdnInnerReserve)
      buff.write(_struct_I.pack(length))
      pattern = '<%sI'%length
      buff.write(self.intAcdnInnerReserve.tostring())
      length = len(self.boolAcdnInnerReserve)
      buff.write(_struct_I.pack(length))
      pattern = '<%sB'%length
      buff.write(self.boolAcdnInnerReserve.tostring())
      _x = self
      buff.write(_get_struct_3B2f7B2f().pack(_x.drilInnerInfo.driverAction.isObjChange, _x.drilInnerInfo.driverAction.isDriverStrAction, _x.drilInnerInfo.driverAction.isDriAccPedalAction, _x.drilInnerInfo.dirverIntvFactor, _x.drilInnerInfo.dirverStrFactor, _x.drilInnerInfo.isDirverFocuseOnMaxDelay, _x.drilInnerInfo.isDriverAcc2Overtake, _x.drilInnerInfo.isDriverAvoidanceObj, _x.drilInnerInfo.isDriverChgPedlAct, _x.drilInnerInfo.isDriverDecelAvoid, _x.drilInnerInfo.isDriverTurnning, _x.drilInnerInfo.driAvdObjInfo.objCrvtAbsReqLeBigger, _x.drilInnerInfo.driAvdObjInfo.objCrvtAbsReqLe, _x.drilInnerInfo.driAvdObjInfo.objCrvtAbsReqRi))
      length = len(self.hooaInnerInfo.floatHooaInnerReserve)
      buff.write(_struct_I.pack(length))
      pattern = '<%sf'%length
      buff.write(self.hooaInnerInfo.floatHooaInnerReserve.tostring())
      length = len(self.hooaInnerInfo.intHooaInnerReserve)
      buff.write(_struct_I.pack(length))
      pattern = '<%sI'%length
      buff.write(self.hooaInnerInfo.intHooaInnerReserve.tostring())
      length = len(self.hooaInnerInfo.boolHooaInnerReserve)
      buff.write(_struct_I.pack(length))
      pattern = '<%sB'%length
      buff.write(self.hooaInnerInfo.boolHooaInnerReserve.tostring())
      _x = self
      buff.write(_get_struct_4fB().pack(_x.aFcwALatCritByDrvr, _x.crvtFcwALatCritByDrvrThd, _x.tTtcFcwTriger, _x.facDriverIntvFcw, _x.isHeadOnObjTrjOverlap))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize_numpy(self, str, numpy):
    """
    unpack serialized message in str into this message instance using numpy for array types
    :param str: byte array of serialized message, ``str``
    :param numpy: numpy python module
    """
    if python3:
      codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      if self.drilInnerInfo is None:
        self.drilInnerInfo = rospy_message_converter.msg.DrilInnerInfo()
      if self.hooaInnerInfo is None:
        self.hooaInnerInfo = rospy_message_converter.msg.HooaInnerInfo()
      end = 0
      _x = self
      start = end
      end += 64
      (_x.thdFcwTtcCompens, _x.isSafeDistance, _x.isSafeLgtRelSpd, _x.isSafeLgtRelAcc, _x.dangerRelease, _x.objLongDistCorr, _x.fcwCodeWord, _x.aebCodeWord, _x.crvtReqdLe, _x.crvtReqdRi, _x.driverCapCrvtCmfLe, _x.driverCapCrvtCmfRi, _x.driverCapCrvtMaxLe, _x.driverCapCrvtMaxRi, _x.oldGearAct, _x.objLatDistGap, _x.flgLatEscapeLe, _x.flgLatEscapeRi, _x.isProceedDangerRelease,) = _get_struct_f4Bf2I6fI4f().unpack(str[start:end])
      self.isSafeDistance = bool(self.isSafeDistance)
      self.isSafeLgtRelSpd = bool(self.isSafeLgtRelSpd)
      self.isSafeLgtRelAcc = bool(self.isSafeLgtRelAcc)
      self.dangerRelease = bool(self.dangerRelease)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sf'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.floatAcdnInnerReserve = numpy.frombuffer(str[start:end], dtype=numpy.float32, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sI'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.intAcdnInnerReserve = numpy.frombuffer(str[start:end], dtype=numpy.uint32, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sB'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.boolAcdnInnerReserve = numpy.frombuffer(str[start:end], dtype=numpy.bool, count=length)
      self.boolAcdnInnerReserve = list(map(bool, self.boolAcdnInnerReserve))
      _x = self
      start = end
      end += 26
      (_x.drilInnerInfo.driverAction.isObjChange, _x.drilInnerInfo.driverAction.isDriverStrAction, _x.drilInnerInfo.driverAction.isDriAccPedalAction, _x.drilInnerInfo.dirverIntvFactor, _x.drilInnerInfo.dirverStrFactor, _x.drilInnerInfo.isDirverFocuseOnMaxDelay, _x.drilInnerInfo.isDriverAcc2Overtake, _x.drilInnerInfo.isDriverAvoidanceObj, _x.drilInnerInfo.isDriverChgPedlAct, _x.drilInnerInfo.isDriverDecelAvoid, _x.drilInnerInfo.isDriverTurnning, _x.drilInnerInfo.driAvdObjInfo.objCrvtAbsReqLeBigger, _x.drilInnerInfo.driAvdObjInfo.objCrvtAbsReqLe, _x.drilInnerInfo.driAvdObjInfo.objCrvtAbsReqRi,) = _get_struct_3B2f7B2f().unpack(str[start:end])
      self.drilInnerInfo.driverAction.isObjChange = bool(self.drilInnerInfo.driverAction.isObjChange)
      self.drilInnerInfo.driverAction.isDriverStrAction = bool(self.drilInnerInfo.driverAction.isDriverStrAction)
      self.drilInnerInfo.driverAction.isDriAccPedalAction = bool(self.drilInnerInfo.driverAction.isDriAccPedalAction)
      self.drilInnerInfo.isDirverFocuseOnMaxDelay = bool(self.drilInnerInfo.isDirverFocuseOnMaxDelay)
      self.drilInnerInfo.isDriverAcc2Overtake = bool(self.drilInnerInfo.isDriverAcc2Overtake)
      self.drilInnerInfo.isDriverAvoidanceObj = bool(self.drilInnerInfo.isDriverAvoidanceObj)
      self.drilInnerInfo.isDriverChgPedlAct = bool(self.drilInnerInfo.isDriverChgPedlAct)
      self.drilInnerInfo.isDriverDecelAvoid = bool(self.drilInnerInfo.isDriverDecelAvoid)
      self.drilInnerInfo.isDriverTurnning = bool(self.drilInnerInfo.isDriverTurnning)
      self.drilInnerInfo.driAvdObjInfo.objCrvtAbsReqLeBigger = bool(self.drilInnerInfo.driAvdObjInfo.objCrvtAbsReqLeBigger)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sf'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.hooaInnerInfo.floatHooaInnerReserve = numpy.frombuffer(str[start:end], dtype=numpy.float32, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sI'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.hooaInnerInfo.intHooaInnerReserve = numpy.frombuffer(str[start:end], dtype=numpy.uint32, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sB'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.hooaInnerInfo.boolHooaInnerReserve = numpy.frombuffer(str[start:end], dtype=numpy.bool, count=length)
      self.hooaInnerInfo.boolHooaInnerReserve = list(map(bool, self.hooaInnerInfo.boolHooaInnerReserve))
      _x = self
      start = end
      end += 17
      (_x.aFcwALatCritByDrvr, _x.crvtFcwALatCritByDrvrThd, _x.tTtcFcwTriger, _x.facDriverIntvFcw, _x.isHeadOnObjTrjOverlap,) = _get_struct_4fB().unpack(str[start:end])
      self.isHeadOnObjTrjOverlap = bool(self.isHeadOnObjTrjOverlap)
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill

_struct_I = genpy.struct_I
def _get_struct_I():
    global _struct_I
    return _struct_I
_struct_3B2f7B2f = None
def _get_struct_3B2f7B2f():
    global _struct_3B2f7B2f
    if _struct_3B2f7B2f is None:
        _struct_3B2f7B2f = struct.Struct("<3B2f7B2f")
    return _struct_3B2f7B2f
_struct_4fB = None
def _get_struct_4fB():
    global _struct_4fB
    if _struct_4fB is None:
        _struct_4fB = struct.Struct("<4fB")
    return _struct_4fB
_struct_f4Bf2I6fI4f = None
def _get_struct_f4Bf2I6fI4f():
    global _struct_f4Bf2I6fI4f
    if _struct_f4Bf2I6fI4f is None:
        _struct_f4Bf2I6fI4f = struct.Struct("<f4Bf2I6fI4f")
    return _struct_f4Bf2I6fI4f
