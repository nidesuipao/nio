# This Python file uses the following encoding: utf-8
"""autogenerated by genpy from rospy_message_converter/esd_np_feature.msg. Do not edit."""
import codecs
import sys
python3 = True if sys.hexversion > 0x03000000 else False
import genpy
import struct

import rospy_message_converter.msg

class esd_np_feature(genpy.Message):
  _md5sum = "85c1409298975075bb39024e6d456147"
  _type = "rospy_message_converter/esd_np_feature"
  _has_header = False  # flag to mark the presence of a Header object
  _full_text = """esd_np_line[] esd_np_Line
esd_np_object[] esd_np_Object
esd_np_path esd_np_Path
esd_np_alc esd_np_Alc
uint32 esd_nop_distance_to_Odd_boundary
esd_aeb_object[] esd_aeb_obj
esd_nop_path esd_nop_Path
bool esd_nop_switch
uint64 esd_nop_time_meas
string publisher_id
uint64 publish_ptp_ts
uint64 counter
uint64 publish_ts

================================================================================
MSG: rospy_message_converter/esd_np_line
uint64 esd_np_line_role
uint64 esd_np_line_ld_level
uint64 esd_np_line_ldw_level

================================================================================
MSG: rospy_message_converter/esd_np_object
uint64 esd_np_obj_id
uint64 esd_np_obj_level
uint64 esd_np_obj_da
uint64 esd_np_obj_elk

================================================================================
MSG: rospy_message_converter/esd_np_path
float32 esd_np_path_c0
float32 esd_np_path_c1
float32 esd_np_path_c2
float32 esd_np_path_c3
float32 esd_np_path_c4
float32 esd_np_path_c5
float32 esd_np_path_end
bool esd_np_enable

================================================================================
MSG: rospy_message_converter/esd_np_alc
uint64 esd_np_alc_crossing
uint64 esd_np_alc_sts
uint32 esd_laneChngIntent
bool esd_crossed_left_lane
bool esd_crossed_right_lane

================================================================================
MSG: rospy_message_converter/esd_aeb_object
uint32 esd_aeb_obj_id
uint32 esd_aeb_obj_func

================================================================================
MSG: rospy_message_converter/esd_nop_path
esd_nop_path_point[] esd_nop_path_points
float32 esd_nop_discrete_path_length
bool esd_nop_discrete_path_enable

================================================================================
MSG: rospy_message_converter/esd_nop_path_point
float32 x
float32 y
float32 z
"""
  __slots__ = ['esd_np_Line','esd_np_Object','esd_np_Path','esd_np_Alc','esd_nop_distance_to_Odd_boundary','esd_aeb_obj','esd_nop_Path','esd_nop_switch','esd_nop_time_meas','publisher_id','publish_ptp_ts','counter','publish_ts']
  _slot_types = ['rospy_message_converter/esd_np_line[]','rospy_message_converter/esd_np_object[]','rospy_message_converter/esd_np_path','rospy_message_converter/esd_np_alc','uint32','rospy_message_converter/esd_aeb_object[]','rospy_message_converter/esd_nop_path','bool','uint64','string','uint64','uint64','uint64']

  def __init__(self, *args, **kwds):
    """
    Constructor. Any message fields that are implicitly/explicitly
    set to None will be assigned a default value. The recommend
    use is keyword arguments as this is more robust to future message
    changes.  You cannot mix in-order arguments and keyword arguments.

    The available fields are:
       esd_np_Line,esd_np_Object,esd_np_Path,esd_np_Alc,esd_nop_distance_to_Odd_boundary,esd_aeb_obj,esd_nop_Path,esd_nop_switch,esd_nop_time_meas,publisher_id,publish_ptp_ts,counter,publish_ts

    :param args: complete set of field values, in .msg order
    :param kwds: use keyword arguments corresponding to message field names
    to set specific fields.
    """
    if args or kwds:
      super(esd_np_feature, self).__init__(*args, **kwds)
      # message fields cannot be None, assign default values for those that are
      if self.esd_np_Line is None:
        self.esd_np_Line = []
      if self.esd_np_Object is None:
        self.esd_np_Object = []
      if self.esd_np_Path is None:
        self.esd_np_Path = rospy_message_converter.msg.esd_np_path()
      if self.esd_np_Alc is None:
        self.esd_np_Alc = rospy_message_converter.msg.esd_np_alc()
      if self.esd_nop_distance_to_Odd_boundary is None:
        self.esd_nop_distance_to_Odd_boundary = 0
      if self.esd_aeb_obj is None:
        self.esd_aeb_obj = []
      if self.esd_nop_Path is None:
        self.esd_nop_Path = rospy_message_converter.msg.esd_nop_path()
      if self.esd_nop_switch is None:
        self.esd_nop_switch = False
      if self.esd_nop_time_meas is None:
        self.esd_nop_time_meas = 0
      if self.publisher_id is None:
        self.publisher_id = ''
      if self.publish_ptp_ts is None:
        self.publish_ptp_ts = 0
      if self.counter is None:
        self.counter = 0
      if self.publish_ts is None:
        self.publish_ts = 0
    else:
      self.esd_np_Line = []
      self.esd_np_Object = []
      self.esd_np_Path = rospy_message_converter.msg.esd_np_path()
      self.esd_np_Alc = rospy_message_converter.msg.esd_np_alc()
      self.esd_nop_distance_to_Odd_boundary = 0
      self.esd_aeb_obj = []
      self.esd_nop_Path = rospy_message_converter.msg.esd_nop_path()
      self.esd_nop_switch = False
      self.esd_nop_time_meas = 0
      self.publisher_id = ''
      self.publish_ptp_ts = 0
      self.counter = 0
      self.publish_ts = 0

  def _get_types(self):
    """
    internal API method
    """
    return self._slot_types

  def serialize(self, buff):
    """
    serialize message into buffer
    :param buff: buffer, ``StringIO``
    """
    try:
      length = len(self.esd_np_Line)
      buff.write(_struct_I.pack(length))
      for val1 in self.esd_np_Line:
        _x = val1
        buff.write(_get_struct_3Q().pack(_x.esd_np_line_role, _x.esd_np_line_ld_level, _x.esd_np_line_ldw_level))
      length = len(self.esd_np_Object)
      buff.write(_struct_I.pack(length))
      for val1 in self.esd_np_Object:
        _x = val1
        buff.write(_get_struct_4Q().pack(_x.esd_np_obj_id, _x.esd_np_obj_level, _x.esd_np_obj_da, _x.esd_np_obj_elk))
      _x = self
      buff.write(_get_struct_7fB2QI2BI().pack(_x.esd_np_Path.esd_np_path_c0, _x.esd_np_Path.esd_np_path_c1, _x.esd_np_Path.esd_np_path_c2, _x.esd_np_Path.esd_np_path_c3, _x.esd_np_Path.esd_np_path_c4, _x.esd_np_Path.esd_np_path_c5, _x.esd_np_Path.esd_np_path_end, _x.esd_np_Path.esd_np_enable, _x.esd_np_Alc.esd_np_alc_crossing, _x.esd_np_Alc.esd_np_alc_sts, _x.esd_np_Alc.esd_laneChngIntent, _x.esd_np_Alc.esd_crossed_left_lane, _x.esd_np_Alc.esd_crossed_right_lane, _x.esd_nop_distance_to_Odd_boundary))
      length = len(self.esd_aeb_obj)
      buff.write(_struct_I.pack(length))
      for val1 in self.esd_aeb_obj:
        _x = val1
        buff.write(_get_struct_2I().pack(_x.esd_aeb_obj_id, _x.esd_aeb_obj_func))
      length = len(self.esd_nop_Path.esd_nop_path_points)
      buff.write(_struct_I.pack(length))
      for val1 in self.esd_nop_Path.esd_nop_path_points:
        _x = val1
        buff.write(_get_struct_3f().pack(_x.x, _x.y, _x.z))
      _x = self
      buff.write(_get_struct_f2BQ().pack(_x.esd_nop_Path.esd_nop_discrete_path_length, _x.esd_nop_Path.esd_nop_discrete_path_enable, _x.esd_nop_switch, _x.esd_nop_time_meas))
      _x = self.publisher_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self
      buff.write(_get_struct_3Q().pack(_x.publish_ptp_ts, _x.counter, _x.publish_ts))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize(self, str):
    """
    unpack serialized message in str into this message instance
    :param str: byte array of serialized message, ``str``
    """
    if python3:
      codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      if self.esd_np_Line is None:
        self.esd_np_Line = None
      if self.esd_np_Object is None:
        self.esd_np_Object = None
      if self.esd_np_Path is None:
        self.esd_np_Path = rospy_message_converter.msg.esd_np_path()
      if self.esd_np_Alc is None:
        self.esd_np_Alc = rospy_message_converter.msg.esd_np_alc()
      if self.esd_aeb_obj is None:
        self.esd_aeb_obj = None
      if self.esd_nop_Path is None:
        self.esd_nop_Path = rospy_message_converter.msg.esd_nop_path()
      end = 0
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.esd_np_Line = []
      for i in range(0, length):
        val1 = rospy_message_converter.msg.esd_np_line()
        _x = val1
        start = end
        end += 24
        (_x.esd_np_line_role, _x.esd_np_line_ld_level, _x.esd_np_line_ldw_level,) = _get_struct_3Q().unpack(str[start:end])
        self.esd_np_Line.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.esd_np_Object = []
      for i in range(0, length):
        val1 = rospy_message_converter.msg.esd_np_object()
        _x = val1
        start = end
        end += 32
        (_x.esd_np_obj_id, _x.esd_np_obj_level, _x.esd_np_obj_da, _x.esd_np_obj_elk,) = _get_struct_4Q().unpack(str[start:end])
        self.esd_np_Object.append(val1)
      _x = self
      start = end
      end += 55
      (_x.esd_np_Path.esd_np_path_c0, _x.esd_np_Path.esd_np_path_c1, _x.esd_np_Path.esd_np_path_c2, _x.esd_np_Path.esd_np_path_c3, _x.esd_np_Path.esd_np_path_c4, _x.esd_np_Path.esd_np_path_c5, _x.esd_np_Path.esd_np_path_end, _x.esd_np_Path.esd_np_enable, _x.esd_np_Alc.esd_np_alc_crossing, _x.esd_np_Alc.esd_np_alc_sts, _x.esd_np_Alc.esd_laneChngIntent, _x.esd_np_Alc.esd_crossed_left_lane, _x.esd_np_Alc.esd_crossed_right_lane, _x.esd_nop_distance_to_Odd_boundary,) = _get_struct_7fB2QI2BI().unpack(str[start:end])
      self.esd_np_Path.esd_np_enable = bool(self.esd_np_Path.esd_np_enable)
      self.esd_np_Alc.esd_crossed_left_lane = bool(self.esd_np_Alc.esd_crossed_left_lane)
      self.esd_np_Alc.esd_crossed_right_lane = bool(self.esd_np_Alc.esd_crossed_right_lane)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.esd_aeb_obj = []
      for i in range(0, length):
        val1 = rospy_message_converter.msg.esd_aeb_object()
        _x = val1
        start = end
        end += 8
        (_x.esd_aeb_obj_id, _x.esd_aeb_obj_func,) = _get_struct_2I().unpack(str[start:end])
        self.esd_aeb_obj.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.esd_nop_Path.esd_nop_path_points = []
      for i in range(0, length):
        val1 = rospy_message_converter.msg.esd_nop_path_point()
        _x = val1
        start = end
        end += 12
        (_x.x, _x.y, _x.z,) = _get_struct_3f().unpack(str[start:end])
        self.esd_nop_Path.esd_nop_path_points.append(val1)
      _x = self
      start = end
      end += 14
      (_x.esd_nop_Path.esd_nop_discrete_path_length, _x.esd_nop_Path.esd_nop_discrete_path_enable, _x.esd_nop_switch, _x.esd_nop_time_meas,) = _get_struct_f2BQ().unpack(str[start:end])
      self.esd_nop_Path.esd_nop_discrete_path_enable = bool(self.esd_nop_Path.esd_nop_discrete_path_enable)
      self.esd_nop_switch = bool(self.esd_nop_switch)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.publisher_id = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.publisher_id = str[start:end]
      _x = self
      start = end
      end += 24
      (_x.publish_ptp_ts, _x.counter, _x.publish_ts,) = _get_struct_3Q().unpack(str[start:end])
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill


  def serialize_numpy(self, buff, numpy):
    """
    serialize message with numpy array types into buffer
    :param buff: buffer, ``StringIO``
    :param numpy: numpy python module
    """
    try:
      length = len(self.esd_np_Line)
      buff.write(_struct_I.pack(length))
      for val1 in self.esd_np_Line:
        _x = val1
        buff.write(_get_struct_3Q().pack(_x.esd_np_line_role, _x.esd_np_line_ld_level, _x.esd_np_line_ldw_level))
      length = len(self.esd_np_Object)
      buff.write(_struct_I.pack(length))
      for val1 in self.esd_np_Object:
        _x = val1
        buff.write(_get_struct_4Q().pack(_x.esd_np_obj_id, _x.esd_np_obj_level, _x.esd_np_obj_da, _x.esd_np_obj_elk))
      _x = self
      buff.write(_get_struct_7fB2QI2BI().pack(_x.esd_np_Path.esd_np_path_c0, _x.esd_np_Path.esd_np_path_c1, _x.esd_np_Path.esd_np_path_c2, _x.esd_np_Path.esd_np_path_c3, _x.esd_np_Path.esd_np_path_c4, _x.esd_np_Path.esd_np_path_c5, _x.esd_np_Path.esd_np_path_end, _x.esd_np_Path.esd_np_enable, _x.esd_np_Alc.esd_np_alc_crossing, _x.esd_np_Alc.esd_np_alc_sts, _x.esd_np_Alc.esd_laneChngIntent, _x.esd_np_Alc.esd_crossed_left_lane, _x.esd_np_Alc.esd_crossed_right_lane, _x.esd_nop_distance_to_Odd_boundary))
      length = len(self.esd_aeb_obj)
      buff.write(_struct_I.pack(length))
      for val1 in self.esd_aeb_obj:
        _x = val1
        buff.write(_get_struct_2I().pack(_x.esd_aeb_obj_id, _x.esd_aeb_obj_func))
      length = len(self.esd_nop_Path.esd_nop_path_points)
      buff.write(_struct_I.pack(length))
      for val1 in self.esd_nop_Path.esd_nop_path_points:
        _x = val1
        buff.write(_get_struct_3f().pack(_x.x, _x.y, _x.z))
      _x = self
      buff.write(_get_struct_f2BQ().pack(_x.esd_nop_Path.esd_nop_discrete_path_length, _x.esd_nop_Path.esd_nop_discrete_path_enable, _x.esd_nop_switch, _x.esd_nop_time_meas))
      _x = self.publisher_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self
      buff.write(_get_struct_3Q().pack(_x.publish_ptp_ts, _x.counter, _x.publish_ts))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize_numpy(self, str, numpy):
    """
    unpack serialized message in str into this message instance using numpy for array types
    :param str: byte array of serialized message, ``str``
    :param numpy: numpy python module
    """
    if python3:
      codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      if self.esd_np_Line is None:
        self.esd_np_Line = None
      if self.esd_np_Object is None:
        self.esd_np_Object = None
      if self.esd_np_Path is None:
        self.esd_np_Path = rospy_message_converter.msg.esd_np_path()
      if self.esd_np_Alc is None:
        self.esd_np_Alc = rospy_message_converter.msg.esd_np_alc()
      if self.esd_aeb_obj is None:
        self.esd_aeb_obj = None
      if self.esd_nop_Path is None:
        self.esd_nop_Path = rospy_message_converter.msg.esd_nop_path()
      end = 0
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.esd_np_Line = []
      for i in range(0, length):
        val1 = rospy_message_converter.msg.esd_np_line()
        _x = val1
        start = end
        end += 24
        (_x.esd_np_line_role, _x.esd_np_line_ld_level, _x.esd_np_line_ldw_level,) = _get_struct_3Q().unpack(str[start:end])
        self.esd_np_Line.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.esd_np_Object = []
      for i in range(0, length):
        val1 = rospy_message_converter.msg.esd_np_object()
        _x = val1
        start = end
        end += 32
        (_x.esd_np_obj_id, _x.esd_np_obj_level, _x.esd_np_obj_da, _x.esd_np_obj_elk,) = _get_struct_4Q().unpack(str[start:end])
        self.esd_np_Object.append(val1)
      _x = self
      start = end
      end += 55
      (_x.esd_np_Path.esd_np_path_c0, _x.esd_np_Path.esd_np_path_c1, _x.esd_np_Path.esd_np_path_c2, _x.esd_np_Path.esd_np_path_c3, _x.esd_np_Path.esd_np_path_c4, _x.esd_np_Path.esd_np_path_c5, _x.esd_np_Path.esd_np_path_end, _x.esd_np_Path.esd_np_enable, _x.esd_np_Alc.esd_np_alc_crossing, _x.esd_np_Alc.esd_np_alc_sts, _x.esd_np_Alc.esd_laneChngIntent, _x.esd_np_Alc.esd_crossed_left_lane, _x.esd_np_Alc.esd_crossed_right_lane, _x.esd_nop_distance_to_Odd_boundary,) = _get_struct_7fB2QI2BI().unpack(str[start:end])
      self.esd_np_Path.esd_np_enable = bool(self.esd_np_Path.esd_np_enable)
      self.esd_np_Alc.esd_crossed_left_lane = bool(self.esd_np_Alc.esd_crossed_left_lane)
      self.esd_np_Alc.esd_crossed_right_lane = bool(self.esd_np_Alc.esd_crossed_right_lane)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.esd_aeb_obj = []
      for i in range(0, length):
        val1 = rospy_message_converter.msg.esd_aeb_object()
        _x = val1
        start = end
        end += 8
        (_x.esd_aeb_obj_id, _x.esd_aeb_obj_func,) = _get_struct_2I().unpack(str[start:end])
        self.esd_aeb_obj.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.esd_nop_Path.esd_nop_path_points = []
      for i in range(0, length):
        val1 = rospy_message_converter.msg.esd_nop_path_point()
        _x = val1
        start = end
        end += 12
        (_x.x, _x.y, _x.z,) = _get_struct_3f().unpack(str[start:end])
        self.esd_nop_Path.esd_nop_path_points.append(val1)
      _x = self
      start = end
      end += 14
      (_x.esd_nop_Path.esd_nop_discrete_path_length, _x.esd_nop_Path.esd_nop_discrete_path_enable, _x.esd_nop_switch, _x.esd_nop_time_meas,) = _get_struct_f2BQ().unpack(str[start:end])
      self.esd_nop_Path.esd_nop_discrete_path_enable = bool(self.esd_nop_Path.esd_nop_discrete_path_enable)
      self.esd_nop_switch = bool(self.esd_nop_switch)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.publisher_id = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.publisher_id = str[start:end]
      _x = self
      start = end
      end += 24
      (_x.publish_ptp_ts, _x.counter, _x.publish_ts,) = _get_struct_3Q().unpack(str[start:end])
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill

_struct_I = genpy.struct_I
def _get_struct_I():
    global _struct_I
    return _struct_I
_struct_2I = None
def _get_struct_2I():
    global _struct_2I
    if _struct_2I is None:
        _struct_2I = struct.Struct("<2I")
    return _struct_2I
_struct_3Q = None
def _get_struct_3Q():
    global _struct_3Q
    if _struct_3Q is None:
        _struct_3Q = struct.Struct("<3Q")
    return _struct_3Q
_struct_3f = None
def _get_struct_3f():
    global _struct_3f
    if _struct_3f is None:
        _struct_3f = struct.Struct("<3f")
    return _struct_3f
_struct_4Q = None
def _get_struct_4Q():
    global _struct_4Q
    if _struct_4Q is None:
        _struct_4Q = struct.Struct("<4Q")
    return _struct_4Q
_struct_7fB2QI2BI = None
def _get_struct_7fB2QI2BI():
    global _struct_7fB2QI2BI
    if _struct_7fB2QI2BI is None:
        _struct_7fB2QI2BI = struct.Struct("<7fB2QI2BI")
    return _struct_7fB2QI2BI
_struct_f2BQ = None
def _get_struct_f2BQ():
    global _struct_f2BQ
    if _struct_f2BQ is None:
        _struct_f2BQ = struct.Struct("<f2BQ")
    return _struct_f2BQ
