# This Python file uses the following encoding: utf-8
"""autogenerated by genpy from rospy_message_converter/AESPathVerify.msg. Do not edit."""
import codecs
import sys
python3 = True if sys.hexversion > 0x03000000 else False
import genpy
import struct

import rospy_message_converter.msg

class AESPathVerify(genpy.Message):
  _md5sum = "d38419dee31a0a925a8eb2d94cca9532"
  _type = "rospy_message_converter/AESPathVerify"
  _has_header = False  # flag to mark the presence of a Header object
  _full_text = """uint32 plan_valid
uint32 target_valid
uint32 rout_valid
uint32 reservetime
float32 pnc_c0
float32 pnc_c1
float32 pnc_c2
float32 pnc_c3
float32 pnc_c4
float32 pnc_c5
uint32 crash_id
uint32 crash_lane
float32 aessteerangle
float32 aespncst
lanepolinomial host_left_lane
lanepolinomial host_right_lane
lanepolinomial left_edge
lanepolinomial right_edge
lpppolinomial host_lpp

================================================================================
MSG: rospy_message_converter/lanepolinomial
float32 path_c0
float32 path_c1
float32 path_c2
float32 path_c3
bool isvalid
uint32 path_type
uint32 path_color
uint32 character

================================================================================
MSG: rospy_message_converter/lpppolinomial
float32 path_c0
float32 path_c1
float32 path_c2
float32 path_c3
bool isvalid
float32 width
"""
  __slots__ = ['plan_valid','target_valid','rout_valid','reservetime','pnc_c0','pnc_c1','pnc_c2','pnc_c3','pnc_c4','pnc_c5','crash_id','crash_lane','aessteerangle','aespncst','host_left_lane','host_right_lane','left_edge','right_edge','host_lpp']
  _slot_types = ['uint32','uint32','uint32','uint32','float32','float32','float32','float32','float32','float32','uint32','uint32','float32','float32','rospy_message_converter/lanepolinomial','rospy_message_converter/lanepolinomial','rospy_message_converter/lanepolinomial','rospy_message_converter/lanepolinomial','rospy_message_converter/lpppolinomial']

  def __init__(self, *args, **kwds):
    """
    Constructor. Any message fields that are implicitly/explicitly
    set to None will be assigned a default value. The recommend
    use is keyword arguments as this is more robust to future message
    changes.  You cannot mix in-order arguments and keyword arguments.

    The available fields are:
       plan_valid,target_valid,rout_valid,reservetime,pnc_c0,pnc_c1,pnc_c2,pnc_c3,pnc_c4,pnc_c5,crash_id,crash_lane,aessteerangle,aespncst,host_left_lane,host_right_lane,left_edge,right_edge,host_lpp

    :param args: complete set of field values, in .msg order
    :param kwds: use keyword arguments corresponding to message field names
    to set specific fields.
    """
    if args or kwds:
      super(AESPathVerify, self).__init__(*args, **kwds)
      # message fields cannot be None, assign default values for those that are
      if self.plan_valid is None:
        self.plan_valid = 0
      if self.target_valid is None:
        self.target_valid = 0
      if self.rout_valid is None:
        self.rout_valid = 0
      if self.reservetime is None:
        self.reservetime = 0
      if self.pnc_c0 is None:
        self.pnc_c0 = 0.
      if self.pnc_c1 is None:
        self.pnc_c1 = 0.
      if self.pnc_c2 is None:
        self.pnc_c2 = 0.
      if self.pnc_c3 is None:
        self.pnc_c3 = 0.
      if self.pnc_c4 is None:
        self.pnc_c4 = 0.
      if self.pnc_c5 is None:
        self.pnc_c5 = 0.
      if self.crash_id is None:
        self.crash_id = 0
      if self.crash_lane is None:
        self.crash_lane = 0
      if self.aessteerangle is None:
        self.aessteerangle = 0.
      if self.aespncst is None:
        self.aespncst = 0.
      if self.host_left_lane is None:
        self.host_left_lane = rospy_message_converter.msg.lanepolinomial()
      if self.host_right_lane is None:
        self.host_right_lane = rospy_message_converter.msg.lanepolinomial()
      if self.left_edge is None:
        self.left_edge = rospy_message_converter.msg.lanepolinomial()
      if self.right_edge is None:
        self.right_edge = rospy_message_converter.msg.lanepolinomial()
      if self.host_lpp is None:
        self.host_lpp = rospy_message_converter.msg.lpppolinomial()
    else:
      self.plan_valid = 0
      self.target_valid = 0
      self.rout_valid = 0
      self.reservetime = 0
      self.pnc_c0 = 0.
      self.pnc_c1 = 0.
      self.pnc_c2 = 0.
      self.pnc_c3 = 0.
      self.pnc_c4 = 0.
      self.pnc_c5 = 0.
      self.crash_id = 0
      self.crash_lane = 0
      self.aessteerangle = 0.
      self.aespncst = 0.
      self.host_left_lane = rospy_message_converter.msg.lanepolinomial()
      self.host_right_lane = rospy_message_converter.msg.lanepolinomial()
      self.left_edge = rospy_message_converter.msg.lanepolinomial()
      self.right_edge = rospy_message_converter.msg.lanepolinomial()
      self.host_lpp = rospy_message_converter.msg.lpppolinomial()

  def _get_types(self):
    """
    internal API method
    """
    return self._slot_types

  def serialize(self, buff):
    """
    serialize message into buffer
    :param buff: buffer, ``StringIO``
    """
    try:
      _x = self
      buff.write(_get_struct_4I6f2I6fB3I4fB3I4fB3I4fB3I4fBf().pack(_x.plan_valid, _x.target_valid, _x.rout_valid, _x.reservetime, _x.pnc_c0, _x.pnc_c1, _x.pnc_c2, _x.pnc_c3, _x.pnc_c4, _x.pnc_c5, _x.crash_id, _x.crash_lane, _x.aessteerangle, _x.aespncst, _x.host_left_lane.path_c0, _x.host_left_lane.path_c1, _x.host_left_lane.path_c2, _x.host_left_lane.path_c3, _x.host_left_lane.isvalid, _x.host_left_lane.path_type, _x.host_left_lane.path_color, _x.host_left_lane.character, _x.host_right_lane.path_c0, _x.host_right_lane.path_c1, _x.host_right_lane.path_c2, _x.host_right_lane.path_c3, _x.host_right_lane.isvalid, _x.host_right_lane.path_type, _x.host_right_lane.path_color, _x.host_right_lane.character, _x.left_edge.path_c0, _x.left_edge.path_c1, _x.left_edge.path_c2, _x.left_edge.path_c3, _x.left_edge.isvalid, _x.left_edge.path_type, _x.left_edge.path_color, _x.left_edge.character, _x.right_edge.path_c0, _x.right_edge.path_c1, _x.right_edge.path_c2, _x.right_edge.path_c3, _x.right_edge.isvalid, _x.right_edge.path_type, _x.right_edge.path_color, _x.right_edge.character, _x.host_lpp.path_c0, _x.host_lpp.path_c1, _x.host_lpp.path_c2, _x.host_lpp.path_c3, _x.host_lpp.isvalid, _x.host_lpp.width))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize(self, str):
    """
    unpack serialized message in str into this message instance
    :param str: byte array of serialized message, ``str``
    """
    if python3:
      codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      if self.host_left_lane is None:
        self.host_left_lane = rospy_message_converter.msg.lanepolinomial()
      if self.host_right_lane is None:
        self.host_right_lane = rospy_message_converter.msg.lanepolinomial()
      if self.left_edge is None:
        self.left_edge = rospy_message_converter.msg.lanepolinomial()
      if self.right_edge is None:
        self.right_edge = rospy_message_converter.msg.lanepolinomial()
      if self.host_lpp is None:
        self.host_lpp = rospy_message_converter.msg.lpppolinomial()
      end = 0
      _x = self
      start = end
      end += 193
      (_x.plan_valid, _x.target_valid, _x.rout_valid, _x.reservetime, _x.pnc_c0, _x.pnc_c1, _x.pnc_c2, _x.pnc_c3, _x.pnc_c4, _x.pnc_c5, _x.crash_id, _x.crash_lane, _x.aessteerangle, _x.aespncst, _x.host_left_lane.path_c0, _x.host_left_lane.path_c1, _x.host_left_lane.path_c2, _x.host_left_lane.path_c3, _x.host_left_lane.isvalid, _x.host_left_lane.path_type, _x.host_left_lane.path_color, _x.host_left_lane.character, _x.host_right_lane.path_c0, _x.host_right_lane.path_c1, _x.host_right_lane.path_c2, _x.host_right_lane.path_c3, _x.host_right_lane.isvalid, _x.host_right_lane.path_type, _x.host_right_lane.path_color, _x.host_right_lane.character, _x.left_edge.path_c0, _x.left_edge.path_c1, _x.left_edge.path_c2, _x.left_edge.path_c3, _x.left_edge.isvalid, _x.left_edge.path_type, _x.left_edge.path_color, _x.left_edge.character, _x.right_edge.path_c0, _x.right_edge.path_c1, _x.right_edge.path_c2, _x.right_edge.path_c3, _x.right_edge.isvalid, _x.right_edge.path_type, _x.right_edge.path_color, _x.right_edge.character, _x.host_lpp.path_c0, _x.host_lpp.path_c1, _x.host_lpp.path_c2, _x.host_lpp.path_c3, _x.host_lpp.isvalid, _x.host_lpp.width,) = _get_struct_4I6f2I6fB3I4fB3I4fB3I4fB3I4fBf().unpack(str[start:end])
      self.host_left_lane.isvalid = bool(self.host_left_lane.isvalid)
      self.host_right_lane.isvalid = bool(self.host_right_lane.isvalid)
      self.left_edge.isvalid = bool(self.left_edge.isvalid)
      self.right_edge.isvalid = bool(self.right_edge.isvalid)
      self.host_lpp.isvalid = bool(self.host_lpp.isvalid)
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill


  def serialize_numpy(self, buff, numpy):
    """
    serialize message with numpy array types into buffer
    :param buff: buffer, ``StringIO``
    :param numpy: numpy python module
    """
    try:
      _x = self
      buff.write(_get_struct_4I6f2I6fB3I4fB3I4fB3I4fB3I4fBf().pack(_x.plan_valid, _x.target_valid, _x.rout_valid, _x.reservetime, _x.pnc_c0, _x.pnc_c1, _x.pnc_c2, _x.pnc_c3, _x.pnc_c4, _x.pnc_c5, _x.crash_id, _x.crash_lane, _x.aessteerangle, _x.aespncst, _x.host_left_lane.path_c0, _x.host_left_lane.path_c1, _x.host_left_lane.path_c2, _x.host_left_lane.path_c3, _x.host_left_lane.isvalid, _x.host_left_lane.path_type, _x.host_left_lane.path_color, _x.host_left_lane.character, _x.host_right_lane.path_c0, _x.host_right_lane.path_c1, _x.host_right_lane.path_c2, _x.host_right_lane.path_c3, _x.host_right_lane.isvalid, _x.host_right_lane.path_type, _x.host_right_lane.path_color, _x.host_right_lane.character, _x.left_edge.path_c0, _x.left_edge.path_c1, _x.left_edge.path_c2, _x.left_edge.path_c3, _x.left_edge.isvalid, _x.left_edge.path_type, _x.left_edge.path_color, _x.left_edge.character, _x.right_edge.path_c0, _x.right_edge.path_c1, _x.right_edge.path_c2, _x.right_edge.path_c3, _x.right_edge.isvalid, _x.right_edge.path_type, _x.right_edge.path_color, _x.right_edge.character, _x.host_lpp.path_c0, _x.host_lpp.path_c1, _x.host_lpp.path_c2, _x.host_lpp.path_c3, _x.host_lpp.isvalid, _x.host_lpp.width))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize_numpy(self, str, numpy):
    """
    unpack serialized message in str into this message instance using numpy for array types
    :param str: byte array of serialized message, ``str``
    :param numpy: numpy python module
    """
    if python3:
      codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      if self.host_left_lane is None:
        self.host_left_lane = rospy_message_converter.msg.lanepolinomial()
      if self.host_right_lane is None:
        self.host_right_lane = rospy_message_converter.msg.lanepolinomial()
      if self.left_edge is None:
        self.left_edge = rospy_message_converter.msg.lanepolinomial()
      if self.right_edge is None:
        self.right_edge = rospy_message_converter.msg.lanepolinomial()
      if self.host_lpp is None:
        self.host_lpp = rospy_message_converter.msg.lpppolinomial()
      end = 0
      _x = self
      start = end
      end += 193
      (_x.plan_valid, _x.target_valid, _x.rout_valid, _x.reservetime, _x.pnc_c0, _x.pnc_c1, _x.pnc_c2, _x.pnc_c3, _x.pnc_c4, _x.pnc_c5, _x.crash_id, _x.crash_lane, _x.aessteerangle, _x.aespncst, _x.host_left_lane.path_c0, _x.host_left_lane.path_c1, _x.host_left_lane.path_c2, _x.host_left_lane.path_c3, _x.host_left_lane.isvalid, _x.host_left_lane.path_type, _x.host_left_lane.path_color, _x.host_left_lane.character, _x.host_right_lane.path_c0, _x.host_right_lane.path_c1, _x.host_right_lane.path_c2, _x.host_right_lane.path_c3, _x.host_right_lane.isvalid, _x.host_right_lane.path_type, _x.host_right_lane.path_color, _x.host_right_lane.character, _x.left_edge.path_c0, _x.left_edge.path_c1, _x.left_edge.path_c2, _x.left_edge.path_c3, _x.left_edge.isvalid, _x.left_edge.path_type, _x.left_edge.path_color, _x.left_edge.character, _x.right_edge.path_c0, _x.right_edge.path_c1, _x.right_edge.path_c2, _x.right_edge.path_c3, _x.right_edge.isvalid, _x.right_edge.path_type, _x.right_edge.path_color, _x.right_edge.character, _x.host_lpp.path_c0, _x.host_lpp.path_c1, _x.host_lpp.path_c2, _x.host_lpp.path_c3, _x.host_lpp.isvalid, _x.host_lpp.width,) = _get_struct_4I6f2I6fB3I4fB3I4fB3I4fB3I4fBf().unpack(str[start:end])
      self.host_left_lane.isvalid = bool(self.host_left_lane.isvalid)
      self.host_right_lane.isvalid = bool(self.host_right_lane.isvalid)
      self.left_edge.isvalid = bool(self.left_edge.isvalid)
      self.right_edge.isvalid = bool(self.right_edge.isvalid)
      self.host_lpp.isvalid = bool(self.host_lpp.isvalid)
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill

_struct_I = genpy.struct_I
def _get_struct_I():
    global _struct_I
    return _struct_I
_struct_4I6f2I6fB3I4fB3I4fB3I4fB3I4fBf = None
def _get_struct_4I6f2I6fB3I4fB3I4fB3I4fB3I4fBf():
    global _struct_4I6f2I6fB3I4fB3I4fB3I4fB3I4fBf
    if _struct_4I6f2I6fB3I4fB3I4fB3I4fB3I4fBf is None:
        _struct_4I6f2I6fB3I4fB3I4fB3I4fB3I4fBf = struct.Struct("<4I6f2I6fB3I4fB3I4fB3I4fB3I4fBf")
    return _struct_4I6f2I6fB3I4fB3I4fB3I4fB3I4fBf
